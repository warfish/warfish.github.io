<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>My worklog</title>
 <link href="warfish.github.io/atom.xml" rel="self"/>
 <link href="warfish.github.io/"/>
 <updated>2015-01-28T17:57:35+06:00</updated>
 <id>warfish.github.io</id>
 <author>
   <name>Evgeny Yakovlev</name>
   <email></email>
 </author>

 
 <entry>
   <title>Hello github.io</title>
   <link href="warfish.github.io//2015/01/27/hello-github-pages/"/>
   <updated>2015-01-27T00:00:00+06:00</updated>
   <id>warfish.github.io/2015/01/27/hello-github-pages</id>
   <content type="html">&lt;p&gt;Hi, here&amp;#39;s some code &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Hello world&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Сосуществование UEFI и линуксового ядра для пребутовой авторизации с помощью гипервизора</title>
   <link href="warfish.github.io//2014/11/17/d181d0bed181d183d189d0b5d181d182d0b2d0bed0b2d0b0d0bdd0b8d0b5-uefi-d0b8-d0bbd0b8d0bdd183d0bad181d0bed0b2d0bed0b3d0be-d18fd0b4d180d0b0/"/>
   <updated>2014-11-17T13:20:53+06:00</updated>
   <id>warfish.github.io/2014/11/17/d181d0bed181d183d189d0b5d181d182d0b2d0bed0b2d0b0d0bdd0b8d0b5-uefi-d0b8-d0bbd0b8d0bdd183d0bad181d0bed0b2d0bed0b3d0be-d18fd0b4d180d0b0</id>
   <content type="html">&lt;p&gt;Использование линуксового ядра как богатой платформы для поддержки пребутовой аутентификации на UEFI железе ограничено конфликтом управления машиной - и UEFI и ядро хотят управлять физической памятью и переферией, а ExitBootServices сделать нельзя потому что потом нужно вернуться в UEFI и продолжить загрузку хостовой ОС без перезагрузки машины. Я ранее накидывал &lt;a href=&quot;http://wrfsh.wordpress.com/2014/06/06/linux-on-efi-wo-reboot/&quot;&gt;идеи&lt;/a&gt; как можно обойти эту проблему. Теперь родился новый вариант, связанный с &lt;a href=&quot;http://wrfsh.wordpress.com/2014/11/07/%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F/&quot;&gt;виртуализацией&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Потенциальное решение базируется на self-contained type-2 гипервизоре, т.е. гипервизоре хостящемся не напрямую на железе, а на существующей софтверной платформе, которая управляет страничной памятью, в данном случае UEFI. Такой гипервизор стартует как UEFI приложение и начинает драйвить VT железо платформы. Создается виртуальный сендбокс, в который загружается ядро. Управление ресурсами происходит следующим образом:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Страничная память. Виртуализация добавляет еще один уровень виртуальной памяти: гипервизор мапит то, что ядро видит как непрерывный физический диапазон линейный адресов. Таким образом UEFI и ядро можно развести на уровне гипервизора не мапя страницы занатые фирмварью.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Доступ к переферийному железу. Тут есть целый ряд возможностей. Через фильтр PCI config space от ядра можно скрыть те устройства доступ к которым мы хотим ограничить (диск, фреймбуфер) и отдать те, которые фильтровать не нужно (USB, сеть). Доступ к ограниченным устройствам можно либо перехватывать через I/O пространство (включая DMA), либо скрыть насовсем и написать драйвера для линукса, которые знают про гипервизор и делают явные гиперколлы, реализация которых опирается на драйвера фирмвари. Тут есть потенциальные грабли - если идти по пути полной фильтрации, то информация о PCI устройстве иногда есть и в ACPI помимо PCI Config Space.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Обработка прерываний. Тут сложнее - если гипервизор хостится на фирмвари, то фирмварь должна видеть прерывания. Ядро тоже должно видеть прерывания для нормальной работы. Этот момент еще до конца не изучен, но есть несколько вариантов, среди которых например эмуляция legacy контроллера прерываний для ядра на базе кода из qemu. Ядро можно собрать с отключенной поддержкой SMP, APIC, IOAPIC, что значительно упрощает жизнь. При этом прерывания от PCI линий, маршрутизируемые через IOAPIC, работать конечно не будут, но ядро готово к этому через irqpoll. Теоретически можно разрешить IOAPIC, но тогда конфликты с фирмварью неизбежны. Придется заниматься жестким переключением контекста при возврате в фирмварь.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ExitBootServices. Ядро можно собрать как UEFI приложение чтобы выкинуть этап загрузчика. Такое ядро загружается в виртуальном окружении и хочет позвать ряд функций фирмвари. Сделать это ему будет проблематично, потому как код фирмвари &lt;em&gt;не мапится&lt;/em&gt; в виртуализованное физическое пространство ядра (см п.1). Решение простое - в ядре есть слой fake firmware, который можно реализовать самостоятельно и слинковать с ядром таким образом подставив свою реализацию ExitBootServices и пары других UEFI функций, которые уже могут делать что угодно, например бежать в гипервизор.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;При передаче управления в хостовую ОС такой гипервизор, будучи хостящимся на UEFI, можно легко свернуть вместе с ядром и отдать машину обратно в UEFI а затем в хостовую ОС. Теоретически можно не сворачивать гипервизор до того как хостовая ОС не сделает ExitBootServices. Это позволит, например, эмулировать интерфейсы фирмвари через линуксовое ядро в процессе загрузки хостовой ОС в случае если это проще чем решить проблему с состоянием переферии. Но это уже совсем адвансед :)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Естественно такое решение упирается в первую очередь в аппаратную поддержку, но его необходимость видится именно для UEFI платформ - для legacy BIOS можно, хоть и менее красиво, решить задачу и без использования виртуализации.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Виртуализация</title>
   <link href="warfish.github.io//2014/11/07/d0b2d0b8d180d182d183d0b0d0bbd0b8d0b7d0b0d186d0b8d18f/"/>
   <updated>2014-11-07T11:52:05+06:00</updated>
   <id>warfish.github.io/2014/11/07/d0b2d0b8d180d182d183d0b0d0bbd0b8d0b7d0b0d186d0b8d18f</id>
   <content type="html">&lt;p&gt;Виртуализация, в разрезе технологии интеловских процессоров, позволяет делать ряд интересных вещей. Сам принцип такой - процессор входит в режим vm набором инструкций, после чего код гипервизора перемещается в ring -1, затем работа продолжается как обычно. Гипервизор, оставаясь резидентным в ring -1 может получать управление разными способами:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Периодически, перехватив прерывания или через preemption timer.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Синхронно через механизм vm-call-ов который реализуется самим гипервизором и используется модифицированной ОС или драйвером в ней, т.е. агентом в ring 0, который знает о гипервизоре.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Асинхронно по возникновению интересующих гипервизора событий от нормальной работы немодифицированного кода.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Последний механизм самый интересный. Код гипервизора может перехватывать ряд интересных для него событий, которые генерирует нормальная работа немодифицированного кода всех менее привелигерованных режимов. Когда эти события возникают, то процессор делает т.н. vmexit, т.е. возврат в ring -1 и передачу управления хендлеру гипервизора. Механизм похож на exception handler, но регистрация на интересующие исключения происходит по-другому. Что можно перехватывать - много чего, но вот одни из самых интересных вещей:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Обращения к физической памяти. В режиме виртуализации то что ОС в ring 0 видит как физическую память на самом деле виртуальные адреса смаппированные гипервизором. Ring 0 продолжает нормально работать с этой памятью как с физической, мапить ее на виртуальные адреса, но на самом деле трансляция в физический адрес проходит через дополнительную таблицу страниц гипервизора, у которого есть возможность при маппировании физической страницы указать флагами генерацию исключения и vmexit при доступе к этой странице на R/W/X. В результате можно перехватывать любые обращения гостевой ОС к интересующему диапазону адресов.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I/O адресное пространство. При инициализации гипервизор может задать битовую маску на весь диапазон I/O портов x86 (почти на весь - у интела баг, который не позволяет захватить два последних бита в маске). Эффект тот же что и с памятью - vmexit при попытке обращения к I/O порту. Это дает дополнительную возможность перехвата одного из способов обращения к PCI Configuration Space, о котором позже.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MSR - vmexit при попытке R/W на интересующий регистр.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Еще несколько дополнительных триггеров, включая обращения к XMM/FPU контексту, CPUID, GDT, LDT, IDT, CR регистры.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Все это позволяет гипервизору эмулировать отдельную песочницу для каждого из гостей,аллоцировать ресурсы и переключать выполнение между несколькими гостями, фильтровать и перенаправлять прерывания и т.д. без модификации самих гостей. А еще это позволяет перехватывать весь доступ гостя к ACPI, PCI и MSR, - т.е. всеми каналами управления переферийным железом и чипсетами, что открывает интересные возможности по фильтрации доступа к железу. Можно спрятать PCI устройство, можно нарисовать свое фейковое устройство и т.д. Это открывает дополнительные прикладные возможности виртуализации, помимо очевидной основной, в рамках одного гостя.&lt;/p&gt;

&lt;p&gt;Например можно попытаться решить проблему с &amp;quot;богатым пребутом&amp;quot; - запустить линукс с возвратом в фирмварь без потери состояния железа, через жесткий ACPI и PCI фильтр и редирект запросов на допустимые устройства в драйвер фирмвари. В случае UEFI можно попытаться не делать выход из бут сервисов, а отобрать у фирмвари процессор на время, защитить ее память и запустить ядро линукса.&lt;/p&gt;

&lt;p&gt;Но одна из самых интересных прикладных задач для меня это инструменты, точнее дебаггер с элементами гипервизора для бареметал. Типичный механизм брейкпоинтов и вочпоинтов подразумевает, что ты знаешь адрес, по которому должен сработать выход в дебаггер. В случае отлаживания и исследования неизвестного кода, например фирмвари, адреса заранее не известны, есть только теория что код обращается к железу / странице памяти / MSRу (например чтобы поменять GS_BASE ;)). В таких случаях нужно нечто более &amp;quot;декларативное&amp;quot;, нужно сказать что-то типа &amp;quot;я не знаю где это происходит, но как только это произойдет, то я хочу об этом знать&amp;quot;, что и позволяют в определенных пределах элементы гипервизора. Помимо отладки такой инструмент можно использовать для исследования чужого кода, в том числе вредоносного, играть с внедрением ошибок от устройств, эмулировать устройства на самом нижнем уровне для проверки устойчивости системы к ошибкам и поиска уязвимостей например.&lt;/p&gt;

&lt;p&gt;Основной недостаток это конечно аппаратные требования. У интела нужную технологию поддерживает уже более менее вся линейка core i процессоров второго и последующих поколений. У AMD своя технология, отдельная от интела и я про нее мало знаю, кроме того что общий смысл тот же, а опкоды другие. У ARM-ов тоже недавно появился TrustZone, который по сути тот же ring -1.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>SMM баги биоса</title>
   <link href="warfish.github.io//2014/09/12/smm-d0b1d0b0d0b3d0b8-d0b1d0b8d0bed181d0b0/"/>
   <updated>2014-09-12T10:59:05+07:00</updated>
   <id>warfish.github.io/2014/09/12/smm-d0b1d0b0d0b3d0b8-d0b1d0b8d0bed181d0b0</id>
   <content type="html">&lt;p&gt;Есть подозрение на аппаратный/SMM баг USB Legacy Support на Dell Optiplex 790.&lt;/p&gt;

&lt;p&gt;Имеем данную машину и подключенные к ней USB клаву и мышь, которые работают через виртуальный 8042 PS/2 контроллер через USB Legacy Support. Биос настраивает виртуальный 8042 так, что сканирование KBD порта разрешено, а сканирование AUX порта отключено. Хучим в риалмодной IDT IRQ1 (PS/2 KBD port interrupt) и IRQ12 (PS/2 AUX port interrupt) исключая код биоса. Хук IRQ1 предсказуемо срабатывает на клавиатурные события, а хук IRQ12 предсказуемо молчит на мышиные события. Затем включаем на контроллере сканирование AUX порта. Сразу после этого контроллер перестает триггерить &lt;em&gt;все&lt;/em&gt; IRQ, нет событий ни от клавы ни от мыши. Все из реального режима.&lt;/p&gt;

&lt;p&gt;Замена IRQ хендлеров в IDT исключает ring0 код биоса. Код включения сканирования порта крайне простой и работает на всех остальных конфигурациях. Остается только SMM код биоса (USB Legacy Support генерирует SMI) и аппаратную реализацию. __&lt;/p&gt;

&lt;p&gt;Решить эту проблему нельзя, ее можно только обойти. Для этого нужно сначала отключить USB legacy support, а затем инициализировать PS/2 драйвера уже для настоящего контроллера. Отключение legacy support на EHCI происходит через машину состояний:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;В определенном регистре контроллера OS выставляет бит &amp;quot;я хочу контроллер&amp;quot;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Срабатывает SMM прерывание в котором биос должен подготовить контроллер к передаче и сбросить другой бит &amp;quot;биос отдал контроллер&amp;quot;. Как только этот бит выставлен процесс передачи контроллера можно считать законченным.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;На этой машине сидят два EHCI контроллера. Один из них успешно прошел этот процесс, а второй отказывается сбрасывать бит владения биосом. При этом видно, что SMM прерывания с него перестали работать, т.е. биос его реально отдал. Эту проблему решил уже апдейт биоса :)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>IDA Pro needs a reality check</title>
   <link href="warfish.github.io//2014/09/01/ida-pro-needs-a-reality-check/"/>
   <updated>2014-09-01T23:06:37+07:00</updated>
   <id>warfish.github.io/2014/09/01/ida-pro-needs-a-reality-check</id>
   <content type="html">&lt;p&gt;На выходных решил вспомнить молодость и поиграть в &lt;a href=&quot;http://eu.blizzard.com/ru-ru/games/d2/&quot;&gt;diablo 2&lt;/a&gt;. Купил, запустил и у меня чуть не вытек глаз от 800х600 на моем 16:9 мониторе. Нашел фанатский resolution патч, но он крашится. Решил поставить дизассемблер на игровой комп, чтобы разобраться (патч не опенсурсный). Оказалось, что hopper v3 более не поддерживает винду, поэтому я скачал бесплатную Иду. И тут у меня вытек второй глаз. Бесплатная ида почти неюзабельна и наверное она лучший мотиватор купить платную, если ты уже пользовался платной и знаешь насколько она лучше. Но платная ида совсем уж платная, в смысле нереально дорогая.&lt;/p&gt;

&lt;p&gt;Поэтому я выгуглил медузу: &lt;a href=&quot;https://github.com/wisk/medusa&quot;&gt;https://github.com/wisk/medusa&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Иде невыносимо нужен конкурент под винду, желательно опенсурсный, чтобы она стала ближе к реальности. Медуза полна шероховатостей, но я надеюсь начать ей пользоваться плотнее и контрибутить по мере возможности. В ней уже проделано очень много работы.  &lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>For loop is fine</title>
   <link href="warfish.github.io//2014/06/11/for-loop-is-fine/"/>
   <updated>2014-06-11T00:00:53+07:00</updated>
   <id>warfish.github.io/2014/06/11/for-loop-is-fine</id>
   <content type="html">&lt;p&gt;Часто приходится писать такой код:&lt;/p&gt;

&lt;blockquote&gt;

&gt;     
&gt;     void ProcessAll(element_t* elements, size_t total)
&gt;     {
&gt;         for (size_t i = 0; i &lt; total; ++i)
&gt;         {
&gt;             ProcessElement(elements[i]);
&gt;         }
&gt;     }
&gt; 
&gt; 
&lt;/blockquote&gt;

&lt;p&gt;So far so good. Но затем нужно обычно написать еще нечто вроде:&lt;/p&gt;

&lt;blockquote&gt;

&gt;     
&gt;     void PrintAll(element_t* elements, size_t total)
&gt;     {
&gt;         for (size_t i = 0; i &lt; total; ++i)
&gt;         {
&gt;             PrintElement(elements[i]);
&gt;         }
&gt;     }
&gt; 
&gt; 
&lt;/blockquote&gt;

&lt;p&gt;И тут срабатывает инстинкт &amp;quot;где-то я это уже видел&amp;quot;, и, вспоминая какой-нибудь SICP, хочется выделить итерацию отдельно и написать:&lt;/p&gt;

&lt;blockquote&gt;

&gt;     
&gt;     void ForEachElement(element_t* elements, size_t total, 
&gt;                         ElementCallbackFptr callback, void* context)
&gt; 
&gt; 

&gt;     
&gt;     {
&gt;         for (size_t i = 0; i &lt; total; ++i)
&gt;         {
&gt;             callback(elements[i], context);
&gt;         }
&gt;     }
&gt; 
&gt; 
&lt;/blockquote&gt;

&lt;p&gt;И начать переписывать ProcessAll и PrintAll через ForEachElement + callback собирая со стека весь контекст в context.
Такой код выглядит красиво, общее абстрагировано, частное параметризировано.&lt;/p&gt;

&lt;p&gt;Но затем такой код нужно читать кому-то другому, обязательно под дедлайном с целью быстро найти и исправить баг. И тут у читающего начинаются проблемы:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Итерация визуально отделена от обработки каждого элемента.
Callback отдельная функция, а не код внутри цикла и визуально он вынесен из скоупа цикла. Приходится прыгать по файлу с целью найти функцию обработки каждого элемента, помнить какая реализация callback соответствует какому из вызовов ForEachElement. Это не дает читающему видеть весь контекст алгоритма сразу, а держать в голове дополнительный контекст и вспоминать его заново каждый раз.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;void* context в лучшем случае структура, специфичная для каждой реализации callback (в худшем абстрактный интерфейс).
В эту структуру как правило со стека рядом с вызовом ForEachElement упаковываются параметры. Читающему нужно помнить еще один контекст - какой параметр куда присвоен в структуре и чему соответствует на самом деле в реализации callback.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Порог вхождения в то как автор называет итерацию.
Цикл for в типичном виде парсится более-менее опытным кодером за один проход. Он не вчитывается в символы, не выясняет их значения, а сразу видит семантику - автор проходит по всем элементам. For это базовая конструкция языка понятная всем. В случае когда автор выделил итерацию отдельно появляется порог вхождения - как именно автор назвал свой аккуратно вырезанный for - ForEach, Enumerate, Walk? Можно сказать, что поняв это один раз можно уже не напрягаться в следующий, но ведь for понимать не надо и в самый первый раз и во все последующие. К тому же код редко читается как книга, в основном читается одна функция за раз с целью найти проблему. Если систему делают несколько авторов, каждый из которых делает свою итерацию, то за одним ForEach следует другой Enumerate уже от другого автора и порог вхождения начинает расти.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;В итоге абстрагировать простейший цикл for может и выглядит красиво при написании кода, но создает только проблемы тому, кто хочет разобраться что происходит.
Если итерация не простая? Я стараюсь в таком случае делать код &amp;quot;максимально совместимым&amp;quot; с for делая для своих элементов First(), Next() и End().&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Possible solution to Linux on EFI w/o reboot</title>
   <link href="warfish.github.io//2014/06/06/linux-on-efi-wo-reboot/"/>
   <updated>2014-06-06T11:26:19+07:00</updated>
   <id>warfish.github.io/2014/06/06/linux-on-efi-wo-reboot</id>
   <content type="html">&lt;p&gt;Как можно реализовать линукс без перезагрузки на EFI:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;При передаче управления из EFI в Linux нужно проделать ряд операций:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Позвать DisconnectController чтобы отключить все драйвера периферийных устройств (ввод/вывод, сеть, диск, USB)&lt;/li&gt;
&lt;li&gt;Получить актуальную карту памяти EFI и сохранить как ее, так и саму память, занятую EFI. По возможности сдампить ее на диск&lt;/li&gt;
&lt;li&gt;Отключить прерывания, сохранить адрес IDT фирмвари и настройки контроллера прерываний.&lt;/li&gt;
&lt;li&gt;Сохранить весь контекст выполнения (сегменты, регистры, адрес стека, etc.), примерно тоже самое что и setjmp/makecontext&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Запустить ядро, юзермодный аппликейшен.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Позвать kexec чтобы выполнить код в защищенном режиме который:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Восстанавливает карту памяти и память фирмвари сохраненную в пункте 1.b.&lt;/li&gt;
&lt;li&gt;Восстановить IDT фирмвари и настройки контроллера прерываний сохраненные в пункте 1.c.&lt;/li&gt;
&lt;li&gt;Восстановить контекст выполнения из пункта 1.d. (по сути сделать longjmp/setcontext), включить прерывания.&lt;/li&gt;
&lt;li&gt;Позвать ConnectController для подключения драйверов к периферийным устройствам.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Суть подхода в том, чтобы рассматривать контекст выполнения фирмвари как выгружаемую задачу, сохранить и выгрузить ее, а затем восстановить обратно. Теоретически можно даже модифицировать планировщик задач ядра так чтобы он часть грязной работы сделал сам. DisconnectController / ConnectController в теории позволяет решить проблему с состоянием железа после возврата из ядра, т.к. ConnectController должен заново запустить инициализацию драйверов фирмвари, которые должны привести свои девайсы в известное состояние.&lt;/p&gt;

&lt;p&gt;Весь подход держится на поведении ConnectController и драйверов фирмвари. Если они не следуют EFI Driver Binding модели, что теоретически возможно, то переинициализация устройств будет затруднительной. Как показала практика, в реальности опасно опираться на соответствие фирмвари чему-то из советов UEFI спецификации.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Почему C++ в ядрах это плохо</title>
   <link href="warfish.github.io//2014/04/25/d0bfd0bed187d0b5d0bcd183-c-d0b2-d18fd0b4d180d0b0d185-d18dd182d0be-d0bfd0bbd0bed185d0be/"/>
   <updated>2014-04-25T22:19:43+07:00</updated>
   <id>warfish.github.io/2014/04/25/d0bfd0bed187d0b5d0bcd183-c-d0b2-d18fd0b4d180d0b0d185-d18dd182d0be-d0bfd0bbd0bed185d0be</id>
   <content type="html">&lt;p&gt;Вот занимательные высказывания торвальдса насчет C++: &lt;a href=&quot;http://harmful.cat-v.org/software/c++/linus&quot;&gt;http://harmful.cat-v.org/software/c++/linus&lt;/a&gt;. Я как и все люблю почитать их и поржать, но не так давно я понял что он прав.&lt;/p&gt;

&lt;p&gt;В низкоуровневых проектах, типа ядер ОС, прошивок, пребутов и т.д. C++ это действительно опасный выбор если подойти со стороны отладки. В таких окружениях часто лучшее на что можно надеяться это дизассемблер. В таком случае, уставившись в голые инструкции, очень полезно понимать что третья по счету инструкция call это скорее всего третий по счету вызов функции в исходнике или суметь найти на стеке нужную локальную переменную. Чтобы этого достичь нужно чтобы high level language был настолько предсказуемо транслируем в ассемблер насколько это возможно при учете оптимизирующих компиляторов.&lt;/p&gt;

&lt;p&gt;C++ во все поля с виртуальными функциями, шаблонами, конструкторами, операторами, перегрузками, контейнерами и развесистыми объектами порождает громадное количество невидимых вызовов, стековых аллокаций, символов, inderect call-ов, pointer chasing-а и прочей радости. В результате понять где же происходит тот самый вызов функции или где на стеке находится нужная переменная становится сильно сложнее, на порядок. Достаточно посмотреть что порождает BOOST&lt;em&gt;SCOPE&lt;/em&gt;EXIT и потерять надежду отладить что-нибудь дизассемблером навсегда. Писать на плюсах можно продуктивнее и надежнее чем на Си например, но такая выгода потом оборачивается потерянными днями проведенными за (безуспешной) отладкой дампов.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>EFI toolkit</title>
   <link href="warfish.github.io//2014/03/17/efi-toolkit/"/>
   <updated>2014-03-17T13:32:17+07:00</updated>
   <id>warfish.github.io/2014/03/17/efi-toolkit</id>
   <content type="html">&lt;p&gt;До того как Intel открыл TianoCore и вокруг него развился EDK был EFI toolkit:
&lt;a href=&quot;http://sourceforge.net/p/efi-toolkit/code/HEAD/tree/trunk/efi-toolkit/&quot;&gt;http://sourceforge.net/p/efi-toolkit/code/HEAD/tree/trunk/efi-toolkit/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Гораздо более легковесный проект чем EDK, содержит EFI спеку в хедерах, порты libc, libm, libsocket, libz, реализацию TCP/IP стека и тонкую convinience wrapper library в виде libefi. Причем порт libc, в отличии от EDK, зависим только от спеки и libefi. В общем то что мне и нужно было всегда, но есть минусы:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;С появлением EDK на проект забили, последние коммиты датируются концом 2006 года. Версия спецификации в хедерах 1.3.что-то.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Нет GNU мейкфайлов, только nmake.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Я сделал себе бранч: &lt;a href=&quot;https://github.com/warfish/uefi-toolkit&quot;&gt;https://github.com/warfish/uefi-toolkit
&lt;/a&gt;Пока планирую сделать сборку под юниксы, стряхнуть пыль и обновить хедера до UEFI spec 2.4.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>EFI libc</title>
   <link href="warfish.github.io//2014/03/11/efi-libc/"/>
   <updated>2014-03-11T23:40:20+07:00</updated>
   <id>warfish.github.io/2014/03/11/efi-libc</id>
   <content type="html">&lt;p&gt;EDK преследует архитектуру library classes, которая позволяет им обернуть самый безобидный интерфейс, типа ASSERT, в полиморфную библиотеку у которой есть один интерфейс и много реализаций. Конкретная &amp;quot;инстанциация&amp;quot; этого полиморфного интерфейса задается в их билд системе через DSC файл. Реализация C99 stdlib, &lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/&quot;&gt;EDK/StdLib&lt;/a&gt;, которую они взяли из Open/Net/Free BSD и жестко мутировали, работает также. Например memcmp у них &lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/LibC/String/Comparison.c#l29&quot;&gt;реализована&lt;/a&gt; через BaseMemoryLib/CompareMem. Такая архитектура позволяет им задавать реализации библиотек для разных этапов загрузки системы (Pei, Dxe, Bbs, Runtime) и местами кажется очень мощной. Но не понятно зачем она нужна в stdlib если они ограничили линковку своей реализации только до EFI_APPLICATION, т.е. только до стадии boot loader-а. Если по-другому, то в результате из реализацию нельзя линковать с EFI драйвером например, хотя бы ради того же memcmp.&lt;/p&gt;

&lt;p&gt;Еще один неприятный момент в их реализации - она зависит от EFI shell. В реализации stdio у них скорее всего встал вопрос, как интерпретировать файловые пути где-нибудь в fopen? Ответ такой - через шелл. Их реализация реализует (sic) NetBSD сисколлы через &amp;quot;драйвера устройств&amp;quot;, которые показывают на &lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/LibC/Uefi/Devices/UefiShell/daShell.c&quot;&gt;маппинги файловых систем в шелле&lt;/a&gt;. В результате проблема решена, но появляется жесткая зависимость от шелла. Эта зависимость явно отражена в &lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/LibC/Main/Main.c#l131&quot;&gt;реализации точки входа&lt;/a&gt;. Также шелл позволяет им ввести понятие аргументов командной строки.&lt;/p&gt;

&lt;p&gt;Есть еще россыпь проблем поменьше: типа неготовность их хедеров к компиляции в плюсовом юните трансляции, переопределение флагов компиляции в inf файле, реализация realloc которая &lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/LibC/StdLib/Malloc.c#l40&quot;&gt;опирается&lt;/a&gt; на их же собственные приватные структуры кучи из реализации DxeCore, что делает опасным ее использование на реальном железе где куча реализована иначе. Ну и как и все остальное в EDK она непредназначена для линковки с проектами вне дерева EDK.&lt;/p&gt;

&lt;p&gt;Все это заставляет задуматься, а зачем? Возьмем например memcmp. Нужно было &lt;em&gt;выкинуть&lt;/em&gt; реализацию чтобы заменить ее своей, через полиморфную либу. Можно было опереться на EFI&lt;em&gt;SIMPLE&lt;/em&gt;FILE&lt;em&gt;SYSTEM в реализации fopen приняв например схему с эмуляцией дерева фс через гуиды разделов (/Volume{GUID}/...). Можно было заинвертировать зависимость опубликовав свой кастомный протокол, EDK&lt;/em&gt;LIBC_ARGS например, инстанс которого клиент бы вешал на хендл слинкованного с StdLib приложения. Тоже самое можно было бы сделать и с stdio тоже. Под эту схему и шелл бы подошел. But alas.&lt;/p&gt;

&lt;p&gt;И вот конструктивная часть поста. Мне интересно насколько трудоемкий вариант выдернуть реализацию StdLib из EDK и сделать ее зависимой только от UEFI spec. Может быть было бы проще начать с нуля, т.е. с BSD libc и портировать ее. Не знаю, но что-то сделать руки чешутся.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[UEFI] Architecture protocols and portable DXE Core</title>
   <link href="warfish.github.io//2014/01/18/uefi-architecture-protocols-and-portable-dxe-core/"/>
   <updated>2014-01-18T17:53:25+07:00</updated>
   <id>warfish.github.io/2014/01/18/uefi-architecture-protocols-and-portable-dxe-core</id>
   <content type="html">&lt;p&gt;Речь пойдет об особенности PI спецификации - архитектурных протоколах, которые осуществляют портабельность DXE core и позволяют переносить всю реализацию DXE стадии на платформы эмуляции UEFI, такие как legacy BIOS (EDK/&lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/&quot;&gt;DuetPkg&lt;/a&gt;) и Win32 (EDK/&lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/Nt32Pkg/&quot;&gt;Nt32Pkg&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Меня всегда интересовало, почему DuetPkg и Nt32Pkg, судя по их DSC файлам, по большей части состоят из бинарных модулей, ничего не знающих про эмуляцию. Наример оба эмулятора использую общую реализацию всего DXE рантайма. Как такое работает?&lt;/p&gt;

&lt;p&gt;Согласно спецификации UEFI инициализация платформы и подготовка ее к загрузке ОС осуществляется в несколько стадий:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wrfsh.files.wordpress.com/2014/01/uefifig61.gif&quot;&gt;&lt;img src=&quot;http://wrfsh.files.wordpress.com/2014/01/uefifig61.gif?w=300&quot; alt=&quot;uefifig6[1]&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Весь API, который описан в UEFI спецификации становится (полностью) доступен на стадии BDS (Boot Device Selection), когда начинает работать boot manager. Реализация этого API и его инициализация происходит, в общем случае, на стадии DXE - driver execution environment. На стадии DXE работаю несколько основных компонентов, которые нас интересуют в контексте темы поста:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DXE Core
Ядро DXE стадии, получает управление после PEI, разворачивает реализацию базы данных хендлов.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DXE Dispatcher
Занимается загрузкой драйверов из firmware volume, который был проинициализирован на стадии PEI.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Референсную реализацию DXE можно найти в &lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/MdeModulePkg/Core/Dxe/&quot;&gt;EDK/MdeModulePkg/Core/Dxe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;DXE Core реализует EFI&lt;em&gt;SYSTEM&lt;/em&gt;TABLE и все сервисы из EFI&lt;em&gt;BOOT&lt;/em&gt;SERVICES и EFI&lt;em&gt;RUNTIME&lt;/em&gt;SERVICES за счет опоры на EFI architecture protocols:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wrfsh.files.wordpress.com/2014/01/dxefoundationarchitectural1.png&quot;&gt;&lt;img src=&quot;http://wrfsh.files.wordpress.com/2014/01/dxefoundationarchitectural1.png?w=300&quot; alt=&quot;dxe+foundation+architectural[1]&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Картинка выше перегружена деталями, но в центре находится реализация DXE, которая зависит от набора архитектурных протоколов таких как EFI&lt;em&gt;CPU&lt;/em&gt;ARCH&lt;em&gt;PROTOCOL, EFI&lt;/em&gt;TIMER&lt;em&gt;ARCH&lt;/em&gt;PROTOCOL и так далее. Эти протоколы описаны в PI спецификации и немногим отличаются от протоколов из UEFI спецификации. Различия есть в драйверах, которые их реализуют: это обычные DXE boot service / DXE runtime service драйвера, однако т.к. опубликованные ими протоколы являются опорой для реализации основных boot и runtime сервисов, то они не могут рассчитывать на их полный набор на некоторых этапах своего выполнения.&lt;/p&gt;

&lt;p&gt;Становится понятной роль архитектурных протоколов - они абстрагируют базовое железо конкретной архитектурной платформы и позволяют коду в DXE core опираться на эти абстракции в реализации основных сервисов, например:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Реализация рантайм сервиса &lt;a href=&quot;http://wiki.phoenix.com/wiki/index.php/EFI_RUNTIME_SERVICES#GetTime.28.29&quot;&gt;EFI&lt;em&gt;RUNTIME&lt;/em&gt;SERVICES::GetTime()&lt;/a&gt; опирается на архитектурный протокол EFI&lt;em&gt;REAL&lt;/em&gt;TIME&lt;em&gt;CLOCK&lt;/em&gt;ARCH_PROTOCOL для доступа к аппаратному устройству wall-time clock&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Вся реализация ивентов в EFI&lt;em&gt;BOOT&lt;/em&gt;SERVICES использует EFI&lt;em&gt;TIMER&lt;/em&gt;ARCH_PROTOCOL для генерирования периодических прерываний по таймеру.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;EFI&lt;em&gt;CPU&lt;/em&gt;ARCH_PROTOCOL используется для синхронизации кешей процессора и реализации сервисов управления памятью&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Драйверы, реализующие эти протоколы, как правило находятся в firmware volume, который инициализируется на стадии PEI и информация о котором передается в DXE Core посредством списка Hand-off Block структур (HOB list), что показано в верхней части картинки выше. Я не буду сейчас заострять внимание на деталях HOB списка, скажу только что это каждый HOB представляет из себя блок данных и GUID, который позволяет интерпретировать эти данные различными клиентами на стадии инициализации DXE. При помощи HOB передается информация о доступной памяти, memory mapped firmware volume и т.п.&lt;/p&gt;

&lt;p&gt;Firmware volume был упомянут уже не раз, но его определение так и не было дано до сих пор. Firmware volume (FV) это структурированная база данных исполняемых модулей DXE, т.е. драйверов и приложений. База данных FV адресует образы по GUIDу и хранит информацию о зависимостях между различными модулями, а так же т.н. a priori list - список GUIDов образов, которые нужно загрузить при инициализации DXE в строго определенной последовательности. Драйвера архитектурных протоколов как правило и находятся в a priori list. Физически на реальной системе FV находятся в ROM и доступ к нему предоставляется через замапленый диапазон адресов физический памяти. Маппинг осуществляется на стадии PEI и информация о нем передается в HOB листе.&lt;/p&gt;

&lt;p&gt;Таким образом при старте DXE код может опираться только на рабочую физическую память, проинициализированную на стадии PEI и описанную в HOB листе. Этого достаточно  для инициализации базы данных хендлов, доступа к FV, загрузке драйверов из FV посредством DXE Dispatcher и инициализацию всех UEFI сервисов.&lt;/p&gt;

&lt;p&gt;Становится понятным список задач, которые должен выполнить эмулятор, чтобы загрузить общий код DXE:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Реализация всех архитектурных протоколов, на который опирается DXE Core&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Реализация firmware volume, доступа к нему и загрузку бинарных образов в среду эмуляции.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Реализация дополнительных драйверов, таких как block io, GOP, консолей и т.п.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Формарование корректного HOB листа и передача управления в DXE.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В этом и заключается полезная нагрузка DuetPkg и Nt32Pkg. К примеру Nt32Pkg реализует архитектурные протоколы и драйвера основных UEFI протоколов через сервисы Win32 и хранит FV как папку на файловой системе предоставляя доступ через &lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/Nt32Pkg/FvbServicesRuntimeDxe/&quot;&gt;FvbServiceRuntimeDxe&lt;/a&gt; драйвер. Реализацию аналогичных компонентов можно найти и в DuetPkg, хотя там все сложнее из-за специфики эмулятора UEFI поверх legacy BIOS, но общая схема остается неизменной.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Career suicide</title>
   <link href="warfish.github.io//2014/01/01/career-suicide/"/>
   <updated>2014-01-01T15:56:22+07:00</updated>
   <id>warfish.github.io/2014/01/01/career-suicide</id>
   <content type="html">&lt;p&gt;Я стараюсь держать этот блог строго техническим, а не личным, но раз в год можно.&lt;/p&gt;

&lt;p&gt;Я научился проходить собеседования на С++ девелопера до того как научился программировать на нем. :) Это очень просто. С++ такой язык, что можно долго радовать собеседников деталями реализации виртуальных функций, лейаутом объектов в памяти, отличием ++i от i++ и тому подобной мишурой, которая хотя и полезна, но вовсе не подразумевает способности собеседуемого решать на этом языке задачи, т.е. &lt;em&gt;программировать&lt;/em&gt;. И это не было каким-то хитрым планом, попыткой обмануть - я искренне считал что этого достаточно.&lt;/p&gt;

&lt;p&gt;До того как научится проходить собеседования на С++ девелопера я умел хорошо кодить на ANSI C. Это тоже было очень далеко от инжиниринга и дизайна чего-то большого, развесистого и требующего планирования. Почему от кодинга на сях я перешел в детали работы виртуальных функций, а не в инжиниринг? Я пытался, но от книг типа &lt;a href=&quot;http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612&quot;&gt;design patterns&lt;/a&gt;, &lt;a href=&quot;http://www.amazon.com/Object-Oriented-Software-Construction-Book-CD-ROM/dp/0136291554&quot;&gt;OOSC&lt;/a&gt; и &lt;a href=&quot;http://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871&quot;&gt;SICP&lt;/a&gt; я засыпал через каждые 20 страниц, хотя домучил все три. &lt;a href=&quot;http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670&quot;&gt;Code complete&lt;/a&gt; и &lt;a href=&quot;http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844&quot;&gt;Алгоритмы&lt;/a&gt; были интереснее, но по-настоящему интересными книгами того времени для меня были &lt;a href=&quot;http://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298&quot;&gt;Expert C&lt;/a&gt;, &lt;a href=&quot;http://www.amazon.com/Understanding-Linux-Kernel-Third-Edition/dp/0596005652&quot;&gt;LK&lt;/a&gt; и &lt;a href=&quot;http://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468&quot;&gt;LKD&lt;/a&gt; (к слову я смотрю на GNU-манифест и прочую романтику как на ребячество, а в худшем случае как на рак мозга).&lt;/p&gt;

&lt;p&gt;Теперь, когда я пытаюсь делать дизайн крупной фичи, декомпозировать ее и высосать из пальца объекты, то мозг скрипит и сопротивляется. В итоге получается в основном хорошо, но очень болезненно. Приятная, интересная и в результате более продуктивная и результативная работа для меня выглядит примерно так: у меня есть черный ящик, который что-то делает, не понятно что. Возможно понятно что он делает, но он запутан деталями. Мне нужно разобраться как с ним работать и абстрагировать его за простым API, который состоит из нескольких простых функций и структур данных. Я чувствую большое удовлетворение от такой работы: от процесса исследования ящика и от дизайна API, который, самое главное, сильно упрощает кому-то жизнь. Ящиком может быть железка, какой-то системный алгоритм вроде DMA или виртуальной памяти. Ящиком может быть какое-нибудь красно-черное дерево. Ящиком может быть непонятный баг. Так или иначе в таком направлении мозг не скрипит, а легко скользит.&lt;/p&gt;

&lt;p&gt;Все это хорошо, знать свои сильные и слабые стороны хорошо, но еще я хочу карьеру, а карьера подразумевает повышение уровня ответственности, который, как правило влечет за собой повышение уровня абстракции. И тут мне кажется, что это идет вразрез с тем что я умею хорошо и с тем, что не очень. Я конечно могу в итоге дойти до уровня чувака, который знает всю системную канализацию настолько хорошо, что может по фотографии электромагнитного излучения выполняемого кода угадать что не так и снять порчу, но это все сказки, потому что такие обычно живут в горах, требуют задавать им не больше трех вопросов в день и отрешаются от всего мирского. На самом деле в реальности они живут скорее в подвале у мамы, чем в горах, но остальное верно.&lt;/p&gt;

&lt;p&gt;Речь не идет о &amp;quot;нравится - не нравится&amp;quot;, нет в моей работе сейчас ничего, что я заставлял бы себя делать насильно, за мелкими исключениями. Если исходить из прагматических соображений, то все просто: у меня хорошо получается одно и не очень хорошо получается второе, но именно второе видится как основное, в чем нужно быть успешным, чтобы карьерно расти.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Эмуляция EFI на Win32</title>
   <link href="warfish.github.io//2013/12/23/d18dd0bcd183d0bbd18fd186d0b8d18f-efi-d0bdd0b0-win32/"/>
   <updated>2013-12-23T22:31:28+07:00</updated>
   <id>warfish.github.io/2013/12/23/d18dd0bcd183d0bbd18fd186d0b8d18f-efi-d0bdd0b0-win32</id>
   <content type="html">&lt;p&gt;В целях тестирования и облегчения отладки у нас есть эмулятор нашего &amp;quot;пребута&amp;quot; на win32. Эмулятор эмулирует некоторую нашу абстракцию платформы, которая на EFI реализована поверх EFI, а на биосе поверх эмуляции EFI :)&lt;/p&gt;

&lt;p&gt;Мне кажется, что подход с эмуляцией этого слоя начинает загонять нас в угол в некоторых местах. Все было хорошо пока эмуляция касалась только клавиатур и дисплеев. Как только возникла тема с поддержкой USB и родных EFI драйверов от вендоров определенного типа устройств (роскошь от которой мы не можем отказаться), то стал появлятся паттерн: есть простой и понятный подход это поддержать, но он режется из-за эмуляции. Мне кажется что таким образом мы начинаем терять одно из самых сильных преимуществ нашего подхода - начиная с определенного уровня у нас везде EFI. Это преимущество позволяет нам фактически &lt;strong&gt;удваивать&lt;/strong&gt; производительность, потому что мы пишем один EFI бинарник, а покрываем им сразу две платформы.&lt;/p&gt;

&lt;p&gt;Поэтому мне кажется нам нужно эмулировать EFI на win32. :) При этом нужно сохранить основное практическое преимущество эмуляции - отладка PBA студийным компилятором.&lt;/p&gt;

&lt;p&gt;*&lt;em&gt;Как это сделать. *&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;В EDK есть проект - &lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/Nt32Pkg/&quot;&gt;Nt32Pkg&lt;/a&gt;. Это софтверный эмулятор EFI окружения. Он не эмулирует PC/AT - в этом его отличие от QEmu с прошивкой. Он компилируется в exe-шник и реализует эмуляцию EFI поверх win32 сервисов. Т.е. грубо говоря аллокация памяти реализована через HeapAlloc, загрузка драйверов через LoadLibraryEx. Драйвер блочного устройства может либо транслировать реальный диск либо эмулировать его на файле. GOP и клавиатурный ввод идут непосредственно через GDI контекст окна приложения. При этом екзешник и драйвера он грузит через LoadLibraryEx, значит, &lt;em&gt;вроде бы&lt;/em&gt; его можно отлаживать. Чего в нем не хватает:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Он не эмулирует USB и не протаскивает хостовые USB девайсы. Для поддержки токенов его придется этому учить, например через &lt;a href=&quot;http://en.wikipedia.org/wiki/WinUSB&quot;&gt;WinUSB&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Он не знает про наши образы дисков, которые у нас широко начали применятся. Нужно делать BlockIo луп-девайс на наш образ диска, что в общем-то может пригодится не только в эмуляции.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Концепция работы с таким эмулятором такая, что мы запускаем на нем весь наш и EFI и эмулируемый Win32 код, т.е. ядро и PBA. Моки ядра придется делать эээ другим ядром. И мне кажется, что все это к лучшему:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Мы таким образом приходим к одной единственной реализации ядра на все три платформы - на EFI. Т.е. теперь один бинарник кроет не две а три платформы.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Так как на эмуляции запускается тот же код ядра, что и в пребуте, то это позволяет нам больше тестировать наш продакшен-кейс.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Моки, как я сказал, делаются честной EFI реализацией. Ну или подгружаемой DLL. Так или иначе моки можно, в принципе, запускать не только на эмуляторе. Возможно тут есть профит.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;EDK планируют объединение двух своих эмуляторов (&lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/Nt32Pkg/&quot;&gt;Nt32Pkg &lt;/a&gt;и &lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/UnixPkg/&quot;&gt;UnixPkg&lt;/a&gt;) в одну платформу - &lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/EmulatorPkg/&quot;&gt;EmulatorPkg&lt;/a&gt;. Что сделает нашу эмуляцию кроссплатформенной на винде и линуксе.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Конечно это не бесплатно. Но альтернатива мне видится такой, что и ядро и эмуляция начнут обрастать ненужными абстракциями в целях поддержать один и тот же код PBA, а преимущество единой платформы, позволяющее нам сейчас запускать одни бинари на двух платформах и сильно сокращающее нам выход в релиз, начнет буксовать.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;А что с PBE API.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Возникает резонный вопрос - если везде EFI, то зачем вообще нужен текущий слой абстракции, который и эмулируется сейчас на Win32 - PBE API.&lt;/p&gt;

&lt;p&gt;На мой взгляд PBE API выполняет важную роль - позволяет pba.dll быть полностью юзермодной дллкой без знания про EFI. Это делает PBA более самодостаточным, имеет больш&lt;strong&gt;и&lt;/strong&gt;е преимущества для его сборки и отладки. Тем не менее я думаю, что PBE API должен в дальнейшем развиваться в сторону &lt;a href=&quot;http://wrfsh.wordpress.com/2013/12/07/preboot-win32-process-vm/&quot;&gt;win32 process VM&lt;/a&gt;. В идеале я вижу себе такую картину: в качестве низкоуровневой платформы везде EFI, а pba.dll зависит только от Win32 API в виде kernel32.dll и т.п. Я думаю что это не практично в таком абсолюте, например несколько функций кастомного фреймбуфера PBE на порядок проще и удобнее чем gdi32.dll. Но я думаю что лучше стремится к win32 там где это оправдано практически.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Внезапно осознание</title>
   <link href="warfish.github.io//2013/12/14/d0b2d0bdd0b5d0b7d0b0d0bfd0bdd0be-d0bed181d0bed0b7d0bdd0b0d0bdd0b8d0b5/"/>
   <updated>2013-12-14T02:35:19+07:00</updated>
   <id>warfish.github.io/2013/12/14/d0b2d0bdd0b5d0b7d0b0d0bfd0bdd0be-d0bed181d0bed0b7d0bdd0b0d0bdd0b8d0b5</id>
   <content type="html">&lt;p&gt;Как так получилось, что год назад PBA был 16-ти битным приложением, которое еле влезало в ~600kb риалмодной памяти, которое нужно было отлаживать дизассемблером дампов и принтфами в ком порт, а теперь это (почти) обычное юзермодное Qt приложение с поддержкой плюсов, STL, boost, которое можно писать и отлаживать под виндой и которое весит 12 метров не считая кучу, которую еще никто даже не считал, но работает в пребуте:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wrfsh.files.wordpress.com/2013/12/w7x64-2013-12-12-12-37-4611.png&quot;&gt;&lt;img src=&quot;http://wrfsh.files.wordpress.com/2013/12/w7x64-2013-12-12-12-37-4611.png?w=300&quot; alt=&quot;w7x64-2013-12-12-12-37-461&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Что-то кажется мы хорошо поработали в этом году.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Preboot Win32 process VM</title>
   <link href="warfish.github.io//2013/12/07/preboot-win32-process-vm/"/>
   <updated>2013-12-07T13:08:59+07:00</updated>
   <id>warfish.github.io/2013/12/07/preboot-win32-process-vm</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Virtual_machine&quot;&gt;http://en.wikipedia.org/wiki/Virtual_machine&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;A process VM, sometimes called an _application virtual machine_, or _Managed Runtime Environment_ (MRE), runs as a normal application inside a host OS and supports a single process. It is created when that process is started and destroyed when it exits. Its purpose is to provide a [platform](http://en.wikipedia.org/wiki/System_platform)-independent programming environment that abstracts away details of the underlying hardware or operating system, and allows a program to execute in the same way on any platform.&lt;/blockquote&gt;

&lt;p&gt;Process VM эмулирует окружение для иденственного процесса. Эмуляция заключается в основном в реализации ABI платформы и стоящего за ним рантайма. Под ABI в данном случае подразумеваются как правило механизм и реализация подобия системных вызовов платформы. Если хостовая &lt;a href=&quot;http://en.wikipedia.org/wiki/Industry_Standard_Architecture&quot;&gt;ISA&lt;/a&gt; отличается от той, для которой собран таргет, то тогда эмуляция включает в себя и бинарную трансляцию target ISA - host ISA. Референсной реализацией считается &lt;a href=&quot;http://en.wikipedia.org/wiki/FX%2132&quot;&gt;FX!32&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Если ближе к пребуту, то скоуп такой: на входе имеем win32 PE/PE+ dll однопоточный модуль, который слинкован с родным MS CRT и тянет ряд платформенных ABI зависимостей, как правило в форме импортов kernel32 / ntdll. ISA таргета и хоста совпадают. Помимо загрузки, релокации и разрешения импортов PE laundry list полноценной реализации окружения и ABI примерно такой:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Куча процесса (kernel32!HeapXXX). Как показала практика тут полезна отдельная куча чтобы не лезть в приватные структуры данных хостовой кучи и иметь возможность отделить аллокации таргета от хоста и трассировать их для отладки.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Контейнер виртуальной файловой системы процесса для подгрузки модулей по имени, загрузки UI ресурсов, etc.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TLS, FLS, переменные окружения, настройки кодовой страницы для конвертации строк, - все в контексте таргета.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Манагмент дополнительных загружаемых библиотек таргета(kernel32!LoadLibrary).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Динамическое связывание с импортами вызова VM монитора, если процесс знает о его существовании. В нашем случае знает и должен знать во избежании импортов GDI для рисования UI.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Реализация второстепенных системных вызовов типа записи на консоль, остановки процесса и т.п.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;При переходе от однопоточного к многопоточному таргету появляется CreateThread и примитивы синхронизации, и все это возможно реализовать, правда гораздо дороже чем все описанное выше.&lt;/p&gt;

&lt;p&gt;Однако до CreateThread существует другой &amp;quot;Nice to have&amp;quot; - поддержка таргетов, состоящий из нескольких модулей. Например поддержка таргета, который линкуется с Qt динамически, а не статически. Проблема с такими таргетами в том, что в отличии от импортов, являющихся часть эмулируемого ABI, VMM ничего не знает о qt.dll и должен опираться на какую-то абстракцию файловой системы для их загрузки и связывания.&lt;/p&gt;

&lt;p&gt;Общий поинт в том, что рассматривая пребут на определенном уровне как win32 process VM можно получить четкую модель реализации, которая сама по себе является портируемой на другие реализации пребута (в частности Win32 эмуляцию).&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>ООП</title>
   <link href="warfish.github.io//2013/11/13/d0bed0bed0bf/"/>
   <updated>2013-11-13T22:21:47+07:00</updated>
   <id>warfish.github.io/2013/11/13/d0bed0bed0bf</id>
   <content type="html">&lt;p&gt;Объектно ориентированное программирование - это методология разработки программного обеспечения и структурирования кода, которая ставит целью найти наиболее хитрожопый выход из ситуации, когда более простой, эффективный и понятный подход невозможен из-за религиозных убеждений, острой паранойи и авторитетного мнения.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Exokernels</title>
   <link href="warfish.github.io//2013/10/27/exokernels/"/>
   <updated>2013-10-27T12:41:31+07:00</updated>
   <id>warfish.github.io/2013/10/27/exokernels</id>
   <content type="html">&lt;p&gt;Оригинальная концепция: &lt;a href=&quot;http://u.cs.biu.ac.il/%7Ewiseman/2os/microkernels/exokernel.pdf&quot;&gt;http://u.cs.biu.ac.il/~wiseman/2os/microkernels/exokernel.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Если коротко, то exo-ядра это крайне минималистичный подход. Концепция перпендикулярна микро или монолитным ядрам. Экзоядро реализует гораздо меньше абстракций чем обычно и дает очень много прямого доступа к &amp;quot;близким к аппаратным&amp;quot; ресурсам (таблицы страниц, дисковые сектора, кеши, etc.). Например экзоядра не реализуют абстракцию файловой системы. Юзерленд реализует ее сам, если нужно (обычно с помощью т.н. libOS). Если не нужно, то работает прямо с диском. Ядро все еще контролирует доступ и мультиплексит эти ресурсы, просто речь о гораздо более низкоуровневом доступе и контроле за этим доступом.&lt;/p&gt;

&lt;p&gt;В пейпере есть раздел 5.4.2 The Cheetah HTTP/1.0 Server, который описывает реализацию агрессивно оптимизированного веб сервера на экзоядре.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Драйвера eToken на Windows</title>
   <link href="warfish.github.io//2013/10/19/d0b4d180d0b0d0b9d0b2d0b5d180d0b0-etoken-d0bdd0b0-windows/"/>
   <updated>2013-10-19T18:49:35+07:00</updated>
   <id>warfish.github.io/2013/10/19/d0b4d180d0b0d0b9d0b2d0b5d180d0b0-etoken-d0bdd0b0-windows</id>
   <content type="html">&lt;p&gt;Я немного посмотрел устройство всего стека eToken на винде и вот что получилось:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Центральный модуль в их архитектуре это &lt;strong&gt;Windows\system32\eToken.dll&lt;/strong&gt;. Этот модуль экспортирует наружу реализацию pkcs#11. Неясно насколько много в нем реализации pkcs#11, но кода много.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Сам eToken.dll требует ряд импортов, в основном стандартные kernel32.dll, user32.dll, etc. Еще ему нужен winscard.dll, импорты которого регулярно просвечиваются по дереву вызовов pkcs#11 реализации.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;В комплекте идут 2 драйвера:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;* aksup.sys - класс USB. В inf файле замечены VendorID/DeviceID алладиновских устройств


* aksifdh.sys - класс SmartCardReader. Подозреваю что это плагин winscard API для интерфейса ридера. Зависит от первого драйвера.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Итого складывается такая картина. Ядреное присутствие eToken ограничивается USB устройством и плагином для winscard, а то что я подозреваю реализацией pkcs#11 - eToken.dll - опирается на winscard.dll.&lt;/p&gt;

&lt;p&gt;Отсюда идеи. Предположим, что мы хотим использовать eToken.dll как есть в пребуте. Тогда нам нужны импорты для него. Есть шелуха типа kernel32.dll, user32.dll, которую, думаю, можно разрулить (что-то уже разрулено). И есть winscard.dll. Такой ли это громадный монстр? Оказывается нет : &lt;a href=&quot;http://www.smartcard-magic.net/en/pc-sc-reader/winscard-api-c-c/&quot;&gt;http://www.smartcard-magic.net/en/pc-sc-reader/winscard-api-c-c/&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa380142(v=vs.85).aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/windows/desktop/aa380142(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Тут нужно небольшое пояснение. Токен это формфактор смарткарты, объединяющий ридер и карту. Есть интерфейс ридера, а есть интерфейс карты. Интерфейс ридера это winscard при поддержке драйверов etoken, которые, как мы уже знаем, общаются с Siemens CardOS внутри девайса. При этом протокол общения открыт и реализован в OpenCT. Поэтому в принципе winscard API можно реализовать используя драйвера из OpenCT / PCSC-lite / etc. Т.е. получается, &lt;em&gt;что нам не нужны закрытые бинарные драйвера ридера eToken.&lt;/em&gt; У нас есть свои.&lt;/p&gt;

&lt;p&gt;Реализация winscard API есть, например, у эппла: &lt;a href=&quot;http://www.opensource.apple.com/source/SmartCardServices/SmartCardServices-34733/src/PCSC/winscard.c&quot;&gt;http://www.opensource.apple.com/source/SmartCardServices/SmartCardServices-34733/src/PCSC/winscard.c&lt;/a&gt;. Я думаю ее можно найти в реактосе. И скорее всего в RTOS-32: &lt;a href=&quot;http://www.on-time.com/rtos-32.htm&quot;&gt;http://www.on-time.com/rtos-32.htm&lt;/a&gt;. Последнее правда за деньги, но я хочу немного на RTOS-32 остановится в этом контексте. Мы знаем, что у McAfee, который поддерживает токены, используется именно он в пребуте на биосе. Мы также знаем что у них недавно появилась поддержка EFI, где тоже есть токены. В таком разрезе кажется очень вероятным что они для поддержки токенов на EFI портировали какие-то куски из RTOS-32 и если там есть реализация winscard API, то я почти уверен что они портировали именно его.  Это можно выяснить наверняка, но главное то, что если я прав, то реализацию winscard можно &lt;em&gt;купить&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ок, с ридером разобрались. Интерфейс карты проприетарный с закрытыми форматами, где его взять? В eToken.dll, для которой мы уже разобрались с ридером через winscard :)&lt;/p&gt;

&lt;p&gt;Такой подход сулит ряд бенефитов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Если все производители идут примерно таким же путем, то подход хорошо скалируется.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Конкретно по eToken - нам не нужны их драйвера, потому что мы сами реализуем winscard поверх тех драйверов ридеров, что есть в OpenCT / PCSC-lite.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Мне не понятна трудоемкость и надежность такого решения. Мне не понятна легальная сторона - можем ли мы использовать чужие бинарные модули вот так? Но мне крайне интересно попробовать, потому что потенциально это сулит более менее легкую поддержку большого числа устройств.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[DOOM-UEFI] Alpha</title>
   <link href="warfish.github.io//2013/10/12/doom-uefi-alpha/"/>
   <updated>2013-10-12T21:40:07+07:00</updated>
   <id>warfish.github.io/2013/10/12/doom-uefi-alpha</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://wrfsh.files.wordpress.com/2013/10/screen-shot-2013-10-12-at-9-28-07-pm.png&quot;&gt;&lt;img src=&quot;http://wrfsh.files.wordpress.com/2013/10/screen-shot-2013-10-12-at-9-28-07-pm.png?w=300&quot; alt=&quot;Screen Shot 2013-10-12 at 9.28.07 PM&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Проблемы:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Оказывается драйвер cirrus logic на OVMF дает только 8 бит реального цвета. Качество картинки в оригинале сильно лучше.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Мышки пока нет, но играть можно и без нее.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Обновление экрана тормозит, но есть идеи. Одна из них в том, что qemu софтверный эмулятор и я ничего не могу с этим поделать. Надо сравнить с досбоксом на такой же хостовой конфигурации. В противном случае придется оптимизировать.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>[DOOM-UEFI] Simple linear scaling to active resolution</title>
   <link href="warfish.github.io//2013/10/10/doom-uefi-simple-linear-scaling-to-active-resolution/"/>
   <updated>2013-10-10T23:36:58+07:00</updated>
   <id>warfish.github.io/2013/10/10/doom-uefi-simple-linear-scaling-to-active-resolution</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://wrfsh.files.wordpress.com/2013/10/screen-shot-2013-10-10-at-11-31-59-pm.png&quot;&gt;&lt;img src=&quot;http://wrfsh.files.wordpress.com/2013/10/screen-shot-2013-10-10-at-11-31-59-pm.png?w=300&quot; alt=&quot;Screen Shot 2013-10-10 at 11.31.59 PM&quot;&gt;&lt;a href=&quot;http://wrfsh.files.wordpress.com/2013/10/screen-shot-2013-10-10-at-11-32-48-pm.png&quot;&gt;&lt;img src=&quot;http://wrfsh.files.wordpress.com/2013/10/screen-shot-2013-10-10-at-11-32-48-pm.png?w=300&quot; alt=&quot;Screen Shot 2013-10-10 at 11.32.48 PM&quot;&gt;&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now, input processing.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[DOOM-UEFI] Title screen</title>
   <link href="warfish.github.io//2013/10/09/doom-uefi-title-screen/"/>
   <updated>2013-10-09T00:52:07+07:00</updated>
   <id>warfish.github.io/2013/10/09/doom-uefi-title-screen</id>
   <content type="html">&lt;p&gt;Yeah!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wrfsh.files.wordpress.com/2013/10/screen-shot-2013-10-09-at-12-48-46-am.png&quot;&gt;&lt;img src=&quot;http://wrfsh.files.wordpress.com/2013/10/screen-shot-2013-10-09-at-12-48-46-am.png?w=300&quot; alt=&quot;Screen Shot 2013-10-09 at 12.48.46 AM&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Original game res is 320x200. EFI is running in 800x600. On to scaling and input processing.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[DOOM-UEFI] D_MainLoop</title>
   <link href="warfish.github.io//2013/10/07/doom-uefi-d_mainloop/"/>
   <updated>2013-10-07T23:19:43+07:00</updated>
   <id>warfish.github.io/2013/10/07/doom-uefi-d_mainloop</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://wrfsh.files.wordpress.com/2013/10/screen-shot-2013-10-07-at-11-15-04-pm.png&quot;&gt;&lt;img src=&quot;http://wrfsh.files.wordpress.com/2013/10/screen-shot-2013-10-07-at-11-15-04-pm.png?w=300&quot; alt=&quot;Screen Shot 2013-10-07 at 11.15.04 PM&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Все ресурсы загружены, все подсистемы проинициализированы. D_MainLoop начинает сбор пользовательского ввода и рендеринг кадров. Можно начинать реализовывать рисование и ввод :)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[UEFI-DOOM] How not to write portable code</title>
   <link href="warfish.github.io//2013/10/07/uefi-doom-how-not-to-write-portable-code/"/>
   <updated>2013-10-07T22:43:55+07:00</updated>
   <id>warfish.github.io/2013/10/07/uefi-doom-how-not-to-write-portable-code</id>
   <content type="html">&lt;p&gt;Структура текстурного патча из сурсов дума. Подразумевается что эти структуры хранятся в ресурсном образе as is, код подгружает их читая sizeof(maptexture_t) из файла:&lt;/p&gt;

&lt;blockquote&gt;struct maptexture_t
{
char name[8];
boolean masked;
short width;
short height;
void** obsolete;
patch_t patches[1];
};&lt;/blockquote&gt;

&lt;p&gt;Естественно собираясь для 64-х битного уефая размер этой структуры едет сразу по нескольким полям.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[UEFI-DOOM] Check the plug</title>
   <link href="warfish.github.io//2013/10/06/uefi-doom-check-the-plug/"/>
   <updated>2013-10-06T22:08:26+07:00</updated>
   <id>warfish.github.io/2013/10/06/uefi-doom-check-the-plug</id>
   <content type="html">&lt;p&gt;Пол дня бился над багом, порт зависал при загрузке текстур. Написал тестовые тулзы, оттрассировал проблему до зонового аллокатора дума. Начал подозревать реализацию malloc из EDK, а потом увидел, что перед падением у аллокатора просят -80 байт (минус восемьдесят).&lt;/p&gt;

&lt;p&gt;Оказалось мне попался закорапченный образ текстур игры =\&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[DOOM-UEFI] WAD files and EDK stdlib problems</title>
   <link href="warfish.github.io//2013/10/06/doom-uefi-wad-files-and-edk-stdlib-problems/"/>
   <updated>2013-10-06T11:24:05+07:00</updated>
   <id>warfish.github.io/2013/10/06/doom-uefi-wad-files-and-edk-stdlib-problems</id>
   <content type="html">&lt;p&gt;Дум хранит все свои ресурсы в одном файле с расширением wad. Структура очень простая:&lt;/p&gt;

&lt;p&gt;Заголовок файла описывается структурой wadinfo_t:&lt;/p&gt;

&lt;blockquote&gt;struct wadinfo_t
{
char id[4]; // &quot;IWAD&quot; or &quot;PWAD&quot;
int numlumps;
int tableoffset;
};&lt;/blockquote&gt;

&lt;p&gt;Файла начинается с &amp;quot;IWAD&amp;quot; или &amp;quot;PWAD&amp;quot; идентификатора, tableoffset показывает на позицию в файле где хранится массив структур filelump_t размером numlumps элементов:&lt;/p&gt;

&lt;blockquote&gt;struct filelump_t
{
char name[8];
int size;
int filepos;
};&lt;/blockquote&gt;

&lt;p&gt;filelump_t показывает на область файла filepos, где хранится бинарный блоб с именем name и размером size байт. В doom.wad около 2 тысяч таких лампов. Каждый ламп хранится бинарным блобом с какой-то своей структурой, про которую wad файл ничего не знает.&lt;/p&gt;

&lt;p&gt;Стартуя, дум пытается найти несколько wad файлов по известным именам и определяет тип игры по имени найденного wad файла: doom.wad для doom1, doomu.wad для unltimate doom, doom2.wad для doom2, etc. Чтобы понять существует файл или нет код использует посиксовую функцию access(2), которая возвращает 0 если файл существует и доступен на открытие с запрошенными правами либо ошибку.&lt;/p&gt;

&lt;p&gt;Тут начинаются проблемы с EDK stdlib. Их реализация access возвращает 0 даже если файла нет, т.е. для нее все файлы существуют. Она опирается на функцию open, которая тоже всегда возвращает ненулевой дескриптор даже если файла нет, потому что в реализации баг, который как бы по умолчанию подразумевает флаг O_CREATE, т.е. создать файл если его нет.&lt;/p&gt;

&lt;p&gt;Чинить open я не хочу, иначе мой бранч на гитхабе не будет работать у людей со свежим EDK. Переписывать open тяжело, но возможно придется. Пока я просто поставил поиск doom.wad первым в списке, потому что он как раз и должен быть найден.&lt;/p&gt;

&lt;p&gt;P.S.: Структуры взяты из самого кода дума. Используются типы не фиксированного размера, что создало проблемы на X64, что правда легко исправить.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[DOOM-UEFI] Development environment</title>
   <link href="warfish.github.io//2013/10/03/doom-uefi-development-environment/"/>
   <updated>2013-10-03T23:54:09+07:00</updated>
   <id>warfish.github.io/2013/10/03/doom-uefi-development-environment</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://wrfsh.files.wordpress.com/2013/10/screen-shot-2013-10-03-at-11-47-33-pm.png&quot;&gt;&lt;img src=&quot;http://wrfsh.files.wordpress.com/2013/10/screen-shot-2013-10-03-at-11-47-33-pm.png?w=300&quot; alt=&quot;Screen Shot 2013-10-03 at 11.47.33 PM&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Qemu запущен с кастомной прошивкой из EDK - OVMF. У этого эмулятора есть убойная фича (вообще их много) - способность задавать в качестве диска папку на хостовой файловой системе.&lt;/p&gt;

&lt;p&gt;Qemu грузится с OVMF, запускается уефайный шелл, fs0 показывает на папку на хосте, где лежит doom.efi. Красота.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[DOOM-UEFI] EDK vs gnuefi</title>
   <link href="warfish.github.io//2013/10/02/doom-uefi-edk-vs-gnuefi/"/>
   <updated>2013-10-02T11:15:51+07:00</updated>
   <id>warfish.github.io/2013/10/02/doom-uefi-edk-vs-gnuefi</id>
   <content type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Все платформенно-специфические зависимости были любезно вынесены id в файлы с перфиксами i_. Все файлы вынесены в &lt;a href=&quot;https://github.com/warfish/DOOM/tree/master/linuxdoom-1.10/efi&quot;&gt;https://github.com/warfish/DOOM/tree/master/linuxdoom-1.10/efi&lt;/a&gt;. Реализации пока нет - одни стабы.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Проект собирается и линкуется для EDK.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Я работаю на маке, пришлось собирать кросс-компилятор для EDK. Пока он собирался у меня был лишний час подумать о том, насколько мне вообще нужен EDK с его громоздкой билд системой, кодогенерацией и необходимыми вывертами чтобы собираться вне EDK дерева.&lt;/p&gt;

&lt;p&gt;Вспомнил про проект &lt;a href=&quot;http://sourceforge.net/projects/gnu-efi/&quot;&gt;gnuefi&lt;/a&gt;, на который я последний раз смотрел года 2 назад. Проект, по сравнению с EDK, крайне простой, плоский: гора хедеров с протоколами из спецификации, гора сишников с реализацией всякого полезного добра поверх спецификации и горстка ассемблерного кода с точками входа для разных архитектур. Все это собирается под нужную архитектуру и получаются теже хедера, одна статическая либа с расширениями и пара объектников, с которыми нужно слинковаться клиентскому бинарнику чтобы EFI смог запустить бинарь. Нет libc, ну и ладно. Лицензия lgpl3, что совместимо с открытыми сурсами дума.&lt;/p&gt;

&lt;p&gt;Такой подход по сравнению с EDK как глоток свежего воздуха: просто, тупо и понятно. Жаль что работает только на линуксе. На маке удалось собрать попинав, на винде наверное только через цигвин.&lt;/p&gt;

&lt;p&gt;Пока я все равно останусь на EDK, потому что я хотябы знаю что с ним делать. Но в будущем хочется уйти от него.&lt;/p&gt;

&lt;p&gt;Полезные ссылки:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://smackerelofopinion.blogspot.ru/2011/05/gnu-efi-lib-and-hello-world.html&quot;&gt;http://smackerelofopinion.blogspot.ru/2011/05/gnu-efi-lib-and-hello-world.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://sourceforge.net/projects/gnu-efi/&quot;&gt;http://sourceforge.net/projects/gnu-efi/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.rodsbooks.com/efi-programming/prepare.html&quot;&gt;http://www.rodsbooks.com/efi-programming/prepare.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;P.S. В этом блоге больше не должно быть рекламы.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[DOOM-UEFI] Day 1</title>
   <link href="warfish.github.io//2013/09/30/doom-uefi-day-1/"/>
   <updated>2013-09-30T21:51:56+07:00</updated>
   <id>warfish.github.io/2013/09/30/doom-uefi-day-1</id>
   <content type="html">&lt;p&gt;Я решил портировать &lt;a href=&quot;http://en.wikipedia.org/wiki/Doom_(video_game)&quot;&gt;doom&lt;/a&gt; в пребут на уефай, just for fun.&lt;/p&gt;

&lt;p&gt;Отличная статья для ознакомления с архитектурой рендера: &lt;a href=&quot;http://fabiensanglard.net/doomIphone/doomClassicRenderer.php&quot;&gt;http://fabiensanglard.net/doomIphone/doomClassicRenderer.php&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Репозиторий оригинального бранча на гитхабе: &lt;a href=&quot;https://github.com/id-Software/DOOM&quot;&gt;https://github.com/id-Software/DOOM&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;После беглого просмотра исходников:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Рендер портировать скорее всего будет просто. Он софтверный с блитом в окно.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Звук не в скоупе, нет драйверов.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Мультиплеер тоже не в скоупе.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Для инпута нужно решить проблему с получением скан кодов из EFI&lt;em&gt;SIMPLE&lt;/em&gt;TEXT_INPUT.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Нужна файловая система для подгрузки pk файлов.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Мой форк тут: &lt;a href=&quot;https://github.com/warfish/DOOM&quot;&gt;https://github.com/warfish/DOOM&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PBE и PBA</title>
   <link href="warfish.github.io//2013/09/18/pbe-d0b8-pba/"/>
   <updated>2013-09-18T22:01:46+07:00</updated>
   <id>warfish.github.io/2013/09/18/pbe-d0b8-pba</id>
   <content type="html">&lt;p&gt;На текущий момент кажется, что разделение PBE и PBA пошло обоим на пользу, хотя и было местами болезненным. Между ними складываются отношения как между операционной системой и приложением. PBA (или его заменитель) даже собирается в PE exe, линкуясь с неким подобием рантайма для PBE. PBE конечно осью назвать нельзя, тем не менее у него есть ряд зачаточных признаков как-то:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Загрузка на голом железе&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Определение, прости господи, интерфейса чем-то напоминающего системные вызовы.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Модель драйверов и устройств.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Защита памяти.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Загрузка пользовательского приложения в качестве полезной нагрузки.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Конечно почти ничего из этого не сделано с нуля.&lt;/p&gt;

&lt;p&gt;PBE это пошло на пользу в плане его генерализации, т.е. обобщения до некой очень специфически ориентированной платформы, абстрагирующейся от бизнес логики рядом интерфейсов, протоколов и контрактов. Это позволяет с одной стороны иметь несколько реализаций PBE, включая, например, эмуляцию; делает возможным удобное тестирование с другой стороны и расширяет области применимости с третьей.&lt;/p&gt;

&lt;p&gt;Для PBA польза также в обобщении - его определение расширяется и во-многом упрощается. Для PBA существует набор условий, в которых он работает, как-то защищенный режим, libc, подмножество плюсового рантайма, вызовы PBE. Каким образом это было достигнуто его не заботит. Ответ на вопрос что можно а что нельзя реализовать становится прямолинейным - можно то, для чего хватает описанных условий.&lt;/p&gt;

&lt;p&gt;Эта условия вырисовываются именно такими, потому что до определенного уровня клиент диктует платформе, что должно быть поддержано - платформа без клиента не имеет смысла. С другой стороны всегда стоят реалии того, сколько будет стоить реализация таких требований и запросы балансируются с возможностями. И это правильно, хотя технически всегда хочется сделать больше и богаче, чем нужно.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[UEFI] Quick UI toolkit overview</title>
   <link href="warfish.github.io//2013/07/20/uefi-quick-ui-toolkit-overview/"/>
   <updated>2013-07-20T15:31:19+07:00</updated>
   <id>warfish.github.io/2013/07/20/uefi-quick-ui-toolkit-overview</id>
   <content type="html">&lt;p&gt;EFI (нативно и эмулируемо) дает интерфейс &lt;a href=&quot;http://wiki.phoenix.com/wiki/index.php/EFI_GRAPHICS_OUTPUT_PROTOCOL&quot;&gt;GOP&lt;/a&gt;, который поддерживает BitBlt и предлагает реализовывать GUI поверх него.  Предполагается, что BitBlt это все что нужно для этого. Я поискал в интернетах открытые и проприетарные GUI тулкиты для EFI, для embedded и для linux framebuffer, потому что последний достаточно близко эмулируется поверх GOP. Вот что удалось откапать.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C/PEG, PEG+, PEG Pro&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.swellsoftware.com/products/cpeg.php&quot;&gt;http://www.swellsoftware.com/products/cpeg.php&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Проприетарное решение от SwellSoftware, ссылка ведет на C/PEG, рядом лежат PEG+ и PEG Pro, которые стоят дороже, но дают больше функционала. В пдфке стоит поддержка x86 VBE и linux framebuffer. К сожалению evaluation kit они хотят слать физической почтой и требуют указать американский штат, поэтому посмотреть в жизни не удается. Тем не менее решение выглядит интересно, хотя цена на лицензирование только по прямому запросу в отдел продаж.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FLTK&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.fltk.org/index.php&quot;&gt;http://www.fltk.org/index.php&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Fast Light Tool Kit. Достаточно взрослый и стабильный проект, быстрый, легковесный, умеет рендерить шрифты и содержит достаточно неплохой набор виджетов. Лицензия GPL v2 с небольшими дополнениями, а именно &lt;a href=&quot;http://www.fltk.org/COPYING.php&quot;&gt;http://www.fltk.org/COPYING.php&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;Static linking of applications and widgets to the FLTK library does not constitute a derivative work and does not require the author to provide source code for the application or widget, use the shared FLTK libraries, or link their applications or widgets against a user-supplied version of FLTK.

If you link the application or widget to a modified version of FLTK, then the changes to FLTK must be provided under the terms of the LGPL in sections 1, 2, and 4.&lt;/blockquote&gt;

&lt;p&gt;Т.е. позволяет линковаться статически и не требует раскрытия кода клиентского приложения.&lt;/p&gt;

&lt;p&gt;Проблема с FLTK в том, что он опирается на Carbon/GDI/X11, что существенно усложняет портирование.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Microwindows&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.microwindows.org/&quot;&gt;http://www.microwindows.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Еще один распространенный в embedded среде тулкит. Пристально пока не смотрел, но радует вот это утверждение с главной страницы:&lt;/p&gt;

&lt;blockquote&gt;All drivers are endian-neutral with only Read/DrawPixel, DrawV/Hline and Blit entry points.&lt;/blockquote&gt;

&lt;p&gt;Т.е. реализация опирается на архитектуру графического драйвера, которому нужны DrawPixel, Draw[V/H]Line и Blit. Опять же, пристально не вглядывался, но такой вариант достаточно портируемый. Лицензирован под &lt;a href=&quot;http://www.mozilla.org/MPL/&quot;&gt;MPL&lt;/a&gt;. Архитектуру можно почитать &lt;a href=&quot;http://www.microwindows.org/microwindows_architecture.html&quot;&gt;здесь&lt;/a&gt;, советую обратить внимание на раздел Screen Driver&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Embedded Qt&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://qt-project.org/doc/qt-4.8/qt-embedded-linux.html&quot;&gt;http://qt-project.org/doc/qt-4.8/qt-embedded-linux.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Встраиваемая версия Qt работающая поверх linux framebuffer. Очень интересный вариант. Что такое Qt думаю пояснять не стоит, а вот про то, что такое фреймбуфер можно почитать &lt;a href=&quot;http://tldp.org/HOWTO/Framebuffer-HOWTO/&quot;&gt;здесь&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Итого&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Есть еще несколько слишком абстрактных вариантов, типа Tcl\Tk порт, но наиболее интересными мне кажутся варианты с Microwindows и Embedded Qt.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Управление Временем</title>
   <link href="warfish.github.io//2013/07/13/d183d0bfd180d0b0d0b2d0bbd0b5d0bdd0b8d0b5-d0b2d180d0b5d0bcd0b5d0bdd0b5d0bc/"/>
   <updated>2013-07-13T18:24:28+07:00</updated>
   <id>warfish.github.io/2013/07/13/d183d0bfd180d0b0d0b2d0bbd0b5d0bdd0b8d0b5-d0b2d180d0b5d0bcd0b5d0bdd0b5d0bc</id>
   <content type="html">&lt;p&gt;Посетил тренинг в Москве в HQ 10-11 числа сего месяца. Общее впечатление - нормально. Самый большой недостаток, на мой взгляд, это то, что тренинг был ориентирован на людей, у которых есть проблема управлением громадного количества небольших и разных задач. Звонки, бесконечный поток почты, постоянные прерывания и т.п. На тренинге было 3 группы людей: ПМы, тестеры и два девелопера :) У ПМов проблема в постоянных звонках и почте, у тестеров в бесконечном потоке задач с одинаково-высоким приоритетом. Девелоперы там просто были :).&lt;/p&gt;

&lt;p&gt;На тренинге было много практики, нас постоянно делили на группы и давали практические занятия по теории. Одно из таких занятий получилось очень смешным и грустным. Задача для команды, в которую я попал была следующей. Вы - исполнители. Вам нужно написать 5 вопросов, которые вы себе зададите для определения приоритета поставленной перед вами задачи. Вторая команда, к слову, была &amp;quot;менеджерами&amp;quot; и должна была написать такие же 5 вопросов, но такие, какие &lt;em&gt;менеджмент ожидает что исполнители себе зададут сами&lt;/em&gt;. Хитро. Моя команда состояла из 3 ПМов и 4 исполнителей (я и трое тестеров). Мы с тестерами естественно решили, что сейчас мы и напишем те вопросы, что мы реально себе задаем в такой ситуации. Несмотря на это трое ПМов решили нас просто игнорировать. Они собрались в свой кружок и экранировали любой белый шум, который поступал от четверых сбоку. Мы поначалу сопротивлялись, но потом забили. В итоге те вопросы, что ПМы придумали были раскритикованы, а нам наконец дали возможность сказать &amp;quot;правильный&amp;quot; ответ :) Тонны злорадства.&lt;/p&gt;

&lt;p&gt;Не поймите неправильно, тренинг был хорошим, просто его ориентированность не была заточена под мою специфику - небольшое количество крупных задач. Моя главная задача на этот тренинг была улучшить эффективность и скорость выполнения этих крупных задач не жертвуя качеством. Я научился ряду полезных приемов организации дня, которые, в общем, можно адаптировать под мою специфику. Однозначно полезными были инструменты хронометража, которые я применял, но, как оказалось, недостаточно глубоко. &lt;a href=&quot;http://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0_%D1%81%D0%B2%D1%8F%D0%B7%D0%B5%D0%B9&quot;&gt;Mind maps&lt;/a&gt; всем очень понравились, но я их применял уже давно в основном для раздебаживания чего-нибудь совсем непонятного. Очень понравилось жестко-гибкое (sic) планирование. Думаю это первое, что я реально начну внедрять в свой рабочий день.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Вердикт по OpenSC</title>
   <link href="warfish.github.io//2013/07/05/d0b2d0b5d180d0b4d0b8d0bad182-d0bfd0be-opensc/"/>
   <updated>2013-07-05T22:23:45+07:00</updated>
   <id>warfish.github.io/2013/07/05/d0b2d0b5d180d0b4d0b8d0bad182-d0bfd0be-opensc</id>
   <content type="html">&lt;p&gt;Если коротко, то криптографический токен можно поддержать &amp;quot;из коробки&amp;quot; портированной связкой opensc/openct при выполнении следующих условий:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Аутентификационные данные и прочие объекты, расположенные на токене, поддерживают стандарт PKCS#15&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OpenSC/OpenCT предоставляет драйвер ридера этого токена, который знает APDU протокол этого устройства.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;А как же PKCS#11? Дело в том, что реализация PKCS#11 в OpenSC опирается на PKCS#15 с одной стороны и драйвер ридера токена с другой. Так что если для конкретного устройства выполняются два условия выше, то PKCS#11 должен &amp;quot;просто работать&amp;quot;.&lt;/p&gt;

&lt;p&gt;Что же было не так с eToken? Возникла теория, которую я решил проверить напрямую и она подтвердилась. Дело в том, что eToken не поддерживает PKCS#15. Функция &lt;a href=&quot;https://github.com/OpenSC/OpenSC/blob/master/src/pkcs11/pkcs11-session.c#L233&quot;&gt;C_Login&lt;/a&gt; в реализации PKCS#11 в OpenSC &lt;a href=&quot;https://github.com/OpenSC/OpenSC/blob/master/src/pkcs11/pkcs11-session.c#L284&quot;&gt;опирается &lt;/a&gt;как раз на PKCS#15, конкретнее на функцию &lt;a href=&quot;https://github.com/OpenSC/OpenSC/blob/master/src/pkcs11/framework-pkcs15.c#L1332&quot;&gt;pkcs15_login&lt;/a&gt;. Которая не работает, потому что аутентификационные данные на eToken не поддерживают этот формат.&lt;/p&gt;

&lt;p&gt;Если вернутся к условиям в начале поста, то я уверен, что OpenSC удачное решение. Оно не дает 100% покрытия, но на мой взгляд eToken скорее исключение нежели чем правило. Исключение которое нам по силам победить даже в худшем случае. ;)&lt;/p&gt;

&lt;p&gt;Стратегии победы включают в себя портирование их бинарных сборок на UEFI и/или реверсинг с технической стороны и переговоры с вендором с политической.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[UEFI Emulation] EDK/Duet is a moderate success</title>
   <link href="warfish.github.io//2013/07/02/uefi-emulation-edkduet-is-a-moderate-success/"/>
   <updated>2013-07-02T23:11:23+07:00</updated>
   <id>warfish.github.io/2013/07/02/uefi-emulation-edkduet-is-a-moderate-success</id>
   <content type="html">&lt;p&gt;Прототипирование UEFI эмуляции на базе EDK/Duet можно считать законченным. Я считаю результат умеренным успехом. Успехом потому что такой подход действительно позволяет поставить знак равенства между Legacy BIOS и UEFI системами на том уровне поддержки аппаратуры, что нам нужен. А умеренным потому что, несмотря на знак равенства, возможности самого UEFI, будь то native или эмуляция, оставляют за нами массу прикладной работы по поддержке локализации, ввода национальных символов и двух факторной авторизации. Глупо было ожидать обратного. :)&lt;/p&gt;

&lt;p&gt;Если сконцентрироваться на хорошем, то UEFI, по сравнению с &amp;quot;голым&amp;quot; PBA дает:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Защиту памяти и полную адресацию. Коррапты памяти раньше происходили тихо и незаметно. Теперь такие баги генерируют GPF.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Поддержку современных тулчейнов, включая тот, что используется для остального проекта. Использование MSVC 1.52 можно свести к минимуму, а значит и его баги тоже (а они есть).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Графический фреймбуфер и рендер растровых юникодных шрифтов.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Работающий USB и PCI стек.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Достаточный контроль состояния аппаратуры.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Модульность, взаимозаменяемость драйверов через повсеместную абстракцию протоколами. Это очень важно для эмуляции, потому что дает возможность заменить реализацию например графического дисплея на свою, работающую через BIOS.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Поддержка source-level отладки.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Стеки сетевых протоколов.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;libc&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Из &amp;quot;умеренного&amp;quot;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Поддержка ввода национальных символов совсем базовая. Раскладки нужно генерировать самостоятельно. Если для европейских языков все терпимо, то для азиатских и арабских выглядит довольно сложно, хотя и не невозможно.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Драйвера крипто токенов. Их либо нет, либо они в непонятно каком состоянии в опенсорсных либах, либо нужно начинать говорить с вендорами токенов.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Нет полноценного GUI фреймворка &amp;quot;из коробки&amp;quot;. Есть все необходимые базовые технологические стеки для его реализации/портирования, типа фреймбуфера, драйверов устройств ввода и т.д, но нет самих примитивов, из которых строится GUI.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если ссумировать, то UEFI предоставляет всю базу, чтобы реализовать прикладные задачи, но не больше этого. Реализовать все остальное можно используя нормальный компилятор, отладчик, защиту памяти, снятие множества ограничений по ресурсам и т.д. EDK/Duet выравнивает BIOS до этого же уровня, что экономит наверное год работы и дает унифицирование платформы на поддерживаемых аппаратных конфигурациях. Но при этом все, что выходит за рамки базовой платформы, нужно делать/портировать почти самостоятельно, и, хочу еще раз подчеркнуть, это касается UEFI в целом, а не только его эмуляции. Приятное исключение это рендер шрифтов :)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>libusb porting tips</title>
   <link href="warfish.github.io//2013/06/30/libusb-porting-tips/"/>
   <updated>2013-06-30T01:10:57+07:00</updated>
   <id>warfish.github.io/2013/06/30/libusb-porting-tips</id>
   <content type="html">&lt;p&gt;From &lt;a href=&quot;http://www.libusb.org/wiki/libusb-1.0&quot;&gt;http://www.libusb.org/wiki/libusb-1.0&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;[libusb](http://www.libusb.org/)-1.0 includes a platform abstraction layer allowing for cross-platform compatibility. Linux, Darwin (Mac OS X), Windows, OpenBSD and NetBSD are supported in the latest release.

FreeBSD 8 and above include a FreeBSD-specific reimplementation of the libusb-1.0 API, so your applications will probably work there too. The source code for this library can be found [​here](http://svn.freebsd.org/viewvc/base/head/lib/libusb/).

If you are interested in porting to other platforms, the [PORTING](http://git.libusb.org/?p=libusb.git;a=blob;f=PORTING;h=7070784d04761562e38208d9d2fa4c2460eefc30;hb=ab9cd5a7be637f7b793987971a706b1d11c27ded;js=1) file tells you where to start. We are more than happy to help out here, please write to the mailing list with your questions and feedback.&lt;/blockquote&gt;

&lt;p&gt;From &lt;a href=&quot;http://git.libusb.org/?p=libusb.git;a=blob;f=PORTING;h=7070784d04761562e38208d9d2fa4c2460eefc30;hb=ab9cd5a7be637f7b793987971a706b1d11c27ded;js=1&quot;&gt;PORTING&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;

&gt; 
&gt; Implementation-wise, the basic idea is that you provide an interface to
&gt; 
&gt; 

&gt; 
&gt; libusb&#39;s internal &quot;backend&quot; API, which performs the appropriate operations on
&gt; 
&gt; 

&gt; 
&gt; your target platform.
&gt; 
&gt; 

&gt; 
&gt; 

&gt; 
&gt; In terms of USB I/O, your backend provides functionality to submit
&gt; 
&gt; 

&gt; 
&gt; asynchronous transfers (synchronous transfers are implemented in the higher
&gt; 
&gt; 

&gt; 
&gt; layers, based on the async interface). Your backend must also provide
&gt; 
&gt; 

&gt; 
&gt; functionality to cancel those transfers.
&gt; 
&gt; 

&gt; 
&gt; 

&gt; 
&gt; Your backend must also provide an event handling function to &quot;reap&quot; ongoing
&gt; 
&gt; 

&gt; 
&gt; transfers and process their results.
&gt; 
&gt; 

&gt; 
&gt; 

&gt; 
&gt; The backend must also provide standard functions for other USB operations,
&gt; 
&gt; 

&gt; 
&gt; e.g. setting configuration, obtaining descriptors, etc.
&gt; 
&gt; 

&gt; 
&gt; &lt;/blockquote&gt;

&lt;p&gt;Existing libusb ports are found in &lt;a href=&quot;http://git.libusb.org/?p=libusb.git;a=tree;f=libusb/os;h=1ec9613c0fc4facf6e9217af4130f02387e2b470;hb=7634714aa696175b08016b6f2185a75a2f55a113;js=1&quot;&gt;libusb/os folder&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;libusbi.h contains a very well documented interface that should be implemented on a new platform: &lt;a href=&quot;http://git.libusb.org/?p=libusb.git;a=blob;f=libusb/libusbi.h;h=3b602d28ca4cae7577bcdcabddccaeb04c0a79cb;hb=7634714aa696175b08016b6f2185a75a2f55a113;js=1#l468&quot;&gt;usbi&lt;em&gt;os&lt;/em&gt;backend&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>OpenSC / UEFI</title>
   <link href="warfish.github.io//2013/06/28/opensc-uefi/"/>
   <updated>2013-06-28T22:33:05+07:00</updated>
   <id>warfish.github.io/2013/06/28/opensc-uefi</id>
   <content type="html">&lt;p&gt;Чтобы портировать связку libopensc/libopenct нужно:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Затащить StdLib. В EDK есть реализация: &lt;a href=&quot;http://sourceforge.net/p/tianocore/edk2/ci/master/tree/StdLib/&quot;&gt;http://sourceforge.net/p/tianocore/edk2/ci/master/tree/StdLib/&lt;/a&gt;. Есть небольшое неудобство - ванильная реализация StdLib в EDK линкуется только с UEFI&lt;em&gt;APPLICATION (а не DXE&lt;/em&gt;DRIVER). Поэтому PBA &lt;em&gt;везде&lt;/em&gt; должен быть аппликейшеном. Либо можно распилить StdLib на части и копилировать сишники. Тоже вариант.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Написать реализацию функций ifd&lt;em&gt;sysdep&lt;/em&gt;usb_* в OpenCT. Вот пример порта на &lt;a href=&quot;http://www.libusb.org/&quot;&gt;libusb&lt;/a&gt;/Linux: &lt;a href=&quot;https://github.com/OpenSC/openct/blob/master/src/ifd/sys-linux.c&quot;&gt;https://github.com/OpenSC/openct/blob/master/src/ifd/sys-linux.c&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Вытравить зависимости от файловой системы в вспомогательном коде OpenCT. Например у него есть конфиг, который он при инициализации парсит из файла и т.д.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Выкинуть все &amp;quot;ненужное&amp;quot;. Например общение с токенами по серийному порту.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Вместо пункта 2 (порт ifd&lt;em&gt;sysdep&lt;/em&gt;usb_*) можно подойти к вопросу фундаментальнее - портировать libusb. Эта либа своего рода стандартный API доступа к USB устройствам на линуксе. На нее портировано много всего, включая OpenCT. Если портануть ее, то это дает гибкость, можно не портировать USB стек второй раз в какой-нибудь другой либе. Но это медленнее, потому что libusb больше.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>OpenSC</title>
   <link href="warfish.github.io//2013/06/27/opensc/"/>
   <updated>2013-06-27T21:09:26+07:00</updated>
   <id>warfish.github.io/2013/06/27/opensc</id>
   <content type="html">&lt;p&gt;Смотрю на &lt;a href=&quot;https://github.com/OpenSC/OpenSC&quot;&gt;OpenSC &lt;/a&gt; - библиотеку драйверов смарт карт и токенов. Наблюдаю интересные вещи. Сама либа не содержит вообще почти никаких платформенных зависимостей, не читает USB. Вместо этого похоже что она абстрагирует конкретный бекенд ридера карт и токенов через &lt;a href=&quot;https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/opensc.h#L284&quot;&gt;sc_reader&lt;/a&gt; и реализует адаптеры на три backend-а:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/CT-API&quot;&gt;CT-API&lt;/a&gt; - &lt;a href=&quot;https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/reader-ctapi.c&quot;&gt;https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/reader-ctapi.c&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/PC/SC&quot;&gt;PC/SC&lt;/a&gt; -  &lt;a href=&quot;https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/reader-pcsc.c&quot;&gt;https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/reader-pcsc.c&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/OpenSC/openct&quot;&gt;OpenCT&lt;/a&gt; - &lt;a href=&quot;https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/reader-openct.c&quot;&gt;https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/reader-openct.c&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Больше инфы по каждому варианту можно найти в вики проекта: &lt;a href=&quot;https://github.com/OpenSC/OpenSC/wiki/Creating-applications-with-smart-card-support#low-level-smart-card-access&quot;&gt;https://github.com/OpenSC/OpenSC/wiki/Creating-applications-with-smart-card-support#low-level-smart-card-access&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Все трое это внешние для OpenSC реализации, которые она адаптирует через сишный вариант полиморфизма в &lt;a href=&quot;https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/opensc.h#L419&quot;&gt;sc&lt;em&gt;reader&lt;/em&gt;operations&lt;/a&gt;. Я кстати очень люблю такой Pure C полиморфизм, но щас не об этом. Подход должен быть знаком сразу всем, кто писал драйвера для линуксового ядра.&lt;/p&gt;

&lt;p&gt;Так или иначе, по моему не самому глубокому 30-ти минутному вниканию я делаю вывод, что портировать на UEFI нужно будет реализацию одного из трех вариантов выше, а не самой OpenSC. У конкурентов на линуксе я почти всегда видел пару libopensc/libopenct, так что вот.&lt;/p&gt;

&lt;p&gt;Драйвер для eToken PRO находится здесь:&lt;a href=&quot;https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/card-cardos.c&quot;&gt;https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/card-cardos.c&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Generic USB слой:&lt;a href=&quot;https://github.com/OpenSC/openct/blob/master/src/ifd/usb.c&quot;&gt;https://github.com/OpenSC/openct/blob/master/src/ifd/usb.c&lt;/a&gt;
Опирается на платформенно-зависимые ifd&lt;em&gt;sysdep&lt;/em&gt;usb_*. Реализация для линукса:&lt;a href=&quot;https://github.com/OpenSC/openct/blob/master/src/ifd/sys-linux.c&quot;&gt;https://github.com/OpenSC/openct/blob/master/src/ifd/sys-linux.c&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[UEFI Emulation] Localized input and output</title>
   <link href="warfish.github.io//2013/06/25/uefi-emulation-localized-input-and-output/"/>
   <updated>2013-06-25T22:35:11+07:00</updated>
   <id>warfish.github.io/2013/06/25/uefi-emulation-localized-input-and-output</id>
   <content type="html">&lt;p&gt;Следующая цель прототипирования: локализованный ввод и вывод. Мы хотим, чтобы пользователь мог ввести свой логин и пароль на своем родном языке и чтобы мы могли локализовать ему пребут. Это означает, что нам нужна поддержка:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Юникодных строк и их рендеринга на графический дисплей.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Клавиатурных раскладок с маппингом на юникодные символы.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Что на данный момент удалось получить от EDK/Duet.&lt;/p&gt;

&lt;p&gt;Сначала о выводе юникода на экран. Вообще весь UEFI и EDK юникодные (UTF16). Для вывода юникодных строк на дисплей UEFI предоставляет описание шрифта: &lt;a href=&quot;http://wiki.phoenix.com/wiki/index.php/EFI_HII_SIMPLE_FONT_PACKAGE_HDR&quot;&gt;http://wiki.phoenix.com/wiki/index.php/EFI&lt;em&gt;HII&lt;/em&gt;SIMPLE&lt;em&gt;FONT&lt;/em&gt;PACKAGE_HDR&lt;/a&gt;. Это по сути таблица маппинга UTF16 кода символа на глиф размером либо 9x19 либо 16x19 пикселей. EDK предоставляет драйвер графической консоли, который учитывает наборы этих шрифтов и рендерит каждый символ в UTF16 строке согласно ее глифу, учитывая переносы строк, слияние границ символов и т.д. И это достаточно много очень противного кода.&lt;/p&gt;

&lt;p&gt;Модель для разработчика получается такая: чтобы поддержать печать текста например на русском языке надо изготовить таблицу глифов для каждого UTF16 символа этого языка, загрузить ее в рантайме и автомагически вся печать на дисплей будет работать. Есть также более продвинутое описание шрифтов, не привязанное к размеру глифа: &lt;a href=&quot;http://wiki.phoenix.com/wiki/index.php/EFI_HII_FONT_PACKAGE_HDR&quot;&gt;http://wiki.phoenix.com/wiki/index.php/EFI&lt;em&gt;HII&lt;/em&gt;FONT&lt;em&gt;PACKAGE&lt;/em&gt;HDR&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Никто не запрещает поступить как grub2 - сделать большой шрифт со всеми нужными языками в одном пакете и грузить его целиком. Никто не запрещает взять векторный шрифт и отрендерить его в нужно размере получив таким образом растр. В общем с этой стороны поддержку можно считать достаточной.&lt;/p&gt;

&lt;p&gt;Теперь о вводе. UEFI предоставляет в том же пакете HII (Human Interface Infrastructure) еще один тип ресурсов - клавиатурные раскладки: &lt;a href=&quot;http://wiki.phoenix.com/wiki/index.php/EFI_HII_KEYBOARD_LAYOUT&quot;&gt;http://wiki.phoenix.com/wiki/index.php/EFI&lt;em&gt;HII&lt;/em&gt;KEYBOARD_LAYOUT&lt;/a&gt;. Раскладка это таблица маппинга скан кода на UTF16 код символа + флаги: &lt;a href=&quot;http://wiki.phoenix.com/wiki/index.php/EFI_KEY_DESCRIPTOR&quot;&gt;http://wiki.phoenix.com/wiki/index.php/EFI&lt;em&gt;KEY&lt;/em&gt;DESCRIPTOR&lt;/a&gt;. Здесь маппинг уже не такой прямой как в случае со шрифтами. В поле атрибутов можно указать ряд флагов, а клавиатурный драйвер будет их учитывать и изменять свое внутреннее состояние в зависимости от нажатой клавиши. Например через флаги EFI&lt;em&gt;NS&lt;/em&gt;KEY&lt;em&gt;MODIFIER и EFI&lt;/em&gt;NS&lt;em&gt;KEY&lt;/em&gt;DEPENDENCY_MODIFIER реализуется поддержка &amp;quot;мертвых клавиш&amp;quot;.&lt;/p&gt;

&lt;p&gt;Модель для разработчика выглядит примерно так же как и в случае со шрифтами: чтобы поддержать ввод символов например на русском языке нужно изготовить таблицу дескрипторов и загрузить ее в рантайме. Но как оказалось тут кроется подстава. В EDK две реализации клавиатурного драйвера: &lt;a href=&quot;http://sourceforge.net/p/tianocore/edk2/ci/master/tree/MdeModulePkg/Bus/Usb/UsbKbDxe&quot;&gt;UsbKbDxe&lt;/a&gt; и &lt;a href=&quot;http://sourceforge.net/p/tianocore/edk2/ci/master/tree/IntelFrameworkModulePkg/Bus/Isa/Ps2KeyboardDxe&quot;&gt;Ps2KeyboardDxe&lt;/a&gt;. Первый - драйвер USB клавиатуры, а второй - PS2, работающий через &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_MCS-48&quot;&gt;Intel 8042&lt;/a&gt; контроллер. Как оказалось раскладки поддерживает только драйвер USB клавиатуры. Соответвенно для PS2 клавиатур нужно портировать код обработки раскладок.&lt;/p&gt;

&lt;p&gt;Ситуацию усложняет еще и так называемый Lеgacy USB. Это стандартная фича USB контроллеров и биосов когда USB клавиатура эмулируется как PS/2 устройство через Intel 8042. Т.е. в большинстве случаев даже если в машину воткнута клавиатура через настоящий USB порт, то биос видит ее как PS/2 клавиатуру. Это можно исправить в ту или другую сторону, но проще не становится.&lt;/p&gt;

&lt;p&gt;Итого. При условии что у нас есть драйвер PS/2 клавиатуры, который умеет работать с раскладками, то получается такой псевдокод добавление поддержки национальных символов:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;для каждого поддерживаемого языка:
    сгенерировать растровый шрифт национальных символов
    нарисовать раскладку клавиатуры с учетом диакритиков, мертвых клавиш и т.д.
    протестировать с реальной клавиатурой
конец
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Для меня это не выглядит страшным, особенно если учесть, что можно избавится от первого шага сгенерировав &amp;quot;большой&amp;quot; юникодный шрифт один раз. Основная доля работы в раскладках и это будет точно не бесплатно, не из коробки, как в случае с линуксом например.&lt;/p&gt;

&lt;p&gt;Мне удалось за один рабочий день корявенько локализовать ввод и вывод на русский язык. Я сгенерировал кривой шрифт и нарисовал раскладку, пока не уперся в то, что VmWare эмулирует клавиатуру как PS/2 устройство, драйвер которого в EDK не понимает раскладки. Но если вынести проблему с драйвером за скобки, то получается примерно такие трудозатраты для относительно простого (и главное знакомого) языка.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[UEFI Emulation] Windows boots (faster)</title>
   <link href="warfish.github.io//2013/06/21/uefi-emulation-windows-boots-faster/"/>
   <updated>2013-06-21T22:49:11+07:00</updated>
   <id>warfish.github.io/2013/06/21/uefi-emulation-windows-boots-faster</id>
   <content type="html">&lt;p&gt;Пребут на базе EDK/Duet загружается и с обычной скоростью загружает NT на 5 (из 5) тестовых реальных машинах. Какие проблемы были решены за эту неделю:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Пожалуй основная проблема в том, что биосы стали очень умные. Многие стартуют сразу с включенным A20. Некоторые используют пейджинг, работая внутри ISR в защищенном режиме. Из-за этого восстанавливать нужно такие вещи как GDTR, CR0-4, состояние A20.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Проблема с замедлением загрузки NT была связана с тем, что биос, находясь в реальном режиме, считает тики таймера, прошедшие с момента загрузки. После ухода в EDK биос больше не видит прерываний таймера и тики начинают теряться. Если по возврату из EDK правильно посчитать сколько тиков прошло с момента загрузки и прописать это значение для биоса, то все грузится с обычной скоростью. Конкретный код, который завязан на значения тиков выяснить не удалось (нет дебаггера). Была придумана теория и проверена вслепую.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;В DuetPkg есть баг, из-за которого происходит коррапт памяти ниже первого мегабайта: &lt;a href=&quot;http://sourceforge.net/p/tianocore/edk2/ci/master/tree/DuetPkg/DxeIpl/HobGeneration.h#l26&quot;&gt;http://sourceforge.net/p/tianocore/edk2/ci/master/tree/DuetPkg/DxeIpl/HobGeneration.h#l26&lt;/a&gt;. Код по ссылке готовит для DxeCore (ядро EDK) т.н. HOB - HandOff Block. В этом блоке загрузчик прописывает таблицы страниц физической памяти, свободные на момент передачи управления из стадии DxeIpl в стадию DxeCore. К сожалению, авторы DxeIpl в дуэте решили захардкодить верхнюю границу диапазона доступной памяти ниже 1MB значением в 0x9F800, что соответствует 640 KB. Практически все современные биосы оставляют меньше свободной памяти, в районе 600KB. В результате при маппировании страниц ниже 1MB перетирается код биоса.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Проблемы выше были исправлены и теперь все снова хорошо. Танцевать еще рано, но пританцовывать можно начинать.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[UEFI Emulation] Windows boots (slowly)</title>
   <link href="warfish.github.io//2013/06/18/uefi-emulation-windows-boots-slowly/"/>
   <updated>2013-06-18T23:31:47+07:00</updated>
   <id>warfish.github.io/2013/06/18/uefi-emulation-windows-boots-slowly</id>
   <content type="html">&lt;p&gt;Хорошие новости - винда начала загружаться на реальном железе из эмулируемого UEFI :)&lt;/p&gt;

&lt;p&gt;Плохие новости - она загружается минут 5 против секунд 15 если без меня. Потенциальные причины проблемы исследуются.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Mind map - researcher's best friend</title>
   <link href="warfish.github.io//2013/06/17/mind-map-researchers-best-friend/"/>
   <updated>2013-06-17T15:43:20+07:00</updated>
   <id>warfish.github.io/2013/06/17/mind-map-researchers-best-friend</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://wrfsh.files.wordpress.com/2013/06/duet-console-output.png&quot;&gt;&lt;img src=&quot;http://wrfsh.files.wordpress.com/2013/06/duet-console-output.png?w=300&quot; alt=&quot;Duet console output&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[UEFI Emulation] BiosThunk and protected mode versus real mode interrupts</title>
   <link href="warfish.github.io//2013/06/16/uefi-emulation-biosthunk-and-protected-mode-versus-real-mode-interrupts/"/>
   <updated>2013-06-16T20:31:38+07:00</updated>
   <id>warfish.github.io/2013/06/16/uefi-emulation-biosthunk-and-protected-mode-versus-real-mode-interrupts</id>
   <content type="html">&lt;p&gt;DuetPkg для реализации доступа к жесткому диску предоставляет драйвера IDE/SATA/AHCI. Я не хочу опираться на них, потому что мне нужно в итоге вернутся в реальный режим для загрузки хостовой ОС, а драйвера портят картину мира для биоса. Выход - опираться на INT 13h. Но тут встает проблема с прерываниями.&lt;/p&gt;

&lt;p&gt;Как работает доставка прерываний в Legacy режиме:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Железо генерирует прерывание используя линию IRQ&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Intel 8259A программируемый контроллер прерываний содержит маппинг IRQ -&amp;gt; Software interrupt line. Прерывание от железа маппируется на софтверное прерывание процессора. Типичный маппинг это IRQ 0h - 7h -&amp;gt; INT 8h - Fh и IRQ 8h - Fh -&amp;gt; INT 70h - 77h.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Типично для режима совместимости первый жесткий диск использует IRQ 14, которая маппируется на INT 76h. В результате когда жесткий диск хочет сообщить например о завершении запроса на чтение, то он ассертит IRQ 14, что приводит к софтверному прерыванию 76h. Процессор выполняет софтверный обработчик, навешанный на это прерывание.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Как процессор определяет где находится обработчик прерывания 76h? Здесь все зависит от режима процессора:&lt;/p&gt;

&lt;p&gt;В реальном режиме 8086 по линейному адресу 0x0 содержится таблица указателей на обработчики прерываний. Каждый элемент длинной 4 байта и содержит segment:offset указатель на 16-ти битный код обработчика. BIOS инициализирует эту таблицу указателями на обработчики при старте машины. Процессор просто достает 4 байта по смещению 0x76 * 0x4, интерпретирует это как segment:offset указатель и выполняет icall туда.&lt;/p&gt;

&lt;p&gt;В защищенном режиме все устроено сложнее. Вместо таблицы указателей с известным оффсетом процессор требует от системного программного обеспечения проинициализировать регистр IDTR, в котором должен быть адрес на описание дескрипторов IDT. IDT похож на GDT в том плане, что в нем содержится 4 байтовый линейный адрес на начало таблицы обработчиков прерываний и ее размер. Сама таблица содержит структуры дескрипторов обработчиков прерываний. Их структуру я объяснять не буду, подробнее можно почитать здесь: &lt;a href=&quot;http://wiki.osdev.org/IDT&quot;&gt;http://wiki.osdev.org/IDT&lt;/a&gt;. Суть в том, что в защищенном режиме процессор использует (установленное софтом) значение регистра IDTR для поиска указателя на процедуру - обработчик прерывания.&lt;/p&gt;

&lt;p&gt;В чем проблема?&lt;/p&gt;

&lt;p&gt;Наше окружение на базе UEFI работает в защищенном режиме, а это значит что оно должно предоставлять IDT. Для чтения диска мы хотим опираться на BIOS, но BIOS работает в реальном режиме, в котором процессор ничего не знает про IDTR и хочет простую таблицу указателей на 16-ти битный код. Когда мы вовращаемся из защищенного режима в реальный, то все будет работать нормально, потому что обработчики BIOSа окажутся на месте. Что делать когда мы работаем в защищенном режиме? Прерывания доставляются асинхронно и BIOS не будет о них знать, если мы не будем их форвардить. Вопрос, нужно ли из форвардить или нет? DuetPkg этого не делает, но это ни о чем не говорит.&lt;/p&gt;

&lt;p&gt;С DuetPkg в этом плане еще хуже. Он использует механизм BiosThunk для реализации EFI&lt;em&gt;GRAPHICS&lt;/em&gt;OUTPUT_PROTOCOL через ISR 10h биоса: &lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/BiosVideoThunkDxe&quot;&gt;BiosVideoThunkDxe&lt;/a&gt;. Что именно там происходит я описывать не буду - главное то, что код вектора 10h исполняется с выключенными прерываниями. Драйвер возвращается в реальный режим, но при этом весь код, выполняющийся там, выполняется с выключенными прерываниями. Вместо инструкции int драйвер напрямую вызывает код обработчика по указателю. Это значит, что использовать такой механизм для вызова INT 13h нельзя, потому что INT 13h ожидает от диска ответного прерывания по окончанию запроса, с таймаутом. До получения такого ответа он не возвращается, а по истечению таймаута возвращается с ошибкой. Даже если в защищенном режиме реализован форвардинг прерываний в BIOS, то он сработает слишком поздно - когда int 13h уже вернулся, потому что прерывания от диска не было. Clover, как оказалось, своим драйвером диска поверх INT 13h не пользуется.&lt;/p&gt;

&lt;p&gt;Почему Duet так делает? Потому что во-первых у него есть драйвера дисков, во-вторых он не хочет пропустить прерывания когда делает thunk в 16-ти битный код и в третьих потому что 10h прерывания не нужны для работы. Проблема есть, но пока она роли не играет. Если мы уходим в реальный режим &amp;quot;насовсем&amp;quot;, т.е. чтобы загрузить хостовую ОС, то нам не нужен thunk. Проблема будет, когда мы захотим прочитать с диска во время работы. Решить это можно грубо, включив таки прерывания во время thunk-а и перенаправив их в обработчики биоса. Тогда Duet может потерять несколько прерываний. В крайнем случае придется мутить что-то страшное наподобие редиректора прерываний в оба режима.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[UEFI Emulation] DxeCore</title>
   <link href="warfish.github.io//2013/06/15/uefi-emulation-dxecore/"/>
   <updated>2013-06-15T21:51:39+07:00</updated>
   <id>warfish.github.io/2013/06/15/uefi-emulation-dxecore</id>
   <content type="html">&lt;p&gt;DxeCore - Ядро UEFI рантайма, стартует сразу после PI (Platform Initialization) стадии. В терминах DuetPkg, где Pi стадия заключается в инициализации пейджинга и idt, сразу после DuetPkg/DxeIpl.&lt;/p&gt;

&lt;p&gt;В DxeCore сосредоточено очень много интересного, в том числе аллокаторы страниц и пулов, учет хендлов, публикация протоколов и т.д. Его роль - реализация базового функционала, необходимого в рантайме UEFI. Все остальное по сути врапперы и клиенты этой основы.&lt;/p&gt;

&lt;p&gt;Код можно посмотреть здесь: &lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/MdeModulePkg/Core/Dxe&quot;&gt;Dxe&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Удивляет отстутсвие тестов, но может я чего-то не вижу / не знаю.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[UEFI Emulation] What exactly is DuetPkg</title>
   <link href="warfish.github.io//2013/06/15/uefi-emulation-what-exactly-is-duetpkg/"/>
   <updated>2013-06-15T19:04:50+07:00</updated>
   <id>warfish.github.io/2013/06/15/uefi-emulation-what-exactly-is-duetpkg</id>
   <content type="html">&lt;p&gt;Речь пойдет о том, что именно такое DuetPkg в EDK2, какую роль он выполняет.&lt;/p&gt;

&lt;p&gt;DuetPkg, в рамках EDK пакета (&lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/&quot;&gt;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/&lt;/a&gt;) служит базовой реализацией платформы UEFI поверх Legacy BIOS. На этапе загрузки в его задачи входит загрузка образа, инициализация защищенного режима, страничной памяти и таблицы прерываний, - все под требования остальных компонентов EDK, чтобы они &amp;quot;просто работали&amp;quot;. В рантайме он занимается эмуляцией NVRAM и предоставляет сервис для возврата в реальный режим и вызовы прерываний BIOS.  Если разобрать его покомпонентно, то получается такая картина:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/BootSector&quot;&gt;BootSector&lt;/a&gt; - набор ассемблерных программ реального и защищенного режима. Из них комбинируется цепочка загрузки на разных платформах. Mbr, FAT boot sector и старт EfiLoader-а, - все там.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/EfiLdr&quot;&gt;EfiLdr&lt;/a&gt; - загрузчик PE образов. Ему передается управление сразу после перехода в плоский защищенный режим. В его задачи входит расжатие остальных компонентов образа, парсинг и релокация PE и передача управления в DxeIpl&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/DxeIpl&quot;&gt;DxeIpl&lt;/a&gt; - Занимается базовой инициализацией платформы. Инициализирует paging, таблицу прерываний защищенного режима и отдает управление в DxeCore, который уже является стандартным компонентом из MdePkg, т.е. &amp;quot;прикладным&amp;quot; кодом EDK.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/PciBusNoEnumerationDxe&quot;&gt;PciBusNoEnumerationDxe&lt;/a&gt;/&lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/PciRootBridgeNoEnumerationDxe&quot;&gt;PciRootBridgeNoEnumerationDxe&lt;/a&gt; - драйвера PCI шины. Предоставляют доступ к PCI configuration space, реализуют PCI IO, позволяют обходить шину и искать там конкретные устройства. NoEnumeration означает что эти компоненты не занимаются аллокацией PCI ресурсов. Т.е. если какое-то устройство на шине не было проинициализировано биосом, то выделением и арбитрацией ресурсов для него будет заниматься конкретный драйвер этого устройства, а не эти компоненты.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/BiosVideoThunkDxe&quot;&gt;BiosVideoThunkDxe&lt;/a&gt; - механизм вызова INT 10h биоса и реализация EFI&lt;em&gt;GRAPHICS&lt;/em&gt;OUTPUT_PROTOCOL поверх него.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/FSVariable&quot;&gt;FSVariable&lt;/a&gt; - драйвер эмуляции NVRAM через файл на загрузочной флешке.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Остальные компоненты выполняют вспомогательную функцию и особого интереса не представляют. Для реализации всего остального UEFI окружения, например страничного аллокатора, загрузчика драйверов, базу данных хендлов и фреймворка пользовательского интерфейса (HII) используются компоненты не входящие напрямую в DuetPkg, а находящиеся в основном в MdePkg, MdeModulePkg, PcAtChipsetPkg, IntelFrameworkPkg.&lt;/p&gt;

&lt;p&gt;Получается, что все богатство эмуляции, которое видно после загрузки с флешки со сборкой DuetPkg реализовано именно прикладным кодом EDK, а не дуэтом. Если разобрать как выглядит сборка дуэта в рантайме и как она загружается (например с флешки), то получается примерно так:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;BIOS загружает MBR флешки (DuetPkg/BootSecotor/Mbr.asm)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MBR ищет FAT12/16/32 раздел, читает boot sector (DuetPkg/BootSector/bs32.asm) и отдает ему управление&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BS парсит FAT и ищет файл EfiLdr20, лежащий в корне раздела. Затем он загружает первый сектор этого файла и отдает ему управление.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Структура EfiLdr20:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Start32.com (BootSector/Start32.asm). Разделен на две части. В первом секторе находится код реального режима, который поднимает с диска весь остальной EfiLdr20 и переходит по оффсету 0x200 в нем.&lt;/li&gt;
&lt;li&gt;Start32.com2 (тот же BootSector/Start32.asm). Вторая половина переводит машину в защищенный режим и передает управление Efi32.com2, по оффсету 0x1000 внутри файла&lt;/li&gt;
&lt;li&gt;Efi32.com2 (BootSecotor/Efi32.asm). Составляет e820 карту памяти, парсит заголовок EfiLoader и передает ему управление с параметром - адресом карты памяти.&lt;/li&gt;
&lt;li&gt;EfiLoader. Был описан ранее. Разжимает, релоцирует и запускает DxeIpl/PE&lt;/li&gt;
&lt;li&gt;DxeIpl. Был описан ранее. Инициализирует платформу и запускает DxeCore/PE.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;На этом вклад DuetPkg в этап загрузки системы заканчивается. DxeCore, который работает следом, уже часть MdePkg. Он парсит базу данных драйверов FV (которая идет следом за ним в EfiLdr20) и загружает каждый из этих драйверов. Драйвера, загружаясь, инициализируются, создают хендлы и публикуют на них протоколы, - обычный такой UEFI рантайм. В конце концов загружается BootManager, ищет загрузочное устройство и запускает с него шелл. Или не запускает, если не нашел. Суть описанного в том, что DuetPkg существует в качестве jump start-ера ядра EDK и всех его драйверов. В рантайме он предоставляет дополнительные драйвера, но немного.&lt;/p&gt;

&lt;p&gt;Возникает вопрос, а можно ли тогда сделать &amp;quot;свой&amp;quot; DuetPkg и, главное, зачем?&lt;/p&gt;

&lt;p&gt;Можно, причем это не слишком тяжело. Вещи типа страничного аллокатора и базы данных хендлов и HII и всего остального идут &amp;quot;бесплатно&amp;quot; из других компонентов EDK. Все что требуется от своей реализации это инициализировать пейджинг, таблицу прерываний, несколько драйверов и обеспечить загрузку всего этого добра согласно протоколам UEFI.&lt;/p&gt;

&lt;p&gt;Зачем это может понадобится? Затем, что задача DuetPkg это окружение для тестирования UEFI приложений и драйверов на Legacy BIOS машинах. Он не подразумевает например последующую загрузку UEFI-capable или любой другой ОС. В результате он все-таки не слишком заботится о сохранении состояния аппаратуры для биоса. Задачи бывают разные, с разными требованиями, для реализации которых нужно переделывать процесс загрузки образа, иначе обходится с аппаратурой, больше опираться на биос, не лезть в ACPI, выкинуть эмуляцию NVRAM и т.д. Возможно проще сделать свой Duet (попутно вытянув из оригинала все что можно) нежели чем перепиливать существующий пополам.&lt;/p&gt;

&lt;p&gt;К слову загрузку я уже переделал. Вместо флешки образ кладется на диск, стартует мой MBR, поднимает с сырого диска ld.com, который поднимает весь образ EfiLdr20 и отдает управление сразу в пункт 4.2, т.е. второй части Start32.com&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>UEFI emulation 1</title>
   <link href="warfish.github.io//2013/06/14/uefi-emulation-1/"/>
   <updated>2013-06-14T01:22:06+07:00</updated>
   <id>warfish.github.io/2013/06/14/uefi-emulation-1</id>
   <content type="html">&lt;p&gt;Первый день прототипирования с duet показал, что с ним тоже есть свои проблемы. У него внезапно есть баги, точнее я подозреваю у него баг с картой памяти на машинах с 1gb физической памяти. Исправления не должны быть слишком сложными, но все-таки как-то неприятно :) Ещё он тоже занимается серьёзной инициализацией платформы. Судя по всему он не форвардит прерывания из защищенного в реальный режим, а реализует нужные вектора полноценно. Как именно пока не понятно. Создаст ли это проблемы при переходе на загрузку оригинальной оси я пока не знаю, но выглядит страшновато. Тем не менее я считаю его все ещё лучшим вариантом. Все точно будет не просто, но вариантов и возможностей достаточно.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CMOS as a persistent secret storage</title>
   <link href="warfish.github.io//2013/06/12/cmos-as-a-persistent-secret-storage/"/>
   <updated>2013-06-12T21:54:30+07:00</updated>
   <id>warfish.github.io/2013/06/12/cmos-as-a-persistent-secret-storage</id>
   <content type="html">&lt;p&gt;Чтобы PBA работало с перезагрузкой, нужно сохранить где-то секрет. Секрет можно разбить на две части - данные и ключ шифрования. В таком случае данные можно положить на диск, а вот куда деть ключ, так чтобы он пережил перезагрузку и его было легко стереть.&lt;/p&gt;

&lt;p&gt;На UEFI есть &lt;a href=&quot;http://en.wikipedia.org/wiki/Non-volatile_random-access_memory&quot;&gt;NVRAM&lt;/a&gt;, а вот на BIOS есть &lt;a href=&quot;http://en.wikipedia.org/wiki/CMOS&quot;&gt;CMOS&lt;/a&gt;. Он гораздо меньше, 512 байт, но мне нужно всего 16. Можно поэкспериментировать с хранением секрета в этой памяти в случае, если без перезагрузки жить не получится. Основная проблема с таким подходом пожалуй в том, что формат данных, хранимых в CMOS, плохо стандартизирован. Не понятно где свободное место, а где нужные биосу данные.&lt;/p&gt;

&lt;p&gt;Код чтения и записи CMOS в Linux: &lt;a href=&quot;http://lxr.linux.no/linux+v3.9.5/drivers/char/nvram.c&quot;&gt;http://lxr.linux.no/linux+v3.9.5/drivers/char/nvram.c&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CMOS memory map: &lt;a href=&quot;http://www.bioscentral.com/misc/cmosmap.htm#&quot;&gt;http://www.bioscentral.com/misc/cmosmap.htm#&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OSDev article: &lt;a href=&quot;http://wiki.osdev.org/CMOS&quot;&gt;http://wiki.osdev.org/CMOS&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Внезапно DuetPkg</title>
   <link href="warfish.github.io//2013/06/11/d0b2d0bdd0b5d0b7d0b0d0bfd0bdd0be-duetpkg/"/>
   <updated>2013-06-11T21:40:04+07:00</updated>
   <id>warfish.github.io/2013/06/11/d0b2d0bdd0b5d0b7d0b0d0bfd0bdd0be-duetpkg</id>
   <content type="html">&lt;p&gt;После одного часа, потраченного на DuetPkg из EDK2 удалось его собрать и прожечь на загрузочную флешку. Загрузившись на реальной машине через BIOS внезапно оказалось, что в получившейся среде есть:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Печать юникода на экран (у среды есть французская локализация).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Полноценный UEFI рантайм, поверх которого успешно грузятся драйвера и запускатся приложения, в том числе и шелл.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PCI/USB стек.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sata, Scsi, Ide драйвера, которые можно подгружать&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Готовые механизмы возврата в реальный режим и вызова BIOS ISR.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Много еще чего-то, чего я не успел заметить&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Не удалось проверить клавиатурные раскладки. В остальном, внезапно, DuetPkg дает все выше перечисленное, т.е. снимает где-то пол года работы по воссозданию среды эмуляции UEFI. Чтобы заработали токены надо портировать libopensc. USB стек уже есть.&lt;/p&gt;

&lt;p&gt;Конечно скорее всего это не бесплатно. При таком богатстве наверное опять встанет проблема состояния железа. Но в этом случае она несравнимо более контролируемая чем  на Linux и, к примеру, написать дисковый драйвер для этой среды, опирающийся на int 13h, не составит особого труда. Более контролируемая она потому что получившаяся среда крайне модульная, очень недалеко стоит от BIOS&amp;#39;а и по своему объему вполне доступна для понимания одним человеком. Выкинуть из сборки например поддержку AHCI будет очень просто. Реализовать замену через int 13h тоже несложно.&lt;/p&gt;

&lt;p&gt;Я только очень надеюсь что вопрос с лицензированием не подведет. В остальном таким образом относительно легко BIOS уравнивается в функционале до UEFI, точнее того его подмножества, который мне нужен. Нужно работать дальше, но пока этот вариант выглядит очень привлекательно.&lt;/p&gt;

&lt;p&gt;Мне кажется, что при таком раскладе на первый план сейчас выходит проработка загрузки хостовой ОС из этой среды через оригинальный MBR. И тут я припас главное. Есть open source проект &lt;a href=&quot;http://sourceforge.net/projects/cloverefiboot/&quot;&gt;Clover&lt;/a&gt;, который представляет из себя UEFI-based boot loader, основанный на DuetPkg, стартующий с BIOS и загружающий ряд операционных систем. Т.е. он решает эту задачу и им можно вдохновлятся. Ну к примеру реализация вышеупомянутого BlockIo драйвера через INT 13h: &lt;a href=&quot;http://sourceforge.net/p/cloverefiboot/code/HEAD/tree/LegacyBios/BlockIoDxe/&quot;&gt;http://sourceforge.net/p/cloverefiboot/code/HEAD/tree/LegacyBios/BlockIoDxe/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Все это внезапно выглядит слишком хорошо.&lt;/p&gt;

&lt;p&gt;UPD: Лицензия - &lt;a href=&quot;http://edk2.svn.sourceforge.net/viewvc/edk2/trunk/edk2/MdeModulePkg/License.txt?revision=14397&amp;amp;view=markup&quot;&gt;http://edk2.svn.sourceforge.net/viewvc/edk2/trunk/edk2/MdeModulePkg/License.txt?revision=14397&amp;amp;view=markup&lt;/a&gt;&lt;br&gt;
Насколько я понимаю она позволяет нам использовать этот код без ограничений кроме как приложить текст дисклеймера?&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>К вопросу о найме: что хочется от кандидата на пребут</title>
   <link href="warfish.github.io//2013/05/28/d0ba-d0b2d0bed0bfd180d0bed181d183-d0be-d0bdd0b0d0b9d0bcd0b5-d187d182d0be-d185d0bed187d0b5d182d181d18f-d0bed182-d0bad0b0d0bdd0b4d0b8d0b4/"/>
   <updated>2013-05-28T13:24:55+07:00</updated>
   <id>warfish.github.io/2013/05/28/d0ba-d0b2d0bed0bfd180d0bed181d183-d0be-d0bdd0b0d0b9d0bcd0b5-d187d182d0be-d185d0bed187d0b5d182d181d18f-d0bed182-d0bad0b0d0bdd0b4d0b8d0b4</id>
   <content type="html">&lt;p&gt;Был задан вопрос - что должен знать и что нужно спрашивать у кандидата на собеседовании, чтобы определить насколько он подходит под наши пребутовые задачи. Ниже я постараюсь дать ответ в форме групп вопросов, которые я бы спросил на собеседовании. В общем и целом мы имеем дело с системным программистом, с некоторой спецификой в плане отвязки от конкретного ядра и системного API. Вопросы я старался подбирать не исходя из собственных знаний (часть я затруднился бы ответить), а исходя из повседневной необходимости.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Общее&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Попросить описать самое интересное, что было на любом месте работы по выбору кандидата, какую интересную проблему он решал. Азарт в рассказе показывает заинтересованность в профессии, а сама проблема многое говорит о предпочтениях кандидата. Идеально было бы, если кандидат расскажет в этом качестве об отладке сложного бага :)&lt;/li&gt;
&lt;li&gt;Спросить чем список отличается от массива :) Уточнить, что речь идет не о библиотечных структурах, а о базовых теоретических понятиях. Большой плюс если кандидат в рамках ответа об алгоритмической сложности перейдет на практические аспекты и расскажет о pointer chasing.&lt;/li&gt;
&lt;li&gt;Что такое переполнения буфера на стеке, как и почему оно работает.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Архитектура x86&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Режимы работы. Protected mode, long mode. Разграничение доступа между kernel/user space и привилегированные инструкции. Отдельный плюс за real mode и unreal mode, но не стоит зацикливаться именно на этом.&lt;/li&gt;
&lt;li&gt;Что такое адрес? Описать путь разыменования простого char* в пользовательском режиме. Как виртуальный адрес превращается в физический? В случае своппинга, как происходит подкачка страниц если виртуальный адрес указывает на засвоппированную страницу? Отдельный плюс за MMU и TLB. Отдельный большой плюс за отличия x86&lt;em&gt;32 от x86&lt;/em&gt;64 и понятие канонического адреса.&lt;/li&gt;
&lt;li&gt;Прерывания. Какие типы бывают и для чего они нужны? Что происходит с процессором при возникновении прерывания? Большой плюс за описание TSS и переключение в привилегированный обработчик прерывания при выполнении кода пользовательского режима. Большой плюс за упоминание контроллера прерываний.&lt;/li&gt;
&lt;li&gt;Пространство I/O портов. Что это такое, для чего они нужны? Большой плюс за ответ на вопрос как адресное пространство портов аллоцируется в системе и аллоцируется ли&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Инструменты.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Компиляция и линковка. Зачем нужен линкер. Что такое бинарный формат исполняемого образа, какие бывают форматы (требовать конкретного знания какого-то конкретного формата не нужно, можно попросить описать на словах общие принципы). Как происходит загрузка исполняемого кода. Что такое слабое связывание (weak linking). Что такое релокация, как она происходит. Большой плюс если кандидат различает релокацию фиксапами и трамплинами.&lt;/li&gt;
&lt;li&gt;Отладка. Здесь интересует не сам опыт отладки или использования какого-то конкретного дебаггера, а скорее знание общих принципов, на которых отладчики построены. Как работают отладчики? Какая аппаратная поддержка существует для поддержки отладчиков? Как можно реализовать отладчик самостоятельно? :)&lt;/li&gt;
&lt;li&gt;Плюсы. Здесь интересует не столько знание языка как такового, сколько понимание как он реализован. Зачем нужен виртуальный деструктор :) Как обычно реализованы виртуальные функции. Если кандидат упирается, что это деталь реализации на конкретной платформе, то спросить как бы он реализовал их сам. Как реализовано простое невиртуальное немножественное наследование, где в памяти будут данные того или иного предка. Как запускаются конструкторы статических объектов. Бонусная задача: как запустить конструктор объекта если нет кучи, стека и CRT.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Практика&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Разворот двухсвязного списка. Написать реализацию функции list&lt;em&gt;node* reverse(list&lt;/em&gt;node* head). Функция принимает голову связного списка, разворачивает его и возвращает новую голову, которая позволяет пройти этот список с хвоста. Задача достаточно небольшая по размеру, в ней есть где ошибиться и она показывает, может ли кандидат писать код :)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В общем и целом я бы предложил отдавать приоритет кандидатам, стремящимся узнать скорее что находится &amp;quot;под капотом&amp;quot; языков и систем, нежели чем отличным теоретическим знаниям или высокоуровневым паттернам языков.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Сколько стоит Advanced Preboot Environment своими руками.</title>
   <link href="warfish.github.io//2013/05/27/d181d0bad0bed0bbd18cd0bad0be-d181d182d0bed0b8d182-advanced-preboot-environment-d181d0b2d0bed0b8d0bcd0b8-d180d183d0bad0b0d0bcd0b8/"/>
   <updated>2013-05-27T22:58:10+07:00</updated>
   <id>warfish.github.io/2013/05/27/d181d0bad0bed0bbd18cd0bad0be-d181d182d0bed0b8d182-advanced-preboot-environment-d181d0b2d0bed0b8d0bcd0b8-d180d183d0bad0b0d0bcd0b8</id>
   <content type="html">&lt;p&gt;Ниже идет грубая оценка на реализацию Advanced Preboot Environment (APBE), написанную своими руками и опирающуюся на BIOS там где это возможно, а именно в драйверах дисплея, серийного порта и дисков.&lt;/p&gt;

&lt;h2&gt;Требования.&lt;/h2&gt;

&lt;p&gt;APBE это платформа для &amp;quot;интересной&amp;quot; бизнес логики, работающей до загрузки ОС. Понятия интересного каждый определяет сам, но я буду иметь в голове продвинутую авторизацию с поддержкой сети и USB токенов.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Плоское адресное пространство и защита памяти&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;APBE должен адресовать 32-битное адресное пространство, и поддерживать защиту памяти в плане разделения страниц кода и данных себя и бизнес логики. В переводе на x86 это означает поддержку:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Защищенного режима (&lt;a href=&quot;http://en.wikipedia.org/wiki/Protected_mode&quot;&gt;protected mode&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Страничного режима виртуальной памяти (paging)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Отдельно о страничном режиме. Речь не идет о поддержки своппинга и расширений виртуальной памяти на физическое хранилище. Пейджинг в данном случае нужен ради одной фичи - разграничения прав на чтение, запись и выполнение данных со страничной гранулярностью. Мы хотим избежать одной из самых тяжело отлаживаемых проблем при работе в реальном режиме - коррапта памяти. Сегментная адресация защищенного режима позволяет указать тип сегмента (код или данные). Однако оперировать целыми сегментами для этого достаточно тяжело. Вместо этого предлагается реализовать простую схему страничной адресации, где виртуальные адреса напрямую отражаются в физические, т.е. виртуальный адрес 0x10000 напрямую отображается в физический адрес 0x10000. Таким образом можно динамически аллоцировать страницы памяти и выставлять для них нужный режим доступа. Любая попытка записи в страницу с кодом приведет к GPF, что нам и нужно вместо молчаливого коррапта.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Firmware piggy-backing&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Мы не хотим писать свои драйвера хостовых дисковых контроллеров, и поэтому хотим оперется на прошивку. В случае BIOS это означает использование ISR реального режима, что влечет за собой некоторые неудобства с прерываниями в защищенном режиме, о которых будет написано ниже в разделе с открытыми задачами.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Максимальная тестируемость в user mode.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Мы хотим чтобы максимальная часть кода как APBE так и бизнес логики могла быть автоматически тестируемой в обычном пользовательском режиме. Это влечет за собой поддержку PE образов и реализацию hosted окружения, когда код работает внутри за-mock-ченной реализации.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Поддержка современным тулчейном.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Мы хотим хороший современный компилятор, ассемблер и линкер, потому что MSVC 1.52 бажный. Это влечет за собой генерацию PE/ELF образов, т.е. необходимость их поддержки при выполнении.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Поддержка дополнительной аппаратуры.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;В плане &amp;quot;бизнес логики по умолчанию&amp;quot; это означает поддержку сетевых устройств и USB шины для поддержки токенов, - того чего BIOS скорее всего не поддерживает. Также это влечет за собой поддержку &lt;a href=&quot;http://en.wikipedia.org/wiki/Conventional_PCI&quot;&gt;PCI&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Roadmap&lt;/h2&gt;

&lt;p&gt;Этап 0: окружение для разработки, запуска и тестирования.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Настройка тулчейна&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Адаптация кода первоначальной загрузки окружения (загрузчики первой и второй ступени)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Serial I/O, display, keyboard input&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Загрузка и релокация PE образа.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PE/COFF &amp;quot;Hello world&amp;quot; в виде полезной нагрузки.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Оценка: 40 ч/ч&lt;/p&gt;

&lt;p&gt;Результат: по окончанию этапа имеем возможность заняться решением задач непосредственно связанных с APBE.&lt;/p&gt;

&lt;p&gt;Этап 1: реализация окружения для выполнения кода&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Защищенный режим&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Страничная адресация&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Аллокатор страниц с выставлением прав + юнит тесты с моком.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Оценка: 60-80 ч/ч&lt;/p&gt;

&lt;p&gt;Результат: по окончанию этапа прикладная логика работает в защищенном режиме с 32-битной адресацией и поддержкой защиты памяти. Есть возможность динамически аллоцировать страничную память.&lt;/p&gt;

&lt;p&gt;Этап 2: прерывания реального и защищенного режима&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Реализация protected mode ISR и TSS&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Механизм гейт коллов ISR реального режима с восстановлением контекста прерываний.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Немного про саму проблему. В 8086 real mode работа с прерываниями очень простая. По адресу 0:0 находится таблица векторов прерываний на 256 элементов. Каждый элемент это стандартный segment:offset указатель на ISR соответствующего прерывания. В защищенном режиме все сложнее. Во-первых вместо простой таблицы указателей нужен &lt;a href=&quot;http://en.wikipedia.org/wiki/Integrated_Device_Technology&quot;&gt;IDT&lt;/a&gt;. Во-вторых при включении защищенного режима нужен ремаппинг прерываний, потому что при включенном пейджинге на прерывания 0 - 0x1f накладываются зарезервированные аппаратные исключения процессора. Мы не хотим заниматься реализацией самих ISR, вместо этого мы хотим опереться на то, что нам дает BIOS. Для этого нужен механизм переключения в реальный режим с восстановлением контекста прерываний BIOS и перенаправление прерываний туда.&lt;/p&gt;

&lt;p&gt;Оценка: 80 ч/ч&lt;/p&gt;

&lt;p&gt;Результат: по окончанию этапа APBE может опираться на BIOS ISR для дискового I/O, печати на дисплей и захвата ввода с клавиатуры, работая при этом в защищенном режиме. Для прерываний, генерируемых не программно (исключения, железо) есть механизм форвардинга между реальным и защищенным режимом.&lt;/p&gt;

&lt;p&gt;Этап 3: обход PCI и идентификация устройств.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Энумерация PCI топологии системы без раздачи дополнительных ресурсов.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Составление структур данных для описания и управления общими PCI устройствами.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;На этом этапе мы делаем крайне мало полезного :) Тем не менее это необходимо как подготовительный этап для добавления поддержки дополнительных устройств.&lt;/p&gt;

&lt;p&gt;Оценка: 40 ч/ч&lt;/p&gt;

&lt;p&gt;Результат: достоверный дамп PCI топологии хоста.&lt;/p&gt;

&lt;p&gt;Этап 4: интеграция &lt;a href=&quot;http://ipxe.org/&quot;&gt;iPXE&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;База данных сетевых устройств и код драйверов iPXE интегрируются в виде библиотеки кода.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Обход PCI шины расширяется идентификацией сетевых устройств из базы iPXE и навешиванием драйверов.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Прикладная логика ip4, udp и tcp из iPXE&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Оценка: 160 ч/ч&lt;/p&gt;

&lt;p&gt;Результат: поддержка сетевых устройств в APBE на сыром уровне. Поддержка библиотечной прикладной логики стеков ip4, tcp и udp.&lt;/p&gt;

&lt;p&gt;Этап 5: USB&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Энумерация &lt;a href=&quot;http://en.wikipedia.org/wiki/Host_controller_interface_%28USB%2C_Firewire%29&quot;&gt;EHCI&lt;/a&gt; контроллеров на PCI, поддержка синхронной энумерации USB эндпоинтов&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Установление сырого канала отправки USB пакетов между хостом и USB эндпоинтом&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Планируется адаптировать код barebones USB из coreboot.&lt;/p&gt;

&lt;p&gt;Оценка: 100 ч/ч&lt;/p&gt;

&lt;p&gt;Результат: синхронная энумерация USB, общение с USB энпоинтом на сыром уровне.&lt;/p&gt;

&lt;p&gt;Этап 6: HAL&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Абстракции сырого доступа к видео памяти фреймбуфером и устройств пользовательского ввода.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Абстракции дисков.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Абстракции USB устройств&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Абстракции сетевых сокетов.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Этот этап заворачивает все поддерживаемые устройства в абстракции для использования прикладным кодом бизнес логики. Речь идет о реализации, чистке и документировании интерфейсов; сами интерфейсы неявно вырабатываются на предыдущих этапах.&lt;/p&gt;

&lt;p&gt;Оценка: 80 ч/ч&lt;/p&gt;

&lt;p&gt;Результат: APBE готова для поддержки клиентского кода бизнес логики.&lt;/p&gt;

&lt;p&gt;Итого: 580-600 часов и куча рисков :)&lt;/p&gt;

&lt;h2&gt;Риски&lt;/h2&gt;

&lt;p&gt;Перечислены в порядке потенциального влияния на время разработки.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Лицензии стороннего кода&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Многое из того что я видел совместимо с выпуском проприетарного кода. Есть то, чего я не видел :)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Ремаппинг прерываний real и protected моде&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Задача описана на этапе 2. Риск заключается в &amp;quot;нестандартных&amp;quot; настройках прерываний реального режима в BIOS. Тем не менее общее решение вполне возможно.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Аллокация PCI ресурсов для дополнительных устройств.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Драйвера сетевых устройств и USB контроллеров должны аллоцировать PCI ресурсы для пронумерированных устройств. Возможно будет необходимо добавить арбитрацию для избегания пересечения этих ресурсов с биосом.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Синхронный опрос USB эндпоинтов.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;На данный момент подразумевается синхронный опрос USB контроллера, что означает отсутствие поддержки для вновь добавленных токенов. Решить это предполагается запуском опроса по таймеру с определенной переодичностью. Риск заключается в скорости опроса, которая сильно может повлиять на время отклика системы для пользователя.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Сигнализирование о наличии данных от сетевого устройства.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Коррелирует с риском о прерываниях и аллоцированием PCI ресурсов. Необходимо обеспечить сетевой интерфейс линией прерывания. Риск заключается в сохранении и восстановлении маппинга прерываний при переходе между реальным и защищенным режимами.&lt;/p&gt;

&lt;p&gt;Заключение&lt;/p&gt;

&lt;p&gt;На этом история конечно не заканчивается, но предполагается, что остальное (включая UI, Unicode и токены) это область прикладного кода. Каждый этап предполагает максимально тестируемую реализацию и покрытие тестами.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHD3 write-up</title>
   <link href="warfish.github.io//2013/05/25/phd3-write-up/"/>
   <updated>2013-05-25T23:39:08+07:00</updated>
   <id>warfish.github.io/2013/05/25/phd3-write-up</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://phdays.ru/&quot;&gt;http://phdays.ru/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Сразу вынужден извинится за отсутствие фотографий - было не до этого&lt;/p&gt;

&lt;h3&gt;День 1.&lt;/h3&gt;

&lt;h4&gt;Цикл разработки ПО с уклоном в безопасность приложений&lt;/h4&gt;

&lt;p&gt;Начал докладчик хорошо, описал проблему, мол вот, безопасники говорят, а девелоперы не понимают. Ok, whatever. Что делать? И тут началась ахинея. Упомянул эзотерический исследовательский проект IBM&amp;#39;s SHADOW (&lt;a href=&quot;http://sysrun.haifa.il.ibm.com/shadows/&quot;&gt;http://sysrun.haifa.il.ibm.com/shadows/&lt;/a&gt;). Самолечащийся софт, чтобы это не значило. Докладчик описал это так, цитирую: &amp;quot;When software detects a vulenerability it inserts a new line of code and moves memory&amp;quot;. Все, точка. Wait what? Тем не менее он дал полезное слово для самостоятельного гугления: SDLC&lt;/p&gt;

&lt;h4&gt;Уязвимости реализаций криптографических приложений для платформы Android&lt;/h4&gt;

&lt;p&gt;Доклад до боли был похож на один из defcon&amp;#39;вских 2011 года, только хуже. Суть была такова: докладчик тычел пальцами в тупых девелоперов, который в своих андроидовых приложениях оставили пароль в открытом виде в xml файле конфигурации. Смешно, но посмеялись и ладно. Я ожидал большего)&lt;/p&gt;

&lt;h4&gt;Загрузка файлов стандартными средствами ОС Windows&lt;/h4&gt;

&lt;p&gt;Атакующий имеет возможность заэксплоитить на виндовом хосте уязвимость, которая приведет к выполнению произвольного кода. Как, имея такую возможность, выгрузить на хост файл? Доклад был очень интересный, но в режиме &amp;quot;для своих&amp;quot;. Докладчик почти ничего не пояснял, пропускал очень многое, как &amp;quot;и так понятное&amp;quot;. В результате выглядело все крайне круто, но многое осталось непонятным. Не отрицаю, что это моя проблема на самом деле. Что я запомнил, так это безумный способ заставить хост сделать nslookup, подставить свой dns сервер и сливать с хоста инфу через dns запросы.&lt;/p&gt;

&lt;h4&gt;Windows kernel: краткий курс молодого бойца&lt;/h4&gt;

&lt;p&gt;4-х часовые практические занятия по WinDBG. Подключали отладчик, лазили по ядру, выполняли интересные упражнения. Потом Был рассказ о security-фичах в ядре, включая нововведения в Windows 8. Это было очень интересно. Последний час мы разбирали код драйвера, в котором автор оставил 4 уязвимости и учились их эксплуатировать. Это мероприятие вытащило для меня весь первый день. Узнал много нового, интересного и нужного.&lt;/p&gt;

&lt;h3&gt;День 2.&lt;/h3&gt;

&lt;h4&gt;(Не)безопасность средств защиты&lt;/h4&gt;

&lt;p&gt;Отличный грамотный, в меру веселый write-up о факапах вендоров решений защиты информации. Я ехал на конференцию во многом узнать как делать софт защищеннее. Во многом именно этот доклад дал наилучший результат для меня.&lt;/p&gt;

&lt;h4&gt;Прелюдия к атаке: практика и автоматизация OSINT&lt;/h4&gt;

&lt;p&gt;Еще один отличный доклад. Пентестер рассказывал о подготовке к атаке на клиента. Подготовка заключается в data mining&amp;#39;е информации о топологии сети и, самое главное, сотрудниках клиента. Показывал много интересных инструментов для автоматического поиска такой информации в открытых источниках (google, linkedin, facebook) и ее структурирования. Крайне полезная информация, для тех, кто исповедуют &amp;quot;humans are the weakest link&amp;quot;.&lt;/p&gt;

&lt;h4&gt;Можно ли защитить секреты в российском суде&lt;/h4&gt;

&lt;p&gt;Для меня это был лучший доклад всего мероприятия. Очень грамотный человек очень грамотно рассказывал что такое коммерческая тайна, и на что может рассчитывать от Российских судов организация в случае, если воруют ее секреты (например когда их сливают сотрудники). Информации было крайне много, во многом потому что я ничего об этом не знал ранее. Но суть такова, что нельзя просто назвать что-то коммерческой тайной и начать судить тех, кто по вашему мнению ее ворует. Нужно вводить специальный режим и обеспечивать охрану этой тайны, согласно формально описанным требованиям нашего законодательства. Только в случае соблюдения такого режима в отношении коммерческих секретов можно рассчитывать на помощь суда.&lt;/p&gt;

&lt;h4&gt;Система шифрования White-Box&lt;/h4&gt;

&lt;p&gt;Выступал докладчик из НГУ Parallels лаборатории. Рассказывал о примитиве ассиметричного шифрования, который они придумали. Я, как и большинство аудитории, мало что понял в 15 минутном потоке слайдов с математикой алгоритма, но сама идея создания и внедрения своих алгоритмов и примитивов кажется очень страшной.&lt;/p&gt;

&lt;h4&gt;Кто смотрит на тебя, малыш?&lt;/h4&gt;

&lt;p&gt;Доклад был о том, как страшно жить в мире, где твой смартфон постоянно сливает твое местоположение. Вот. Ну и еще они презентовали свою систему слежения за участниками конференции через rfid badge, из которой юзер мог в любой момент выйти.&lt;/p&gt;

&lt;h4&gt;iOS Mach-Ports Fuzzing&lt;/h4&gt;

&lt;p&gt;А вот это очень интересно. Я долгое время был системным программистом под OS X и знал про mach порты, которые суть низкоуровневый механизм IPC между процессами, сервисами ядра, etc, - все с навешанной системой прав (кто кому может слать сообщения). Ребята выяснили, что доступ к mach портам возможен из песочницы iOS &amp;quot;просто так&amp;quot;. Затем они зафаззили их и получили падения системы в некотором случае, однако у них была цель получить через порт информацию о wifi соединении, что они успешно выполнили. Тем не менее фаззинг портов намекает на уязвимости сервисов, многие из которых работают из под привилегированного пользователя или из ядра. Я решил заняться этой темой самостоятельно, насколько смогу конечно :)&lt;/p&gt;

&lt;h3&gt;Итого&lt;/h3&gt;

&lt;p&gt;Я хотел понять как разрабатывать софт секьюрно, какие процессы для этого нужно внести в процесс разработки и т.п. Почти все доклады, которые меня заинтересовали в этом плане оказались ни о чем. Зато вместо них я попал на ряд не менее интересных вещей, часть их которых все-таки восполнили нишу.&lt;/p&gt;

&lt;p&gt;Зато вторая цель - практика отладки ядра - была выполнена на все сто.&lt;/p&gt;

&lt;p&gt;А еще было встречено много интересных людей :)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>О пользе UEFI спецификации в не-UEFI девелопменте.</title>
   <link href="warfish.github.io//2013/05/19/d0be-d0bfd0bed0bbd18cd0b7d0b5-uefi-d181d0bfd0b5d186d0b8d184d0b8d0bad0b0d186d0b8d0b8-d0b2-d0bdd0b5-uefi-d0b4d0b5d0b2d0b5d0bbd0bed0bfd0bc/"/>
   <updated>2013-05-19T19:04:03+07:00</updated>
   <id>warfish.github.io/2013/05/19/d0be-d0bfd0bed0bbd18cd0b7d0b5-uefi-d181d0bfd0b5d186d0b8d184d0b8d0bad0b0d186d0b8d0b8-d0b2-d0bdd0b5-uefi-d0b4d0b5d0b2d0b5d0bbd0bed0bfd0bc</id>
   <content type="html">&lt;p&gt;Вообще, если абстрагированно взглянуть на UEFI спеку, то можно использовать ее в качестве готовой документации на контракты интерфейсов различных сервисов пребута. Например, посмотрите на относительно простой протокол SIMPLE&lt;em&gt;TEXT&lt;/em&gt;OUTPUT_PROTOCOL (11.4). Спецификация явно декларирует такие вещи как в каких ситуация и как производится перевод позиции текстового курсора:&lt;/p&gt;

&lt;p&gt;Table 90. EFI Cursor Location/Advance Rules (страница 430)&lt;/p&gt;

&lt;p&gt;Mnemonic Unicode Description&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Null     U+0000  Ignore the character, and do not move the cursor.
BS       U+0008  If the cursor is not at the left edge of the display, 
                 then move the cursor left one column.
LF       U+000A  If the cursor is at the bottom of the display, then scroll 
                 the display one row, and do not update the cursor position. 
                 Otherwise, move the cursor down one row.
CR       U+000D  Move the cursor to the beginning of the current row.
Other    U+XXXX  Print the character at the current cursor position 
                 and move the cursor right one column. 
                 If this moves the cursor past the right edge of the display, 
                 then the line should wrap to the beginning of the next line. 
                 This is equivalent to inserting a CR and an LF. 
                 Note that if the cursor is at the bottom of the display, 
                 and the line wraps, then the display will be scrolled one line.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;На мой взгляд это отличная готовая спецификация контракта на интерфейс сервиса печати на текстовую консоль в пребуте, UEFI или не UEFI.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>UEFI 2.3.1 - User Interface Infrastructure</title>
   <link href="warfish.github.io//2013/05/19/uefi-spec-2-3-1/"/>
   <updated>2013-05-19T18:36:25+07:00</updated>
   <id>warfish.github.io/2013/05/19/uefi-spec-2-3-1</id>
   <content type="html">&lt;p&gt;Выгрузил последнюю спецификацию UEFI API: &lt;a href=&quot;https://dl.dropboxusercontent.com/u/42224890/UEFI_Spec_2_3_1.pdf&quot;&gt;https://dl.dropboxusercontent.com/u/42224890/UEFI&lt;em&gt;Spec&lt;/em&gt;2&lt;em&gt;3&lt;/em&gt;1.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Интересные для PBA UI вещи находятся в пунктах 28 и 29. Описывают user interface infrastructure, клавиатурные раскладки, шрифты и формы ввода. Если быстро пробежаться по реализациям этого кода в tianocore, то, на первый взгляд, кажется что они зависят от следующих вещей (цифры указывают на раздел спецификации):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Simple Text Input protocol - 11.3&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Simple Text Output protocol - 11.4&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Simple Pointer Protocol - 11.5&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Absolute Pointer Protocol - 11.7&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Graphics Output Protocol - 11.9&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Поддержка юникода (UTF16LE) идет через реализацию стандартной библиотеки, т.е. опять же прикладной код, который я правда еще не копал, но думаю что он зависит в основном от менеджера памяти. В результате пока что это все зависимости прикладного кода поддержки UI в уефае которые я нашел. При наличии stdlib с уникодом их достаточно несложно реализовать через BIOS. Самый сложный это пожалуй Absolute Pointer Protocol.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>UEFI capabilities and strategy</title>
   <link href="warfish.github.io//2013/05/17/uefi-capabilities-and-strategy/"/>
   <updated>2013-05-17T22:04:12+07:00</updated>
   <id>warfish.github.io/2013/05/17/uefi-capabilities-and-strategy</id>
   <content type="html">&lt;p&gt;Что может UEFI:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Сетевые драйвера, дисковые драйвера, USB, драйвера графической консоли.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UefiToolkit предоставляет прикладную поддержку сетевых проколов (IP, UDP, TFTP, DHCP, TCP), input form UI, unicode, реализацию stdlib и другой прикладной код. Реализован поверх интерфейсов устройств из пункта 1.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Работа в защищенном режиме с пейджингом в плане защиты памяти&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PE/COFF бинарники, которые можно тестировать в пользовательском режиме.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Т.е. для реализации MBO нам нужны &amp;quot;только&amp;quot; драйвера токенов. К сожалению, кроме UEFI систем есть еще и legacy BIOS cистемы, и их достаточно много. На этих системах нет почти ничего из описанных интерфейсов, кроме дисков и сырой видео памяти.&lt;/p&gt;

&lt;p&gt;Итого мы получаем две платформы: legacy BIOS и UEFI. С точки зрения удобства разработки нам нужна одна платформа, чтобы уменьшить набор тестовых конфигураций и максимально повысить переиспользование кода. Для этого нам нужна платформа, которая выравнивает обе предыдущие. При этом, если ставить во главу угла пользовательский экспириенс, то мы должны обеспечить быструю загрузку PBA и прозрачное продолжение загрузки машины после прохождения PBA.&lt;/p&gt;

&lt;p&gt;На UEFI системах мы &lt;em&gt;пока&lt;/em&gt; не представляем как обеспечить прозрачное продолжение загрузки кроме как написать нативное UEFI приложение. Попытки выполнить это на BIOS-e пока приводят к смешанным результатам. Поэтому рождается такой вариант:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Использовать в качестве общей платформы UEFI, в плане спецификации его API.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;В качестве реализации платформы на UEFI системах использовать саму прошивку&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Что делать с legacy BIOS системами? Реализовать требуемый набор UEFI интерфейсов поверх слепленного комка из самого биоса, &lt;a href=&quot;http://ipxe.org/&quot;&gt;iPXE&lt;/a&gt; для поддержки сети и barebones USB (из состава coreboot) для поддержки USB стека.&lt;/p&gt;

&lt;p&gt;Таким образом клиентский код PBA написан против UEFI API, вот только на BIOS мы реализуем этот API сами.&lt;/p&gt;

&lt;p&gt;Плюсы такого подхода:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Одна платформа, переиспользование кода&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Нативное UEFI приложение на UEFI системах работает максимально быстро, обеспечивает прозрачную перезагрузку из коробки.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;На BIOS системах можно использовать прикладной код из UEFI toolkit, потому как наша реализация предоставляет необходимые интерфейсы устройств. Это значит что мы получаем прикладной код сетевых протоколов, UI и stdlib.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Никаких проблем с состоянием аппаратуры на обоих платформах.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Возможность развернуть инфраструктуру разработки, отладки и автоматической сборки на одной платформе с остальным кодом решения (проще говоря, собирать все на винде и не тянуть линукс).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Возможность распараллелить разработку. Один девелопер портирует текущий код и пишет новый для UEFI, второй девелопер наращивает Legacy BIOS до нужного подмножества реализации UEFI API&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Минусы:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Драйвера токенов.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Обеспечивается поддержка только той аппаратуры что нужна именно на ближайший период, не хватает задела на будущее, особенно для экзотических вещей типа сканеров отпечатков пальцев.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Нехилая задача по реализации подмножества UEFI спецификации. Однако есть подспорье в виде &lt;a href=&quot;http://sourceforge.net/apps/mediawiki/tianocore/index.php?title=DuetPkg&quot;&gt;DuetPkg&lt;/a&gt; и &lt;a href=&quot;http://sourceforge.net/projects/cloverefiboot/&quot;&gt;Clover&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если ссумировать сказанное, то на мой взгляд нам так или иначе придется писать нативный UEFI код на UEFI системах, если мы хотим работать без перезагрузки. А если нам придется это делать, то мы в своем роде ограничены сверху именно UEFI. Поэтому почему бы не провести водораздел зависимости нашего кода именно на уровне спецификации UEFI API и доделать то, чего не хватает на legacy BIOS с помощью сторонних библиотек.&lt;/p&gt;

&lt;p&gt;Вопрос, что делать с токенами? Ответ: портировать линуксовую юзер модную реализацию libopensc на USB стек пребута.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>DUET - UEFI environment for BIOS based systems.</title>
   <link href="warfish.github.io//2013/05/16/duet-uefi-environment-for-bios-based-systems/"/>
   <updated>2013-05-16T21:40:50+07:00</updated>
   <id>warfish.github.io/2013/05/16/duet-uefi-environment-for-bios-based-systems</id>
   <content type="html">&lt;p&gt;http://sourceforge.net/apps/mediawiki/tianocore/index.php?title=DuetPkg&lt;/p&gt;

&lt;p&gt;Звучит интересно, но я сильно сомневаюсь, что он поддерживает аппаратуру, которую не поддерживает биос, на котором он сидит&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Dell optiplex and buggy BIOSes</title>
   <link href="warfish.github.io//2013/05/16/dell-optiplex-and-buggy-bioses/"/>
   <updated>2013-05-16T21:16:50+07:00</updated>
   <id>warfish.github.io/2013/05/16/dell-optiplex-and-buggy-bioses</id>
   <content type="html">&lt;p&gt;Сегодня прототип отказался загружаться на тестовой машине Dell optiplex 790. Судя по гуглу, нам безумно повезло с тестовым железом. &lt;a href=&quot;http://www.gnu.org/software/grub/&quot;&gt;GRUB&lt;/a&gt; содержит такую кашу воркэраундов вокруг деллового биоса, что волосы встают дыбом.&lt;/p&gt;

&lt;p&gt;Проект grub4dos, который пытается выполнить очень близкую нам вещь - загрузится из линукса через &lt;a href=&quot;http://en.wikipedia.org/wiki/Kexec&quot;&gt;kexec&lt;/a&gt; и стартовать другую ОС - так же испытывает много боли:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://reboot.pro/topic/10201-grub4dos-and-dell-optiplex-cant-boot/&quot;&gt;http://reboot.pro/topic/10201-grub4dos-and-dell-optiplex-cant-boot/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://reboot.pro/topic/12449-funny-dell-bios-and-how-to-determine-number-of-hd-connected/&quot;&gt;http://reboot.pro/topic/12449-funny-dell-bios-and-how-to-determine-number-of-hd-connected/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.911cd.net/forums/lofiversion/index.php/t20864.html&quot;&gt;http://www.911cd.net/forums/lofiversion/index.php/t20864.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Выводы:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Нужно попробовать посмотреть и позапускать grub4dos (кажется через него работает guardian edge).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Нужно попробовать другое, не делловое, железо.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>One down, more to go</title>
   <link href="warfish.github.io//2013/05/15/one-down-more-to-go/"/>
   <updated>2013-05-15T20:52:35+07:00</updated>
   <id>warfish.github.io/2013/05/15/one-down-more-to-go</id>
   <content type="html">&lt;p&gt;Сегодня нам удалось загрузить XP с IDE диска из-под линукса. :)&lt;/p&gt;

&lt;p&gt;Что мы узнали по дороге:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_8259&quot;&gt;8259A&lt;/a&gt; PIC нужно не только перемаппировать на rm оффсеты векторов прерываний, но и явно показать кто из них мастер, кто из них слейв, по какой линии они связаны. Дисковые прерывания это IRQ14 и IRQ15 и они должны идти от slave PIC на master PIC и потом уже маппироваться на 0x76 и 0x77 софтверное прерывание соответственно. Без этого доставку прерываний гарантировать нельзя.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_8253&quot;&gt;Intel 8253&lt;/a&gt; / 8254 PIT Программируемый таймер. Ядро использует его в качестве раннего источника тайминга. При этом ядро перепрограммирует его на свой удобный ядру режим. В результате чего (как мы подозреваем) подобие реализации sleep в биосе в реальном режиме никогда не дожидается таймера.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ядру можно запретить перераспределять PCI ресурсы параметром загрузки pci=realloc=off&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PCI IDE контроллер в итоге не составил никакой проблемы.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kexec вообще-то проводит достаточно глубокую деинициализацию платформы.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Extensible Boot Platform</title>
   <link href="warfish.github.io//2013/05/13/extensible-boot-platform/"/>
   <updated>2013-05-13T21:15:14+07:00</updated>
   <id>warfish.github.io/2013/05/13/extensible-boot-platform</id>
   <content type="html">&lt;p&gt;&lt;em&gt;Problem statement:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Есть определенное количество кода, который должен работать до загрузки операционной системы. Bootloader, особенно те, что работают на тонких клиентах. Агенты preboot authentication и низкоуровнего форматирования дисков. Антивирусные сканеры и антируткиты. Всем им нужен определенный функционал и исполняемое окружение. Исторически таким окружением служит &lt;a href=&quot;http://en.wikipedia.org/wiki/BIOS&quot;&gt;BIOS&lt;/a&gt; в реальном (в лучшем случае защищенном) режиме. В последнее время &lt;a href=&quot;http://www.uefi.org/&quot;&gt;UEFI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Неудобство такого окружения в том, что даже в защищенном режиме нет защиты памяти, поддержки дополнительных устройств (сеть, USB), нормального пользовательского ввода и вывода. С появлением UEFI ситуация улучшается, но появляется проблема двух платформ.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Vision&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;Extensible Boot Platform - платформа, портируемая на BIOS и UEFI, расширяемая пользовательским кодом бизнес логики. Предоставляет набор runtime сервисов для клиентского кода, среду выполнения с защитой памяти, абстрагированный доступ к современной аппаратуре и простую драйверную модель. Ориентирована на поддержку загрузчиков ОС с продвинутыми функциями.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Must have:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Execution in protected mode with memory protection&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Modern hardware support: PCI, (IO-)APIC, AHCI, USB.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Network support: Ethernet, UDP, IP.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CRT subset implementation and support for modern compilers&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Hardware state management to support chainboot into host OS.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fast boot time&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Nice to have:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Unicode&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Simplistic GUI toolkit with pointer device support&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Localization&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;File systems&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Non-issue, что не включается в скоуп:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SMP&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Processes and threads.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Users, user context and user rights management&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Paging&quot;&gt;Paging&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Почему EBP это не UEFI:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;UEFI отвечает за низкоуровневую инициализацию железа, зависимую от конкретной модели чипсета и топологии устройств на отдельно взятой материнской плате. EBP предоставляет слой абстракции над UEFI, унифицируя набор предоставляемых сервисов как между версиями UEFI так и между Legacy BIOS и UEFI.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Почему EBP это не однопроцессная ОС:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;EBP существует в виде библиотеки бинарного кода, реализующей предоставляемые сервисы и статически линкующейся с пользовательским кодом для получения исполняемого образа ядра. Пользовательский код не существует в виде одного отдельного исполняемого процесса, вместо этого он  является полезной нагрузкой самого ядра.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Почему EBP это не GRUB:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;EBP не выполняет функцию загрузчика ОС сам по себе. Вместо этого он ориентирован на делегирование пользовательскому коду любого реально полезного функционала, четко разграничивая свою зону ответственности и явно предоставляя сервисы для поддержки расширений.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Модель разработки:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Open-source, максимальное заимствование кода драйверов и стеков протоколов.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Это реально сделать?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Все реально сделать имея неограниченные ресурсы. Не имея неограниченных ресурсов все можно попытаться оценить, представить сроки, стоимость и принять взвешенное решение. И именно так я и &lt;strong&gt;не&lt;/strong&gt; ответил на этот вопрос сам :)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>8259A Interrupt controller issues</title>
   <link href="warfish.github.io//2013/05/12/8259a-interrupt-controller-issues/"/>
   <updated>2013-05-12T17:24:59+07:00</updated>
   <id>warfish.github.io/2013/05/12/8259a-interrupt-controller-issues</id>
   <content type="html">&lt;p&gt;Другие проблемы, которые точно возникают при возврате из ядра ОС, работающей в защищенном режиме, обратно в реальный это переинициализация &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_8259&quot;&gt;8259A&lt;/a&gt; контроллера(ов) прерываний. На типичной PC/AT - совместимой системе таких контроллеров два. Они занимаются тем, что сериализуют прерывания от нескольких устройств и маппируют их на вектора прерываний x86-совместимого процессора. Каждый контроллер предоставляет 8 линий прерываний. Один из контроллеров мастер, а другой слейв.&lt;/p&gt;

&lt;p&gt;Для реального режима типичен маппинг 8 линий прерываний первого контроллера на оффсет вектора 0x08, т.е. на вектора 0x08 - 0x0F прерываний процессора. Второй контроллер замаппирован на оффсет 0x70 (0x70 - 0x77). В защищенном режиме Intel резервирует вектора от нуля до 0x1F включительно под аппаратные прерывания, поэтому первый контроллер должен быть перемаплен, но обычно перемаппируют сразу оба контроллера на вектора 0x20 - 0x2F.&lt;/p&gt;

&lt;p&gt;В результате по возврату в реальный режим без перемаппирования контроллеров глохнет например клавиатура (IRQ1, real mode INT 09h [08h base + 01h]). К слову сказать это то, что мы видели у McAfee по возврату в реальный режим и то что мы сами тоже уже делаем. А вот что делать с &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_APIC_Architecture&quot;&gt;IO-APIC&lt;/a&gt;, пока не понятно :)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wiki.osdev.org/PIC#What_does_the_8259_PIC_do.3F&quot;&gt;http://wiki.osdev.org/PIC#What&lt;em&gt;does&lt;/em&gt;the&lt;em&gt;8259&lt;/em&gt;PIC_do.3F&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CoreBoot</title>
   <link href="warfish.github.io//2013/05/11/coreboot/"/>
   <updated>2013-05-11T23:18:44+07:00</updated>
   <id>warfish.github.io/2013/05/11/coreboot</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://coreboot.org/&quot;&gt;coreboot&lt;/a&gt; это опен сорсная реализация нижней половины биоса. Нижней половины означает, что он не реализует API прерываний, GUI настроек и прочее. Все это делегирует payload-у в терминологии проекта. Вместо этого coreboot реализует инициализацию чипсета, устройств и запускает payload. Проект поддерживается многими производителями чипсетов, такими как AMD например (Intel продвигает UEFI).&lt;/p&gt;

&lt;p&gt;Это очень интересный проект по которому можно изучить что делает биос на самых первых этапах старта машины, еще из EEPROM. Ниже линки на особенно заинтересовавшие части:&lt;/p&gt;

&lt;p&gt;Старт прошивки в реальном режиме: &lt;a href=&quot;http://review.coreboot.org/gitweb?p=coreboot.git;a=blob;f=src/cpu/x86/16bit/entry16.inc;h=e4613bf986c15d73e7ea70f72dc241d1539f3038;hb=HEAD&quot;&gt;http://review.coreboot.org/gitweb?p=coreboot.git;a=blob;f=src/cpu/x86/16bit/entry16.inc;h=e4613bf986c15d73e7ea70f72dc241d1539f3038;hb=HEAD&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Старт прошивки в защищенном режиме:&lt;a href=&quot;http://review.coreboot.org/gitweb?p=coreboot.git;a=blob;f=src/cpu/x86/32bit/entry32.inc;h=f74e1b87374e2f11af1fa7b7f60e3c17da1d4f1c;hb=HEAD&quot;&gt; http://review.coreboot.org/gitweb?p=coreboot.git;a=blob;f=src/cpu/x86/32bit/entry32.inc;h=f74e1b87374e2f11af1fa7b7f60e3c17da1d4f1c;hb=HEAD&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Точка входа инициализации устройств:&lt;a href=&quot;http://review.coreboot.org/gitweb?p=coreboot.git;a=blob;f=src/lib/hardwaremain.c;h=99b4a069b4ddabf6b79926bd482be54f6f1ab828;hb=HEAD&quot;&gt; http://review.coreboot.org/gitweb?p=coreboot.git;a=blob;f=src/lib/hardwaremain.c;h=99b4a069b4ddabf6b79926bd482be54f6f1ab828;hb=HEAD&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Реализация общего драйвера PCI устройства: &lt;a href=&quot;http://review.coreboot.org/gitweb?p=coreboot.git;a=blob;f=src/device/pci_device.c;h=4c5a81451c923072b48182cb198080823ab19402;hb=HEAD&quot;&gt;http://review.coreboot.org/gitweb?p=coreboot.git;a=blob;f=src/device/pci_device.c;h=4c5a81451c923072b48182cb198080823ab19402;hb=HEAD&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Thoughts on disk timeout after return to real mode from linux kernel</title>
   <link href="warfish.github.io//2013/05/11/thoughts-on-disk-timeout-after-return-to-real-mode-from-linux-kernel/"/>
   <updated>2013-05-11T16:56:34+07:00</updated>
   <id>warfish.github.io/2013/05/11/thoughts-on-disk-timeout-after-return-to-real-mode-from-linux-kernel</id>
   <content type="html">&lt;p&gt;Читаю про PCI шину. Она полностью конфигурируется программно и на стадии инициализации железа прошивка (а потом ОС) раздает каждому подключенному устройству ресурсы. Ресурсы включают в себя адресное пространство x86 I/O портов и линий прерываний через которые процессор общается с устройством, а устройство сигнализирует свое состояние. Делается это через &lt;a href=&quot;http://en.wikipedia.org/wiki/PCI_configuration_space&quot;&gt;PCI Configuration Space&lt;/a&gt;, который доступен сразу через host bridge по портам CF8 для задания адреса устройства и CFC для чтения и записи конфигурации.&lt;/p&gt;

&lt;p&gt;Нет ничего удивительного в том, что BIOS и ядро ОС раздают эти ресурсы по-разному. И соответственно нет ничего удивительного в том, что возвращаясь в реальный режим после линуксового ядра INT13h начинает возвращать таймауты дискового запроса: скорее всего BIOS ожидает ответа IDE/AHCI/RAID/SCSI контроллера на другом порту/линии прерывания.&lt;/p&gt;

&lt;p&gt;Вообще это звучит как приговор для попыток решить задачу состояния устройств в общем случае, однако чтобы подтвердить такую теорию нужно делать обход PCI шины и дампить PCI Configuration Space для каждого подключенного устройства до загрузки ядра и после возврата в реальный режим и сравнивать их. Далее можно либо пытаться вернуть конфигурацию к предыдущим значениям, либо пытаться заставить ядро не переконфигурировать ничего, что может привести к неожиданным последствиям. Так или иначе, задача видится как очень объемная, если конечно не пытаться решить ее как WinMagic - топорно и только для SATA дисков в AHCI режиме.&lt;/p&gt;

&lt;p&gt;Интересно то, что после возврата продолжают работать COM порты, видимо потому что они подключены к ISA шине через &lt;a href=&quot;http://en.wikipedia.org/wiki/Conventional_PCI&quot;&gt;PCI bridge&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;TOREAD:
TLDP Linux PCI handling: &lt;a href=&quot;http://tldp.org/LDP/tlk/dd/pci.html&quot;&gt;http://tldp.org/LDP/tlk/dd/pci.html&lt;/a&gt;
LDD chapter 12 &amp;quot;PCI drivers&amp;quot;: &lt;a href=&quot;http://lwn.net/images/pdf/LDD3/ch12.pdf&quot;&gt;http://lwn.net/images/pdf/LDD3/ch12.pdf&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 

</feed>
