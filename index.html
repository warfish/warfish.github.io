<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      My worklog &middot; My worklog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.png">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="My worklog" href="/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h2 class="masthead-title">
          <a href="/" title="Home">My worklog</a>
          <small><a href="https://github.com/warfish">GitHub</a></small>
          <small><a href="/archive/">Archive</a></small>
          <small><a href="/tags/">Tags</a></small>
        </h3>
      </header>

      <main>
        <div class="wrapper">
  <div class="center">

    <div class="posts">
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2015/01/31/CPU-out-of-order-optimization/">
        CPU out-of-order performance
      </a>
    </h1>

    <time datetime="2015-01-31T00:00:00+06:00" class="post-date">31 Jan 2015</time>

    <p>Начиная с <a href="http://en.wikipedia.org/wiki/P6_%28microarchitecture%29">P6</a> интел реализует out-of-order спекулятивную суперскалярную микроархитектуру. Это означает, в общих чертах, что в ядре работают несколько конвееров и оно умеет наружать их микрокодом инструкций не обязательно в том порядке, в котором они идут в машинном коде если результат вычислений в пределах instruction window не меняется. </p>

<p>На практике это означает, что если внутри ограниченной последовательности инструкций последующая инструкция не зависит от результата вычислений предыдущей, то ее можно начать выполнять уже сейчас, оптимально на другом конвеере:</p>

<p>
<a href="http://www.renesas.com/media/products/mpumcu/rx/getting_started/feature/rxfamily_feature01.gif"><img src="http://www.renesas.com/media/products/mpumcu/rx/getting_started/feature/rxfamily_feature01.gif"></img></a>
</p>

<p>Это известная фича, но я решил сделать небольшой бенчмарк. Для этого я сделал 64-х битный уефайный бинарник, который запускается на одном ядре на голом железе и выполняет три теста замеряя производительность с помощью сериализующей RDTSCP:
<ul>
<li>Первый тест считает оверхед, наложенный работой с RDTSCP - контрольная группа.</p>

<div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">test0:</span>
    <span class="c1">; Save-disable interrupts</span>
    <span class="nf">pushf</span>
    <span class="nf">cli</span>

    <span class="c1">; Save starting tsc in rbx (wasting some overhead cycles)</span>
    <span class="nf">rdtscp</span>              
    <span class="nf">shl</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="mi">32</span>     
    <span class="nf">add</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="nb">rax</span>    
    <span class="nf">mov</span>     <span class="nb">rbx</span><span class="p">,</span> <span class="nb">rdx</span>    
    
    <span class="c1">; Collect end tsc</span>
    <span class="nf">rdtscp</span>              
    <span class="nf">shl</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="mi">32</span>     
    <span class="nf">add</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="nb">rax</span>
    <span class="nf">mov</span>     <span class="nb">rax</span><span class="p">,</span> <span class="nb">rdx</span>
    <span class="nf">sub</span>     <span class="nb">rax</span><span class="p">,</span> <span class="nb">rbx</span>

    <span class="c1">; Restore interrupts and return</span>
    <span class="nf">popf</span>
    <span class="nf">ret</span></code></pre></div>

<p></li></p>

<p><li>
Второй тест пытается сложить шесть 64-х битных чисел со стека и сохранить результат по указателю на стеке. При этом в коде сложения каждая следующая инструкция зависит от результатов предыдущей</p>

<div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">test1:</span>
    <span class="nf">push</span>    <span class="nb">rbp</span>
    <span class="nf">mov</span>     <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="c1">; Save-disable interrupts</span>
    <span class="nf">pushf</span>
    <span class="nf">cli</span>

    <span class="c1">; Save starting tsc in rbx (wasting some overhead cycles)</span>
    <span class="nf">rdtscp</span>              
    <span class="nf">shl</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="mi">32</span>     
    <span class="nf">add</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="nb">rax</span>    
    <span class="nf">mov</span>     <span class="nb">rbx</span><span class="p">,</span> <span class="nb">rdx</span>    
    
    <span class="c1">; Add numbers</span>
    <span class="nf">mov</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">]</span>
    <span class="nf">mov</span>     <span class="nb">rax</span><span class="p">,</span> <span class="nb">rdx</span>            
    <span class="nf">mov</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">]</span>
    <span class="nf">add</span>     <span class="nb">rax</span><span class="p">,</span> <span class="nb">rdx</span>            
    <span class="nf">mov</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span>
    <span class="nf">add</span>     <span class="nb">rax</span><span class="p">,</span> <span class="nb">rdx</span>            
    <span class="nf">mov</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">]</span>
    <span class="nf">add</span>     <span class="nb">rax</span><span class="p">,</span> <span class="nb">rdx</span>            
    <span class="nf">mov</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">]</span>
    <span class="nf">add</span>     <span class="nb">rax</span><span class="p">,</span> <span class="nb">rdx</span>            
    <span class="nf">mov</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">]</span>
    <span class="nf">add</span>     <span class="nb">rax</span><span class="p">,</span> <span class="nb">rdx</span>            
    
    <span class="c1">; Store</span>
    <span class="nf">mov</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">]</span>
    <span class="nf">mov</span>     <span class="p">[</span><span class="nb">rdx</span><span class="p">],</span> <span class="nb">rax</span>

    <span class="c1">; Collect end tsc</span>
    <span class="nf">rdtscp</span>              
    <span class="nf">shl</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="mi">32</span>    
    <span class="nf">add</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="nb">rax</span>
    <span class="nf">mov</span>     <span class="nb">rax</span><span class="p">,</span> <span class="nb">rdx</span>
    <span class="nf">sub</span>     <span class="nb">rax</span><span class="p">,</span> <span class="nb">rbx</span>

    <span class="c1">; Restore interrupts and return</span>
    <span class="nf">popf</span>
    <span class="nf">pop</span>     <span class="nb">rbp</span>
    <span class="nf">ret</span></code></pre></div>

<p></li></p>

<p><li>
Третий тест делает тоже самое что и второй, но в нем я пытался написать максимально дружелюбный к out-of-order код. При этом количество инструкций выполняющих сложение одинаково в обоих тестах</p>

<div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">test2:</span>
    <span class="nf">push</span>    <span class="nb">rbp</span>
    <span class="nf">mov</span>     <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="c1">; Save-disable interrupts</span>
    <span class="nf">pushf</span>
    <span class="nf">cli</span>

    <span class="c1">; Save starting tsc in rbx (wasting some overhead cycles)</span>
    <span class="nf">rdtscp</span>              
    <span class="nf">shl</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="mi">32</span>     
    <span class="nf">add</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="nb">rax</span>    
    <span class="nf">mov</span>     <span class="nb">rbx</span><span class="p">,</span> <span class="nb">rdx</span>    
    
    <span class="c1">; Add numbers</span>
    <span class="nf">mov</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">]</span>
    <span class="nf">mov</span>     <span class="nb">rcx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">]</span>
    <span class="nf">mov</span>     <span class="nv">r8</span><span class="p">,</span>  <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span>
    <span class="nf">mov</span>     <span class="nv">r9</span><span class="p">,</span>  <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">]</span>
    <span class="nf">mov</span>     <span class="nv">r10</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">]</span>
    <span class="nf">mov</span>     <span class="nv">r11</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">]</span>
    <span class="nf">add</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="nb">rcx</span>
    <span class="nf">add</span>     <span class="nv">r8</span><span class="p">,</span> <span class="nv">r9</span>
    <span class="nf">add</span>     <span class="nv">r10</span><span class="p">,</span> <span class="nv">r11</span>
    <span class="nf">add</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="nv">r8</span>
    <span class="nf">add</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="nv">r10</span>
    <span class="nf">mov</span>     <span class="nb">rax</span><span class="p">,</span> <span class="nb">rdx</span> 

    <span class="c1">; Store</span>
    <span class="nf">mov</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">]</span>
    <span class="nf">mov</span>     <span class="p">[</span><span class="nb">rdx</span><span class="p">],</span> <span class="nb">rax</span>

    <span class="c1">; Collect end tsc</span>
    <span class="nf">rdtscp</span>              
    <span class="nf">shl</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="mi">32</span>     
    <span class="nf">add</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="nb">rax</span>
    <span class="nf">mov</span>     <span class="nb">rax</span><span class="p">,</span> <span class="nb">rdx</span>
    <span class="nf">sub</span>     <span class="nb">rax</span><span class="p">,</span> <span class="nb">rbx</span>

    <span class="c1">; Restore interrupts and return</span>
    <span class="nf">popf</span>
    <span class="nf">pop</span>     <span class="nb">rbp</span>
    <span class="nf">ret</span></code></pre></div>

<p></li></p>

<p></ul></p>

<p>Каждый тест, как я уж сказал, я прогнал 4 раза на голом железе с выключенными прерываниями. Еще я заренее разогревал кеши инструкций верхушки стека предварительным проходом, который не фиксируется:</p>

<ul>
<li>Первый тест, оверхед замеров:
<pre>
0: 36
1: 36
2: 36
3: 36
Mean: 36
</pre>
</li>

<li>Второй тест, пессимизация под out-of-order:
<pre>
0: 154
1: 156
2: 152
3: 144
Mean: 151.5
</pre>
</li>

<li>Третий тест, оптимизация под out-of-order:
<pre>
0: 40
1: 40
2: 40
3: 40
Mean: 40
</pre>
</li>

</ul>

<p>Результаты говорят сами за себя и в общем-то ожидаемые.<br />
Тесты гонялись на Intel(R) Core(TM) i3-3240 CPU @ 3.40GHz</p>

    
    <span class="tags">
      
      <a href="/hardware/">hardware</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2015/01/30/github-ci/">
        GitHub + Continuous Integration
      </a>
    </h1>

    <time datetime="2015-01-30T00:00:00+06:00" class="post-date">30 Jan 2015</time>

    <p>Недавно я стал замечать на гитхабовых репозиториях светофоры со статусами билдов. При выяснении что это такое оказалось что это внешний, интегрированный с гитхабом, сервис continuous integration. Как правило это <a href="http://travis-ci.org">travis-ci</a>. Сервис позволяет автоматически запускать билды и тесты для заданных конфигураций языков и тулчейнов и генерить отчеты о статусе таких билдов. Настроить все очень просто, вот <a href="http://docs.travis-ci.com/user/getting-started/">три шага к успеху</a>.</p>

<p>Я сделал себе тестовый репозиторий: <a href="https://github.com/warfish/ci-test">ci-test</a>. Для подцепления репы к травису нужно написать YAML конфигурацию в .travis.yml:</p>

<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="l-Scalar-Plain">language</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">c</span>
<span class="l-Scalar-Plain">compiler</span><span class="p-Indicator">:</span>
<span class="p-Indicator">-</span> <span class="l-Scalar-Plain">gcc</span>
<span class="p-Indicator">-</span> <span class="l-Scalar-Plain">clang</span>
<span class="l-Scalar-Plain">script</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">make run</span></code></pre></div>

<p>Результаты билдов можно посмотреть тут <a href="https://travis-ci.org/warfish/ci-test">https://travis-ci.org/warfish/ci-test</a>.</p>

<p>UPD: </p>

<p>Я решил сделать что-то поинтереснее. У меня есть репозиторий <a href="https://github.com/warfish/chip8">chip8</a> - эмулятор chip8 с автотестами на CUnit. Чтобы собрать его нужно вытянуть зависимость от CUnit сначала. Это получилось сделать тривиально в yml конфиге:</p>

<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="l-Scalar-Plain">language</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">c</span>
<span class="l-Scalar-Plain">compiler</span><span class="p-Indicator">:</span>
<span class="p-Indicator">-</span> <span class="l-Scalar-Plain">gcc</span>
<span class="l-Scalar-Plain">before_script</span><span class="p-Indicator">:</span>
<span class="p-Indicator">-</span> <span class="l-Scalar-Plain">sudo apt-get install libcunit1</span>
<span class="p-Indicator">-</span> <span class="l-Scalar-Plain">sudo apt-get install libcunit1-dev</span>
<span class="l-Scalar-Plain">script</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">make chip8-test</span></code></pre></div>

<p>И вот лог первого билда с автотестами: <a href="https://travis-ci.org/warfish/chip8/builds/48865917">https://travis-ci.org/warfish/chip8/builds/48865917</a></p>

    
    <span class="tags">
      
      <a href="/github/">github</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2014/11/17/d181d0bed181d183d189d0b5d181d182d0b2d0bed0b2d0b0d0bdd0b8d0b5-uefi-d0b8-d0bbd0b8d0bdd183d0bad181d0bed0b2d0bed0b3d0be-d18fd0b4d180d0b0/">
        Сосуществование UEFI и линуксового ядра для пребутовой авторизации с помощью гипервизора
      </a>
    </h1>

    <time datetime="2014-11-17T13:20:53+06:00" class="post-date">17 Nov 2014</time>

    <p>Использование линуксового ядра как богатой платформы для поддержки пребутовой аутентификации на UEFI железе ограничено конфликтом управления машиной - и UEFI и ядро хотят управлять физической памятью и переферией, а ExitBootServices сделать нельзя потому что потом нужно вернуться в UEFI и продолжить загрузку хостовой ОС без перезагрузки машины. Я ранее накидывал <a href="http://wrfsh.wordpress.com/2014/06/06/linux-on-efi-wo-reboot/">идеи</a> как можно обойти эту проблему. Теперь родился новый вариант, связанный с <a href="http://wrfsh.wordpress.com/2014/11/07/%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F/">виртуализацией</a>.</p>

<p>Потенциальное решение базируется на self-contained type-2 гипервизоре, т.е. гипервизоре хостящемся не напрямую на железе, а на существующей софтверной платформе, которая управляет страничной памятью, в данном случае UEFI. Такой гипервизор стартует как UEFI приложение и начинает драйвить VT железо платформы. Создается виртуальный сендбокс, в который загружается ядро. Управление ресурсами происходит следующим образом:</p>

<ol>
<li><p>Страничная память. Виртуализация добавляет еще один уровень виртуальной памяти: гипервизор мапит то, что ядро видит как непрерывный физический диапазон линейный адресов. Таким образом UEFI и ядро можно развести на уровне гипервизора не мапя страницы занатые фирмварью.</p></li>
<li><p>Доступ к переферийному железу. Тут есть целый ряд возможностей. Через фильтр PCI config space от ядра можно скрыть те устройства доступ к которым мы хотим ограничить (диск, фреймбуфер) и отдать те, которые фильтровать не нужно (USB, сеть). Доступ к ограниченным устройствам можно либо перехватывать через I/O пространство (включая DMA), либо скрыть насовсем и написать драйвера для линукса, которые знают про гипервизор и делают явные гиперколлы, реализация которых опирается на драйвера фирмвари. Тут есть потенциальные грабли - если идти по пути полной фильтрации, то информация о PCI устройстве иногда есть и в ACPI помимо PCI Config Space.</p></li>
<li><p>Обработка прерываний. Тут сложнее - если гипервизор хостится на фирмвари, то фирмварь должна видеть прерывания. Ядро тоже должно видеть прерывания для нормальной работы. Этот момент еще до конца не изучен, но есть несколько вариантов, среди которых например эмуляция legacy контроллера прерываний для ядра на базе кода из qemu. Ядро можно собрать с отключенной поддержкой SMP, APIC, IOAPIC, что значительно упрощает жизнь. При этом прерывания от PCI линий, маршрутизируемые через IOAPIC, работать конечно не будут, но ядро готово к этому через irqpoll. Теоретически можно разрешить IOAPIC, но тогда конфликты с фирмварью неизбежны. Придется заниматься жестким переключением контекста при возврате в фирмварь.</p></li>
<li><p>ExitBootServices. Ядро можно собрать как UEFI приложение чтобы выкинуть этап загрузчика. Такое ядро загружается в виртуальном окружении и хочет позвать ряд функций фирмвари. Сделать это ему будет проблематично, потому как код фирмвари <em>не мапится</em> в виртуализованное физическое пространство ядра (см п.1). Решение простое - в ядре есть слой fake firmware, который можно реализовать самостоятельно и слинковать с ядром таким образом подставив свою реализацию ExitBootServices и пары других UEFI функций, которые уже могут делать что угодно, например бежать в гипервизор.</p></li>
<li><p>При передаче управления в хостовую ОС такой гипервизор, будучи хостящимся на UEFI, можно легко свернуть вместе с ядром и отдать машину обратно в UEFI а затем в хостовую ОС. Теоретически можно не сворачивать гипервизор до того как хостовая ОС не сделает ExitBootServices. Это позволит, например, эмулировать интерфейсы фирмвари через линуксовое ядро в процессе загрузки хостовой ОС в случае если это проще чем решить проблему с состоянием переферии. Но это уже совсем адвансед :)</p></li>
</ol>

<p>Естественно такое решение упирается в первую очередь в аппаратную поддержку, но его необходимость видится именно для UEFI платформ - для legacy BIOS можно, хоть и менее красиво, решить задачу и без использования виртуализации.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2014/11/07/d0b2d0b8d180d182d183d0b0d0bbd0b8d0b7d0b0d186d0b8d18f/">
        Виртуализация
      </a>
    </h1>

    <time datetime="2014-11-07T11:52:05+06:00" class="post-date">07 Nov 2014</time>

    <p>Виртуализация, в разрезе технологии интеловских процессоров, позволяет делать ряд интересных вещей. Сам принцип такой - процессор входит в режим vm набором инструкций, после чего код гипервизора перемещается в ring -1, затем работа продолжается как обычно. Гипервизор, оставаясь резидентным в ring -1 может получать управление разными способами:</p>

<ul>
<li><p>Периодически, перехватив прерывания или через preemption timer.</p></li>
<li><p>Синхронно через механизм vm-call-ов который реализуется самим гипервизором и используется модифицированной ОС или драйвером в ней, т.е. агентом в ring 0, который знает о гипервизоре.</p></li>
<li><p>Асинхронно по возникновению интересующих гипервизора событий от нормальной работы немодифицированного кода.</p></li>
</ul>

<p>Последний механизм самый интересный. Код гипервизора может перехватывать ряд интересных для него событий, которые генерирует нормальная работа немодифицированного кода всех менее привелигерованных режимов. Когда эти события возникают, то процессор делает т.н. vmexit, т.е. возврат в ring -1 и передачу управления хендлеру гипервизора. Механизм похож на exception handler, но регистрация на интересующие исключения происходит по-другому. Что можно перехватывать - много чего, но вот одни из самых интересных вещей:</p>

<ul>
<li><p>Обращения к физической памяти. В режиме виртуализации то что ОС в ring 0 видит как физическую память на самом деле виртуальные адреса смаппированные гипервизором. Ring 0 продолжает нормально работать с этой памятью как с физической, мапить ее на виртуальные адреса, но на самом деле трансляция в физический адрес проходит через дополнительную таблицу страниц гипервизора, у которого есть возможность при маппировании физической страницы указать флагами генерацию исключения и vmexit при доступе к этой странице на R/W/X. В результате можно перехватывать любые обращения гостевой ОС к интересующему диапазону адресов.</p></li>
<li><p>I/O адресное пространство. При инициализации гипервизор может задать битовую маску на весь диапазон I/O портов x86 (почти на весь - у интела баг, который не позволяет захватить два последних бита в маске). Эффект тот же что и с памятью - vmexit при попытке обращения к I/O порту. Это дает дополнительную возможность перехвата одного из способов обращения к PCI Configuration Space, о котором позже.</p></li>
<li><p>MSR - vmexit при попытке R/W на интересующий регистр.</p></li>
<li><p>Еще несколько дополнительных триггеров, включая обращения к XMM/FPU контексту, CPUID, GDT, LDT, IDT, CR регистры.</p></li>
</ul>

<p>Все это позволяет гипервизору эмулировать отдельную песочницу для каждого из гостей,аллоцировать ресурсы и переключать выполнение между несколькими гостями, фильтровать и перенаправлять прерывания и т.д. без модификации самих гостей. А еще это позволяет перехватывать весь доступ гостя к ACPI, PCI и MSR, - т.е. всеми каналами управления переферийным железом и чипсетами, что открывает интересные возможности по фильтрации доступа к железу. Можно спрятать PCI устройство, можно нарисовать свое фейковое устройство и т.д. Это открывает дополнительные прикладные возможности виртуализации, помимо очевидной основной, в рамках одного гостя.</p>

<p>Например можно попытаться решить проблему с &quot;богатым пребутом&quot; - запустить линукс с возвратом в фирмварь без потери состояния железа, через жесткий ACPI и PCI фильтр и редирект запросов на допустимые устройства в драйвер фирмвари. В случае UEFI можно попытаться не делать выход из бут сервисов, а отобрать у фирмвари процессор на время, защитить ее память и запустить ядро линукса.</p>

<p>Но одна из самых интересных прикладных задач для меня это инструменты, точнее дебаггер с элементами гипервизора для бареметал. Типичный механизм брейкпоинтов и вочпоинтов подразумевает, что ты знаешь адрес, по которому должен сработать выход в дебаггер. В случае отлаживания и исследования неизвестного кода, например фирмвари, адреса заранее не известны, есть только теория что код обращается к железу / странице памяти / MSRу (например чтобы поменять GS_BASE ;)). В таких случаях нужно нечто более &quot;декларативное&quot;, нужно сказать что-то типа &quot;я не знаю где это происходит, но как только это произойдет, то я хочу об этом знать&quot;, что и позволяют в определенных пределах элементы гипервизора. Помимо отладки такой инструмент можно использовать для исследования чужого кода, в том числе вредоносного, играть с внедрением ошибок от устройств, эмулировать устройства на самом нижнем уровне для проверки устойчивости системы к ошибкам и поиска уязвимостей например.</p>

<p>Основной недостаток это конечно аппаратные требования. У интела нужную технологию поддерживает уже более менее вся линейка core i процессоров второго и последующих поколений. У AMD своя технология, отдельная от интела и я про нее мало знаю, кроме того что общий смысл тот же, а опкоды другие. У ARM-ов тоже недавно появился TrustZone, который по сути тот же ring -1.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2014/09/12/smm-d0b1d0b0d0b3d0b8-d0b1d0b8d0bed181d0b0/">
        SMM баги биоса
      </a>
    </h1>

    <time datetime="2014-09-12T10:59:05+07:00" class="post-date">12 Sep 2014</time>

    <p>Есть подозрение на аппаратный/SMM баг USB Legacy Support на Dell Optiplex 790.</p>

<p>Имеем данную машину и подключенные к ней USB клаву и мышь, которые работают через виртуальный 8042 PS/2 контроллер через USB Legacy Support. Биос настраивает виртуальный 8042 так, что сканирование KBD порта разрешено, а сканирование AUX порта отключено. Хучим в риалмодной IDT IRQ1 (PS/2 KBD port interrupt) и IRQ12 (PS/2 AUX port interrupt) исключая код биоса. Хук IRQ1 предсказуемо срабатывает на клавиатурные события, а хук IRQ12 предсказуемо молчит на мышиные события. Затем включаем на контроллере сканирование AUX порта. Сразу после этого контроллер перестает триггерить <em>все</em> IRQ, нет событий ни от клавы ни от мыши. Все из реального режима.</p>

<p>Замена IRQ хендлеров в IDT исключает ring0 код биоса. Код включения сканирования порта крайне простой и работает на всех остальных конфигурациях. Остается только SMM код биоса (USB Legacy Support генерирует SMI) и аппаратную реализацию. __</p>

<p>Решить эту проблему нельзя, ее можно только обойти. Для этого нужно сначала отключить USB legacy support, а затем инициализировать PS/2 драйвера уже для настоящего контроллера. Отключение legacy support на EHCI происходит через машину состояний:</p>

<ol>
<li><p>В определенном регистре контроллера OS выставляет бит &quot;я хочу контроллер&quot;.</p></li>
<li><p>Срабатывает SMM прерывание в котором биос должен подготовить контроллер к передаче и сбросить другой бит &quot;биос отдал контроллер&quot;. Как только этот бит выставлен процесс передачи контроллера можно считать законченным.</p></li>
</ol>

<p>На этой машине сидят два EHCI контроллера. Один из них успешно прошел этот процесс, а второй отказывается сбрасывать бит владения биосом. При этом видно, что SMM прерывания с него перестали работать, т.е. биос его реально отдал. Эту проблему решил уже апдейт биоса :)</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2014/09/01/ida-pro-needs-a-reality-check/">
        IDA Pro needs a reality check
      </a>
    </h1>

    <time datetime="2014-09-01T23:06:37+07:00" class="post-date">01 Sep 2014</time>

    <p>На выходных решил вспомнить молодость и поиграть в <a href="http://eu.blizzard.com/ru-ru/games/d2/">diablo 2</a>. Купил, запустил и у меня чуть не вытек глаз от 800х600 на моем 16:9 мониторе. Нашел фанатский resolution патч, но он крашится. Решил поставить дизассемблер на игровой комп, чтобы разобраться (патч не опенсурсный). Оказалось, что hopper v3 более не поддерживает винду, поэтому я скачал бесплатную Иду. И тут у меня вытек второй глаз. Бесплатная ида почти неюзабельна и наверное она лучший мотиватор купить платную, если ты уже пользовался платной и знаешь насколько она лучше. Но платная ида совсем уж платная, в смысле нереально дорогая.</p>

<p>Поэтому я выгуглил медузу: <a href="https://github.com/wisk/medusa">https://github.com/wisk/medusa</a></p>

<p>Иде невыносимо нужен конкурент под винду, желательно опенсурсный, чтобы она стала ближе к реальности. Медуза полна шероховатостей, но я надеюсь начать ей пользоваться плотнее и контрибутить по мере возможности. В ней уже проделано очень много работы.  </p>

<p> </p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2014/06/11/for-loop-is-fine/">
        For loop is fine
      </a>
    </h1>

    <time datetime="2014-06-11T00:00:53+07:00" class="post-date">11 Jun 2014</time>

    <p>Часто приходится писать такой код:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">ProcessAll</span><span class="p">(</span><span class="kt">element_t</span><span class="o">*</span> <span class="n">elements</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">total</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">total</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ProcessElement</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>So far so good. Но затем нужно обычно написать еще нечто вроде:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">PrintAll</span><span class="p">(</span><span class="kt">element_t</span><span class="o">*</span> <span class="n">elements</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">total</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">total</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PrintElement</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>И тут срабатывает инстинкт &quot;где-то я это уже видел&quot;, и, вспоминая какой-нибудь SICP, хочется выделить итерацию отдельно и написать:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">ForEachElement</span><span class="p">(</span><span class="kt">element_t</span><span class="o">*</span> <span class="n">elements</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">total</span><span class="p">,</span> <span class="n">ElementCallbackFptr</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">total</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">callback</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">context</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>И начать переписывать ProcessAll и PrintAll через ForEachElement + callback собирая со стека весь контекст в context.
Такой код выглядит красиво, общее абстрагировано, частное параметризировано.</p>

<p>Но затем такой код нужно читать кому-то другому, обязательно под дедлайном с целью быстро найти и исправить баг. И тут у читающего начинаются проблемы:</p>

<ol>
<li><p>Итерация визуально отделена от обработки каждого элемента.
Callback отдельная функция, а не код внутри цикла и визуально он вынесен из скоупа цикла. Приходится прыгать по файлу с целью найти функцию обработки каждого элемента, помнить какая реализация callback соответствует какому из вызовов ForEachElement. Это не дает читающему видеть весь контекст алгоритма сразу, а держать в голове дополнительный контекст и вспоминать его заново каждый раз.</p></li>
<li><p>void* context в лучшем случае структура, специфичная для каждой реализации callback (в худшем абстрактный интерфейс).
В эту структуру как правило со стека рядом с вызовом ForEachElement упаковываются параметры. Читающему нужно помнить еще один контекст - какой параметр куда присвоен в структуре и чему соответствует на самом деле в реализации callback.</p></li>
<li><p>Порог вхождения в то как автор называет итерацию.
Цикл for в типичном виде парсится более-менее опытным кодером за один проход. Он не вчитывается в символы, не выясняет их значения, а сразу видит семантику - автор проходит по всем элементам. For это базовая конструкция языка понятная всем. В случае когда автор выделил итерацию отдельно появляется порог вхождения - как именно автор назвал свой аккуратно вырезанный for - ForEach, Enumerate, Walk? Можно сказать, что поняв это один раз можно уже не напрягаться в следующий, но ведь for понимать не надо и в самый первый раз и во все последующие. К тому же код редко читается как книга, в основном читается одна функция за раз с целью найти проблему. Если систему делают несколько авторов, каждый из которых делает свою итерацию, то за одним ForEach следует другой Enumerate уже от другого автора и порог вхождения начинает расти.</p></li>
</ol>

<p>В итоге абстрагировать простейший цикл for может и выглядит красиво при написании кода, но создает только проблемы тому, кто хочет разобраться что происходит.
Если итерация не простая? Я стараюсь в таком случае делать код &quot;максимально совместимым&quot; с for делая для своих элементов First(), Next() и End().</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2014/06/06/linux-on-efi-wo-reboot/">
        Possible solution to Linux on EFI w/o reboot
      </a>
    </h1>

    <time datetime="2014-06-06T11:26:19+07:00" class="post-date">06 Jun 2014</time>

    <p>Как можно реализовать линукс без перезагрузки на EFI:</p>

<ol>
<li><p>При передаче управления из EFI в Linux нужно проделать ряд операций:</p>

<ol>
<li>Позвать DisconnectController чтобы отключить все драйвера периферийных устройств (ввод/вывод, сеть, диск, USB)</li>
<li>Получить актуальную карту памяти EFI и сохранить как ее, так и саму память, занятую EFI. По возможности сдампить ее на диск</li>
<li>Отключить прерывания, сохранить адрес IDT фирмвари и настройки контроллера прерываний.</li>
<li>Сохранить весь контекст выполнения (сегменты, регистры, адрес стека, etc.), примерно тоже самое что и setjmp/makecontext</li>
</ol></li>
<li><p>Запустить ядро, юзермодный аппликейшен.</p></li>
<li><p>Позвать kexec чтобы выполнить код в защищенном режиме который:</p>

<ol>
<li>Восстанавливает карту памяти и память фирмвари сохраненную в пункте 1.b.</li>
<li>Восстановить IDT фирмвари и настройки контроллера прерываний сохраненные в пункте 1.c.</li>
<li>Восстановить контекст выполнения из пункта 1.d. (по сути сделать longjmp/setcontext), включить прерывания.</li>
<li>Позвать ConnectController для подключения драйверов к периферийным устройствам.</li>
</ol></li>
</ol>

<p>Суть подхода в том, чтобы рассматривать контекст выполнения фирмвари как выгружаемую задачу, сохранить и выгрузить ее, а затем восстановить обратно. Теоретически можно даже модифицировать планировщик задач ядра так чтобы он часть грязной работы сделал сам. DisconnectController / ConnectController в теории позволяет решить проблему с состоянием железа после возврата из ядра, т.к. ConnectController должен заново запустить инициализацию драйверов фирмвари, которые должны привести свои девайсы в известное состояние.</p>

<p>Весь подход держится на поведении ConnectController и драйверов фирмвари. Если они не следуют EFI Driver Binding модели, что теоретически возможно, то переинициализация устройств будет затруднительной. Как показала практика, в реальности опасно опираться на соответствие фирмвари чему-то из советов UEFI спецификации.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2014/04/25/d0bfd0bed187d0b5d0bcd183-c-d0b2-d18fd0b4d180d0b0d185-d18dd182d0be-d0bfd0bbd0bed185d0be/">
        Почему C++ в ядрах это плохо
      </a>
    </h1>

    <time datetime="2014-04-25T22:19:43+07:00" class="post-date">25 Apr 2014</time>

    <p>Вот занимательные высказывания торвальдса насчет C++: <a href="http://harmful.cat-v.org/software/c++/linus">http://harmful.cat-v.org/software/c++/linus</a>. Я как и все люблю почитать их и поржать, но не так давно я понял что он прав.</p>

<p>В низкоуровневых проектах, типа ядер ОС, прошивок, пребутов и т.д. C++ это действительно опасный выбор если подойти со стороны отладки. В таких окружениях часто лучшее на что можно надеяться это дизассемблер. В таком случае, уставившись в голые инструкции, очень полезно понимать что третья по счету инструкция call это скорее всего третий по счету вызов функции в исходнике или суметь найти на стеке нужную локальную переменную. Чтобы этого достичь нужно чтобы high level language был настолько предсказуемо транслируем в ассемблер насколько это возможно при учете оптимизирующих компиляторов.</p>

<p>C++ во все поля с виртуальными функциями, шаблонами, конструкторами, операторами, перегрузками, контейнерами и развесистыми объектами порождает громадное количество невидимых вызовов, стековых аллокаций, символов, inderect call-ов, pointer chasing-а и прочей радости. В результате понять где же происходит тот самый вызов функции или где на стеке находится нужная переменная становится сильно сложнее, на порядок. Достаточно посмотреть что порождает BOOST_SCOPE_EXIT и потерять надежду отладить что-нибудь дизассемблером навсегда. Писать на плюсах можно продуктивнее и надежнее чем на Си например, но такая выгода потом оборачивается потерянными днями проведенными за (безуспешной) отладкой дампов.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2014/03/17/efi-toolkit/">
        EFI toolkit
      </a>
    </h1>

    <time datetime="2014-03-17T13:32:17+07:00" class="post-date">17 Mar 2014</time>

    <p>До того как Intel открыл TianoCore и вокруг него развился EDK был EFI toolkit:
<a href="http://sourceforge.net/p/efi-toolkit/code/HEAD/tree/trunk/efi-toolkit/">http://sourceforge.net/p/efi-toolkit/code/HEAD/tree/trunk/efi-toolkit/</a></p>

<p>Гораздо более легковесный проект чем EDK, содержит EFI спеку в хедерах, порты libc, libm, libsocket, libz, реализацию TCP/IP стека и тонкую convinience wrapper library в виде libefi. Причем порт libc, в отличии от EDK, зависим только от спеки и libefi. В общем то что мне и нужно было всегда, но есть минусы:</p>

<ol>
<li><p>С появлением EDK на проект забили, последние коммиты датируются концом 2006 года. Версия спецификации в хедерах 1.3.что-то.</p></li>
<li><p>Нет GNU мейкфайлов, только nmake.</p></li>
</ol>

<p>Я сделал себе бранч: <a href="https://github.com/warfish/uefi-toolkit">https://github.com/warfish/uefi-toolkit
</a>Пока планирую сделать сборку под юниксы, стряхнуть пыль и обновить хедера до UEFI spec 2.4.</p>

    
    <span class="tags">
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    </div>

    <div class="pagination">
      
      <a class="pagination-item older" href="/page2">Older</a>
      
      
      <span class="pagination-item newer">Newer</span>
      
    </div>

  </div>
      
  <div class="sidebar">
    <ul class="post-list">
      
      <!-- a style="font-size: 182%" href="/BIOS/">BIOS</a -->
      <li><a href="/BIOS/">BIOS</a></li>
      
      <!-- a style="font-size: 107%" href="/device state/">device state</a -->
      <li><a href="/device state/">device state</a></li>
      
      <!-- a style="font-size: 245%" href="/preboot/">preboot</a -->
      <li><a href="/preboot/">preboot</a></li>
      
      <!-- a style="font-size: 295%" href="/UEFI/">UEFI</a -->
      <li><a href="/UEFI/">UEFI</a></li>
      
      <!-- a style="font-size: 107%" href="/crypto/">crypto</a -->
      <li><a href="/crypto/">crypto</a></li>
      
      <!-- a style="font-size: 195%" href="/doom-uefi/">doom-uefi</a -->
      <li><a href="/doom-uefi/">doom-uefi</a></li>
      
      <!-- a style="font-size: 82%" href="/github/">github</a -->
      <li><a href="/github/">github</a></li>
      
      <!-- a style="font-size: 82%" href="/hardware/">hardware</a -->
      <li><a href="/hardware/">hardware</a></li>
      
    </ul>
  </div>

</div>



      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2015-01-31T16:39:32+06:00">2015</time>. All rights reserved.
        </small>
      </footer>

    </div>

  </body>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-59069328-1', 'auto');
            ga('send', 'pageview');

            </script>

</html>
