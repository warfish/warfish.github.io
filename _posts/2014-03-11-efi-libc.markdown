---
author: wrfsh
comments: true
date: 2014-03-11 16:40:20+00:00
layout: post
slug: efi-libc
title: EFI libc
wordpress_id: 376
tags:
- UEFI
---

EDK преследует архитектуру library classes, которая позволяет им обернуть самый безобидный интерфейс, типа ASSERT, в полиморфную библиотеку у которой есть один интерфейс и много реализаций. Конкретная "инстанциация" этого полиморфного интерфейса задается в их билд системе через DSC файл. Реализация C99 stdlib, [EDK/StdLib](http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/), которую они взяли из Open/Net/Free BSD и жестко мутировали, работает также. Например memcmp у них [реализована](http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/LibC/String/Comparison.c#l29) через BaseMemoryLib/CompareMem. Такая архитектура позволяет им задавать реализации библиотек для разных этапов загрузки системы (Pei, Dxe, Bbs, Runtime) и местами кажется очень мощной. Но не понятно зачем она нужна в stdlib если они ограничили линковку своей реализации только до EFI_APPLICATION, т.е. только до стадии boot loader-а. Если по-другому, то в результате из реализацию нельзя линковать с EFI драйвером например, хотя бы ради того же memcmp.

Еще один неприятный момент в их реализации - она зависит от EFI shell. В реализации stdio у них скорее всего встал вопрос, как интерпретировать файловые пути где-нибудь в fopen? Ответ такой - через шелл. Их реализация реализует (sic) NetBSD сисколлы через "драйвера устройств", которые показывают на [маппинги файловых систем в шелле](http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/LibC/Uefi/Devices/UefiShell/daShell.c). В результате проблема решена, но появляется жесткая зависимость от шелла. Эта зависимость явно отражена в [реализации точки входа](http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/LibC/Main/Main.c#l131). Также шелл позволяет им ввести понятие аргументов командной строки.

Есть еще россыпь проблем поменьше: типа неготовность их хедеров к компиляции в плюсовом юните трансляции, переопределение флагов компиляции в inf файле, реализация realloc которая [опирается](http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/LibC/StdLib/Malloc.c#l40) на их же собственные приватные структуры кучи из реализации DxeCore, что делает опасным ее использование на реальном железе где куча реализована иначе. Ну и как и все остальное в EDK она непредназначена для линковки с проектами вне дерева EDK.

Все это заставляет задуматься, а зачем? Возьмем например memcmp. Нужно было _выкинуть_ реализацию чтобы заменить ее своей, через полиморфную либу. Можно было опереться на EFI_SIMPLE_FILE_SYSTEM в реализации fopen приняв например схему с эмуляцией дерева фс через гуиды разделов (/Volume{GUID}/...). Можно было заинвертировать зависимость опубликовав свой кастомный протокол, EDK_LIBC_ARGS например, инстанс которого клиент бы вешал на хендл слинкованного с StdLib приложения. Тоже самое можно было бы сделать и с stdio тоже. Под эту схему и шелл бы подошел. But alas.

И вот конструктивная часть поста. Мне интересно насколько трудоемкий вариант выдернуть реализацию StdLib из EDK и сделать ее зависимой только от UEFI spec. Может быть было бы проще начать с нуля, т.е. с BSD libc и портировать ее. Не знаю, но что-то сделать руки чешутся.
