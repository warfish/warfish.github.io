---
author: wrfsh
comments: true
date: 2013-05-17 15:04:12+00:00
layout: post
slug: uefi-capabilities-and-strategy
title: UEFI capabilities and strategy
wordpress_id: 57
tags:
- BIOS
- preboot
- UEFI
---

Что может UEFI:



	
  1. Сетевые драйвера, дисковые драйвера, USB, драйвера графической консоли.

	
  2. UefiToolkit предоставляет прикладную поддержку сетевых проколов (IP, UDP, TFTP, DHCP, TCP), input form UI, unicode, реализацию stdlib и другой прикладной код. Реализован поверх интерфейсов устройств из пункта 1.

	
  3. Работа в защищенном режиме с пейджингом в плане защиты памяти

	
  4. PE/COFF бинарники, которые можно тестировать в пользовательском режиме.


Т.е. для реализации MBO нам нужны "только" драйвера токенов. К сожалению, кроме UEFI систем есть еще и legacy BIOS cистемы, и их достаточно много. На этих системах нет почти ничего из описанных интерфейсов, кроме дисков и сырой видео памяти.

Итого мы получаем две платформы: legacy BIOS и UEFI. С точки зрения удобства разработки нам нужна одна платформа, чтобы уменьшить набор тестовых конфигураций и максимально повысить переиспользование кода. Для этого нам нужна платформа, которая выравнивает обе предыдущие. При этом, если ставить во главу угла пользовательский экспириенс, то мы должны обеспечить быструю загрузку PBA и прозрачное продолжение загрузки машины после прохождения PBA.

На UEFI системах мы _пока_ не представляем как обеспечить прозрачное продолжение загрузки кроме как написать нативное UEFI приложение. Попытки выполнить это на BIOS-e пока приводят к смешанным результатам. Поэтому рождается такой вариант:

	
  * Использовать в качестве общей платформы UEFI, в плане спецификации его API.

	
  * В качестве реализации платформы на UEFI системах использовать саму прошивку


Что делать с legacy BIOS системами? Реализовать требуемый набор UEFI интерфейсов поверх слепленного комка из самого биоса, [iPXE](http://ipxe.org/) для поддержки сети и barebones USB (из состава coreboot) для поддержки USB стека.

Таким образом клиентский код PBA написан против UEFI API, вот только на BIOS мы реализуем этот API сами.

Плюсы такого подхода:



	
  * Одна платформа, переиспользование кода

	
  * Нативное UEFI приложение на UEFI системах работает максимально быстро, обеспечивает прозрачную перезагрузку из коробки.

	
  * На BIOS системах можно использовать прикладной код из UEFI toolkit, потому как наша реализация предоставляет необходимые интерфейсы устройств. Это значит что мы получаем прикладной код сетевых протоколов, UI и stdlib.

	
  * Никаких проблем с состоянием аппаратуры на обоих платформах.

	
  * Возможность развернуть инфраструктуру разработки, отладки и автоматической сборки на одной платформе с остальным кодом решения (проще говоря, собирать все на винде и не тянуть линукс).

	
  * Возможность распараллелить разработку. Один девелопер портирует текущий код и пишет новый для UEFI, второй девелопер наращивает Legacy BIOS до нужного подмножества реализации UEFI API


Минусы:

	
  * Драйвера токенов.

	
  * Обеспечивается поддержка только той аппаратуры что нужна именно на ближайший период, не хватает задела на будущее, особенно для экзотических вещей типа сканеров отпечатков пальцев.

	
  * Нехилая задача по реализации подмножества UEFI спецификации. Однако есть подспорье в виде [DuetPkg](http://sourceforge.net/apps/mediawiki/tianocore/index.php?title=DuetPkg) и [Clover](http://sourceforge.net/projects/cloverefiboot/)


Если ссумировать сказанное, то на мой взгляд нам так или иначе придется писать нативный UEFI код на UEFI системах, если мы хотим работать без перезагрузки. А если нам придется это делать, то мы в своем роде ограничены сверху именно UEFI. Поэтому почему бы не провести водораздел зависимости нашего кода именно на уровне спецификации UEFI API и доделать то, чего не хватает на legacy BIOS с помощью сторонних библиотек.

Вопрос, что делать с токенами? Ответ: портировать линуксовую юзер модную реализацию libopensc на USB стек пребута.
