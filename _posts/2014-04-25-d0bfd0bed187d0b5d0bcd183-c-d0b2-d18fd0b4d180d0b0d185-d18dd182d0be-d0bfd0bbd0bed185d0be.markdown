---
author: wrfsh
comments: true
date: 2014-04-25 15:19:43+00:00
layout: post
slug: '%d0%bf%d0%be%d1%87%d0%b5%d0%bc%d1%83-c-%d0%b2-%d1%8f%d0%b4%d1%80%d0%b0%d1%85-%d1%8d%d1%82%d0%be-%d0%bf%d0%bb%d0%be%d1%85%d0%be'
title: Почему C++ в ядрах это плохо
wordpress_id: 389
---

Вот занимательные высказывания торвальдса насчет C++: [http://harmful.cat-v.org/software/c++/linus](http://harmful.cat-v.org/software/c++/linus). Я как и все люблю почитать их и поржать, но не так давно я понял что он прав.

В низкоуровневых проектах, типа ядер ОС, прошивок, пребутов и т.д. C++ это действительно опасный выбор если подойти со стороны отладки. В таких окружениях часто лучшее на что можно надеяться это дизассемблер. В таком случае, уставившись в голые инструкции, очень полезно понимать что третья по счету инструкция call это скорее всего третий по счету вызов функции в исходнике или суметь найти на стеке нужную локальную переменную. Чтобы этого достичь нужно чтобы high level language был настолько предсказуемо транслируем в ассемблер насколько это возможно при учете оптимизирующих компиляторов.

C++ во все поля с виртуальными функциями, шаблонами, конструкторами, операторами, перегрузками, контейнерами и развесистыми объектами порождает громадное количество невидимых вызовов, стековых аллокаций, символов, inderect call-ов, pointer chasing-а и прочей радости. В результате понять где же происходит тот самый вызов функции или где на стеке находится нужная переменная становится сильно сложнее, на порядок. Достаточно посмотреть что порождает BOOST_SCOPE_EXIT и потерять надежду отладить что-нибудь дизассемблером навсегда. Писать на плюсах можно продуктивнее и надежнее чем на Си например, но такая выгода потом оборачивается потерянными днями проведенными за (безуспешной) отладкой дампов.


