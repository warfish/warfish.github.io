---
author: wrfsh
comments: true
date: 2014-09-27 06:03:16+00:00
layout: post
slug: exit-interview
title: Exit interview
wordpress_id: 408
published: false
---

Спустя 2-3 месяца после того, как я устроился в ЛК у нас началась подготовка к релизу и на меня свалился первый пребутовый баг - после ввода логина и пароля машина зависает на черном экране. Пребут тогда был не чита нонешнему - риал модный MZ бинарник, который еле-еле но влезал в отведенные ~500KB. Дебаггера и эмулятора не было, даже простого дизассемблера в GDB, а единственный способ отладки это печать в ком порт и на экран. И тут я запаниковал. До этого я работал с ядрами линукса и мака, но там была нормальная отладка. А тут, как же так, я понятия не имею как этот код работает, до сих пор немного плаваю в том, что такое сегментированный указатель, не могу ставить брейкпоинты, а когда я вставляю отладочную печать, то эффект пропадает. Я не знаю что делать дальше, никто не знает что делать дальше, а мне испытательный надо закрывать.

На следующий день паника немного поутихла и я решил попробовать единственное, что мог на тот момент - открыть бинарь в дизассемблере. Я мало что понимал в дизассемблере тогда, но спустя еще пару дней мне повезло и я заметил что в бинарнике есть референсы за пределы его образа, около 8 байт сразу после конца. Еще день на то чтобы поверить, что "баги в компиляторе это возможно" и оказалось что виноват был код вида:


<blockquote>`void func()
{
static something_t* ptr = get_something();
ptr->do_stuff();
}
`</blockquote>


Как оказалось MSVC 1.52 на каждый local static выделяет скрытый int - флажок что инициализация была пройдена. Этот флажок он помещает в BSS секцию, но линкер, при сборке COM файла, не аллоцирует в бинарнике память под BSS секцию, а т.к. у COM нет никакого формата и хедера, то и записать размер BSS некуда. BSS секция просто адресовалась сразу после конца файла и никто об этом нигде не сказал, кроме опционального MAP файла. Компилятор генерировал код вида:


<blockquote>`if(ptr_initialized_flag_in_bss != 1)
{
ptr = get_something();
}
`</blockquote>


Флажок находился за пределами бинаря, т.е. в неинициализированной памяти. При одном адресе загрузки / размере бинарника флажок попадал на нули, а при другом не на нули и инициализация ptr не происходила. Это объясняло пропадание эффекта при добавлении отладочной печати - флажок перемещался на память, где чисто случайно были нули.

Моей радости не было передела, мне казалось, что я решил самый сложный в своей жизни баг и что ничего хуже со мной уже не будет никогда. В ретроспективе этот баг на самом деле достаточно простой, а следом за ним были вещи типа ошибок кодогенерации MSVC 1.52, отладки патчеванием уже собранного бинаря вставкой туда инструкций, генерирующих бипы PC спикера на живой железной машине, неработающий memcpy, дедлоки в PCI драйверах, реализация ECDH за 3 дня, неработающие биосы и много других разрывов мозга.

Это то что я запомню надолго, но еще я запомню как вся команда сидела в окопах по субботам, когда на каждую закрытую проблему возникало две новых, какие все были злые и раздражительные спустя месяц таких овертаймов, как люто закрученный мат шел со стороны каждого рабочего места, но никто ни разу не сказал "это не моя проблема". Работать над этими проблемами с этими людьми было настоящим удовольствием, а теперь мне нужны другие проблемы, но людей будет не хватать :)
