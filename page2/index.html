<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      My worklog &middot; My worklog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.png">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="My worklog" href="/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h2 class="masthead-title">
          <a href="/" title="Home">My worklog</a>
          <small><a href="https://github.com/warfish">GitHub</a></small>
          <small><a href="/archive/">Archive</a></small>
          <small><a href="/tags/">Tags</a></small>
        </h3>
      </header>

      <main>
        <div class="wrapper">
  <div class="center">

    <div class="posts">
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2014/01/01/career-suicide/">
        Career suicide
      </a>
    </h1>

    <time datetime="2014-01-01T15:56:22+07:00" class="post-date">01 Jan 2014</time>

    <p>Я стараюсь держать этот блог строго техническим, а не личным, но раз в год можно.</p>

<p>Я научился проходить собеседования на С++ девелопера до того как научился программировать на нем. :) Это очень просто. С++ такой язык, что можно долго радовать собеседников деталями реализации виртуальных функций, лейаутом объектов в памяти, отличием ++i от i++ и тому подобной мишурой, которая хотя и полезна, но вовсе не подразумевает способности собеседуемого решать на этом языке задачи, т.е. <em>программировать</em>. И это не было каким-то хитрым планом, попыткой обмануть - я искренне считал что этого достаточно.</p>

<p>До того как научится проходить собеседования на С++ девелопера я умел хорошо кодить на ANSI C. Это тоже было очень далеко от инжиниринга и дизайна чего-то большого, развесистого и требующего планирования. Почему от кодинга на сях я перешел в детали работы виртуальных функций, а не в инжиниринг? Я пытался, но от книг типа <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">design patterns</a>, <a href="http://www.amazon.com/Object-Oriented-Software-Construction-Book-CD-ROM/dp/0136291554">OOSC</a> и <a href="http://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871">SICP</a> я засыпал через каждые 20 страниц, хотя домучил все три. <a href="http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670">Code complete</a> и <a href="http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844">Алгоритмы</a> были интереснее, но по-настоящему интересными книгами того времени для меня были <a href="http://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298">Expert C</a>, <a href="http://www.amazon.com/Understanding-Linux-Kernel-Third-Edition/dp/0596005652">LK</a> и <a href="http://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468">LKD</a> (к слову я смотрю на GNU-манифест и прочую романтику как на ребячество, а в худшем случае как на рак мозга).</p>

<p>Теперь, когда я пытаюсь делать дизайн крупной фичи, декомпозировать ее и высосать из пальца объекты, то мозг скрипит и сопротивляется. В итоге получается в основном хорошо, но очень болезненно. Приятная, интересная и в результате более продуктивная и результативная работа для меня выглядит примерно так: у меня есть черный ящик, который что-то делает, не понятно что. Возможно понятно что он делает, но он запутан деталями. Мне нужно разобраться как с ним работать и абстрагировать его за простым API, который состоит из нескольких простых функций и структур данных. Я чувствую большое удовлетворение от такой работы: от процесса исследования ящика и от дизайна API, который, самое главное, сильно упрощает кому-то жизнь. Ящиком может быть железка, какой-то системный алгоритм вроде DMA или виртуальной памяти. Ящиком может быть какое-нибудь красно-черное дерево. Ящиком может быть непонятный баг. Так или иначе в таком направлении мозг не скрипит, а легко скользит.</p>

<p>Все это хорошо, знать свои сильные и слабые стороны хорошо, но еще я хочу карьеру, а карьера подразумевает повышение уровня ответственности, который, как правило влечет за собой повышение уровня абстракции. И тут мне кажется, что это идет вразрез с тем что я умею хорошо и с тем, что не очень. Я конечно могу в итоге дойти до уровня чувака, который знает всю системную канализацию настолько хорошо, что может по фотографии электромагнитного излучения выполняемого кода угадать что не так и снять порчу, но это все сказки, потому что такие обычно живут в горах, требуют задавать им не больше трех вопросов в день и отрешаются от всего мирского. На самом деле в реальности они живут скорее в подвале у мамы, чем в горах, но остальное верно.</p>

<p>Речь не идет о &quot;нравится - не нравится&quot;, нет в моей работе сейчас ничего, что я заставлял бы себя делать насильно, за мелкими исключениями. Если исходить из прагматических соображений, то все просто: у меня хорошо получается одно и не очень хорошо получается второе, но именно второе видится как основное, в чем нужно быть успешным, чтобы карьерно расти.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/12/23/d18dd0bcd183d0bbd18fd186d0b8d18f-efi-d0bdd0b0-win32/">
        Эмуляция EFI на Win32
      </a>
    </h1>

    <time datetime="2013-12-23T22:31:28+07:00" class="post-date">23 Dec 2013</time>

    <p>В целях тестирования и облегчения отладки у нас есть эмулятор нашего &quot;пребута&quot; на win32. Эмулятор эмулирует некоторую нашу абстракцию платформы, которая на EFI реализована поверх EFI, а на биосе поверх эмуляции EFI :)</p>

<p>Мне кажется, что подход с эмуляцией этого слоя начинает загонять нас в угол в некоторых местах. Все было хорошо пока эмуляция касалась только клавиатур и дисплеев. Как только возникла тема с поддержкой USB и родных EFI драйверов от вендоров определенного типа устройств (роскошь от которой мы не можем отказаться), то стал появлятся паттерн: есть простой и понятный подход это поддержать, но он режется из-за эмуляции. Мне кажется что таким образом мы начинаем терять одно из самых сильных преимуществ нашего подхода - начиная с определенного уровня у нас везде EFI. Это преимущество позволяет нам фактически <strong>удваивать</strong> производительность, потому что мы пишем один EFI бинарник, а покрываем им сразу две платформы.</p>

<p>Поэтому мне кажется нам нужно эмулировать EFI на win32. :) При этом нужно сохранить основное практическое преимущество эмуляции - отладка PBA студийным компилятором.</p>

<p>*<em>Как это сделать. *</em></p>

<p>В EDK есть проект - <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/Nt32Pkg/">Nt32Pkg</a>. Это софтверный эмулятор EFI окружения. Он не эмулирует PC/AT - в этом его отличие от QEmu с прошивкой. Он компилируется в exe-шник и реализует эмуляцию EFI поверх win32 сервисов. Т.е. грубо говоря аллокация памяти реализована через HeapAlloc, загрузка драйверов через LoadLibraryEx. Драйвер блочного устройства может либо транслировать реальный диск либо эмулировать его на файле. GOP и клавиатурный ввод идут непосредственно через GDI контекст окна приложения. При этом екзешник и драйвера он грузит через LoadLibraryEx, значит, <em>вроде бы</em> его можно отлаживать. Чего в нем не хватает:</p>

<ol>
<li><p>Он не эмулирует USB и не протаскивает хостовые USB девайсы. Для поддержки токенов его придется этому учить, например через <a href="http://en.wikipedia.org/wiki/WinUSB">WinUSB</a>.</p></li>
<li><p>Он не знает про наши образы дисков, которые у нас широко начали применятся. Нужно делать BlockIo луп-девайс на наш образ диска, что в общем-то может пригодится не только в эмуляции.</p></li>
</ol>

<p>Концепция работы с таким эмулятором такая, что мы запускаем на нем весь наш и EFI и эмулируемый Win32 код, т.е. ядро и PBA. Моки ядра придется делать эээ другим ядром. И мне кажется, что все это к лучшему:</p>

<ol>
<li><p>Мы таким образом приходим к одной единственной реализации ядра на все три платформы - на EFI. Т.е. теперь один бинарник кроет не две а три платформы.</p></li>
<li><p>Так как на эмуляции запускается тот же код ядра, что и в пребуте, то это позволяет нам больше тестировать наш продакшен-кейс.</p></li>
<li><p>Моки, как я сказал, делаются честной EFI реализацией. Ну или подгружаемой DLL. Так или иначе моки можно, в принципе, запускать не только на эмуляторе. Возможно тут есть профит.</p></li>
<li><p>EDK планируют объединение двух своих эмуляторов (<a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/Nt32Pkg/">Nt32Pkg </a>и <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/UnixPkg/">UnixPkg</a>) в одну платформу - <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/EmulatorPkg/">EmulatorPkg</a>. Что сделает нашу эмуляцию кроссплатформенной на винде и линуксе.</p></li>
</ol>

<p>Конечно это не бесплатно. Но альтернатива мне видится такой, что и ядро и эмуляция начнут обрастать ненужными абстракциями в целях поддержать один и тот же код PBA, а преимущество единой платформы, позволяющее нам сейчас запускать одни бинари на двух платформах и сильно сокращающее нам выход в релиз, начнет буксовать.</p>

<p><strong>А что с PBE API.</strong></p>

<p>Возникает резонный вопрос - если везде EFI, то зачем вообще нужен текущий слой абстракции, который и эмулируется сейчас на Win32 - PBE API.</p>

<p>На мой взгляд PBE API выполняет важную роль - позволяет pba.dll быть полностью юзермодной дллкой без знания про EFI. Это делает PBA более самодостаточным, имеет больш<strong>и</strong>е преимущества для его сборки и отладки. Тем не менее я думаю, что PBE API должен в дальнейшем развиваться в сторону <a href="http://wrfsh.wordpress.com/2013/12/07/preboot-win32-process-vm/">win32 process VM</a>. В идеале я вижу себе такую картину: в качестве низкоуровневой платформы везде EFI, а pba.dll зависит только от Win32 API в виде kernel32.dll и т.п. Я думаю что это не практично в таком абсолюте, например несколько функций кастомного фреймбуфера PBE на порядок проще и удобнее чем gdi32.dll. Но я думаю что лучше стремится к win32 там где это оправдано практически.</p>

    
    <span class="tags">
      
      <a href="/preboot/">preboot</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/12/14/d0b2d0bdd0b5d0b7d0b0d0bfd0bdd0be-d0bed181d0bed0b7d0bdd0b0d0bdd0b8d0b5/">
        Внезапно осознание
      </a>
    </h1>

    <time datetime="2013-12-14T02:35:19+07:00" class="post-date">14 Dec 2013</time>

    <p>Как так получилось, что год назад PBA был 16-ти битным приложением, которое еле влезало в ~600kb риалмодной памяти, которое нужно было отлаживать дизассемблером дампов и принтфами в ком порт, а теперь это (почти) обычное юзермодное Qt приложение с поддержкой плюсов, STL, boost, которое можно писать и отлаживать под виндой и которое весит 12 метров не считая кучу, которую еще никто даже не считал, но работает в пребуте:</p>

<p><a href="/public/images//w7x64-2013-12-12-12-37-4611.png"><img src="/public/images/w7x64-2013-12-12-12-37-4611.png" alt="w7x64-2013-12-12-12-37-461"></a></p>

<p>Что-то кажется мы хорошо поработали в этом году.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/12/07/preboot-win32-process-vm/">
        Preboot Win32 process VM
      </a>
    </h1>

    <time datetime="2013-12-07T13:08:59+07:00" class="post-date">07 Dec 2013</time>

    <p><a href="http://en.wikipedia.org/wiki/Virtual_machine">http://en.wikipedia.org/wiki/Virtual_machine</a>:</p>

<blockquote>A process VM, sometimes called an _application virtual machine_, or _Managed Runtime Environment_ (MRE), runs as a normal application inside a host OS and supports a single process. It is created when that process is started and destroyed when it exits. Its purpose is to provide a [platform](http://en.wikipedia.org/wiki/System_platform)-independent programming environment that abstracts away details of the underlying hardware or operating system, and allows a program to execute in the same way on any platform.</blockquote>

<p>Process VM эмулирует окружение для иденственного процесса. Эмуляция заключается в основном в реализации ABI платформы и стоящего за ним рантайма. Под ABI в данном случае подразумеваются как правило механизм и реализация подобия системных вызовов платформы. Если хостовая <a href="http://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA</a> отличается от той, для которой собран таргет, то тогда эмуляция включает в себя и бинарную трансляцию target ISA - host ISA. Референсной реализацией считается <a href="http://en.wikipedia.org/wiki/FX%2132">FX!32</a></p>

<p>Если ближе к пребуту, то скоуп такой: на входе имеем win32 PE/PE+ dll однопоточный модуль, который слинкован с родным MS CRT и тянет ряд платформенных ABI зависимостей, как правило в форме импортов kernel32 / ntdll. ISA таргета и хоста совпадают. Помимо загрузки, релокации и разрешения импортов PE laundry list полноценной реализации окружения и ABI примерно такой:</p>

<ul>
<li><p>Куча процесса (kernel32!HeapXXX). Как показала практика тут полезна отдельная куча чтобы не лезть в приватные структуры данных хостовой кучи и иметь возможность отделить аллокации таргета от хоста и трассировать их для отладки.</p></li>
<li><p>Контейнер виртуальной файловой системы процесса для подгрузки модулей по имени, загрузки UI ресурсов, etc.</p></li>
<li><p>TLS, FLS, переменные окружения, настройки кодовой страницы для конвертации строк, - все в контексте таргета.</p></li>
<li><p>Манагмент дополнительных загружаемых библиотек таргета(kernel32!LoadLibrary).</p></li>
<li><p>Динамическое связывание с импортами вызова VM монитора, если процесс знает о его существовании. В нашем случае знает и должен знать во избежании импортов GDI для рисования UI.</p></li>
<li><p>Реализация второстепенных системных вызовов типа записи на консоль, остановки процесса и т.п.</p></li>
</ul>

<p>При переходе от однопоточного к многопоточному таргету появляется CreateThread и примитивы синхронизации, и все это возможно реализовать, правда гораздо дороже чем все описанное выше.</p>

<p>Однако до CreateThread существует другой &quot;Nice to have&quot; - поддержка таргетов, состоящий из нескольких модулей. Например поддержка таргета, который линкуется с Qt динамически, а не статически. Проблема с такими таргетами в том, что в отличии от импортов, являющихся часть эмулируемого ABI, VMM ничего не знает о qt.dll и должен опираться на какую-то абстракцию файловой системы для их загрузки и связывания.</p>

<p>Общий поинт в том, что рассматривая пребут на определенном уровне как win32 process VM можно получить четкую модель реализации, которая сама по себе является портируемой на другие реализации пребута (в частности Win32 эмуляцию).</p>

    
    <span class="tags">
      
      <a href="/preboot/">preboot</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/11/13/d0bed0bed0bf/">
        ООП
      </a>
    </h1>

    <time datetime="2013-11-13T22:21:47+07:00" class="post-date">13 Nov 2013</time>

    <p>Объектно ориентированное программирование - это методология разработки программного обеспечения и структурирования кода, которая ставит целью найти наиболее хитрожопый выход из ситуации, когда более простой, эффективный и понятный подход невозможен из-за религиозных убеждений, острой паранойи и авторитетного мнения.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/10/27/exokernels/">
        Exokernels
      </a>
    </h1>

    <time datetime="2013-10-27T12:41:31+07:00" class="post-date">27 Oct 2013</time>

    <p>Оригинальная концепция: <a href="http://u.cs.biu.ac.il/%7Ewiseman/2os/microkernels/exokernel.pdf">http://u.cs.biu.ac.il/~wiseman/2os/microkernels/exokernel.pdf</a></p>

<p>Если коротко, то exo-ядра это крайне минималистичный подход. Концепция перпендикулярна микро или монолитным ядрам. Экзоядро реализует гораздо меньше абстракций чем обычно и дает очень много прямого доступа к &quot;близким к аппаратным&quot; ресурсам (таблицы страниц, дисковые сектора, кеши, etc.). Например экзоядра не реализуют абстракцию файловой системы. Юзерленд реализует ее сам, если нужно (обычно с помощью т.н. libOS). Если не нужно, то работает прямо с диском. Ядро все еще контролирует доступ и мультиплексит эти ресурсы, просто речь о гораздо более низкоуровневом доступе и контроле за этим доступом.</p>

<p>В пейпере есть раздел 5.4.2 The Cheetah HTTP/1.0 Server, который описывает реализацию агрессивно оптимизированного веб сервера на экзоядре.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/10/19/d0b4d180d0b0d0b9d0b2d0b5d180d0b0-etoken-d0bdd0b0-windows/">
        Драйвера eToken на Windows
      </a>
    </h1>

    <time datetime="2013-10-19T18:49:35+07:00" class="post-date">19 Oct 2013</time>

    <p>Я немного посмотрел устройство всего стека eToken на винде и вот что получилось:</p>

<ol>
<li><p>Центральный модуль в их архитектуре это <strong>Windows\system32\eToken.dll</strong>. Этот модуль экспортирует наружу реализацию pkcs#11. Неясно насколько много в нем реализации pkcs#11, но кода много.</p></li>
<li><p>Сам eToken.dll требует ряд импортов, в основном стандартные kernel32.dll, user32.dll, etc. Еще ему нужен winscard.dll, импорты которого регулярно просвечиваются по дереву вызовов pkcs#11 реализации.</p></li>
<li><p>В комплекте идут 2 драйвера:</p></li>
</ol>
<div class="highlight"><pre><code class="language-text" data-lang="text">* aksup.sys - класс USB. В inf файле замечены VendorID/DeviceID алладиновских устройств


* aksifdh.sys - класс SmartCardReader. Подозреваю что это плагин winscard API для интерфейса ридера. Зависит от первого драйвера.
</code></pre></div>
<p>Итого складывается такая картина. Ядреное присутствие eToken ограничивается USB устройством и плагином для winscard, а то что я подозреваю реализацией pkcs#11 - eToken.dll - опирается на winscard.dll.</p>

<p>Отсюда идеи. Предположим, что мы хотим использовать eToken.dll как есть в пребуте. Тогда нам нужны импорты для него. Есть шелуха типа kernel32.dll, user32.dll, которую, думаю, можно разрулить (что-то уже разрулено). И есть winscard.dll. Такой ли это громадный монстр? Оказывается нет : <a href="http://www.smartcard-magic.net/en/pc-sc-reader/winscard-api-c-c/">http://www.smartcard-magic.net/en/pc-sc-reader/winscard-api-c-c/</a>, <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa380142(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/aa380142(v=vs.85).aspx</a></p>

<p>Тут нужно небольшое пояснение. Токен это формфактор смарткарты, объединяющий ридер и карту. Есть интерфейс ридера, а есть интерфейс карты. Интерфейс ридера это winscard при поддержке драйверов etoken, которые, как мы уже знаем, общаются с Siemens CardOS внутри девайса. При этом протокол общения открыт и реализован в OpenCT. Поэтому в принципе winscard API можно реализовать используя драйвера из OpenCT / PCSC-lite / etc. Т.е. получается, <em>что нам не нужны закрытые бинарные драйвера ридера eToken.</em> У нас есть свои.</p>

<p>Реализация winscard API есть, например, у эппла: <a href="http://www.opensource.apple.com/source/SmartCardServices/SmartCardServices-34733/src/PCSC/winscard.c">http://www.opensource.apple.com/source/SmartCardServices/SmartCardServices-34733/src/PCSC/winscard.c</a>. Я думаю ее можно найти в реактосе. И скорее всего в RTOS-32: <a href="http://www.on-time.com/rtos-32.htm">http://www.on-time.com/rtos-32.htm</a>. Последнее правда за деньги, но я хочу немного на RTOS-32 остановится в этом контексте. Мы знаем, что у McAfee, который поддерживает токены, используется именно он в пребуте на биосе. Мы также знаем что у них недавно появилась поддержка EFI, где тоже есть токены. В таком разрезе кажется очень вероятным что они для поддержки токенов на EFI портировали какие-то куски из RTOS-32 и если там есть реализация winscard API, то я почти уверен что они портировали именно его.  Это можно выяснить наверняка, но главное то, что если я прав, то реализацию winscard можно <em>купить</em>.</p>

<p>Ок, с ридером разобрались. Интерфейс карты проприетарный с закрытыми форматами, где его взять? В eToken.dll, для которой мы уже разобрались с ридером через winscard :)</p>

<p>Такой подход сулит ряд бенефитов:</p>

<ul>
<li><p>Если все производители идут примерно таким же путем, то подход хорошо скалируется.</p></li>
<li><p>Конкретно по eToken - нам не нужны их драйвера, потому что мы сами реализуем winscard поверх тех драйверов ридеров, что есть в OpenCT / PCSC-lite.</p></li>
</ul>

<p>Мне не понятна трудоемкость и надежность такого решения. Мне не понятна легальная сторона - можем ли мы использовать чужие бинарные модули вот так? Но мне крайне интересно попробовать, потому что потенциально это сулит более менее легкую поддержку большого числа устройств.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/10/12/doom-uefi-alpha/">
        [DOOM-UEFI] Alpha
      </a>
    </h1>

    <time datetime="2013-10-12T21:40:07+07:00" class="post-date">12 Oct 2013</time>

    <p><a href="/public/images/screen-shot-2013-10-12-at-9-28-07-pm.png"><img src="/public/images/screen-shot-2013-10-12-at-9-28-07-pm.png" alt="Screen Shot 2013-10-12 at 9.28.07 PM"></a></p>

<p>Проблемы:</p>

<ul>
<li><p>Оказывается драйвер cirrus logic на OVMF дает только 8 бит реального цвета. Качество картинки в оригинале сильно лучше.</p></li>
<li><p>Мышки пока нет, но играть можно и без нее.</p></li>
<li><p>Обновление экрана тормозит, но есть идеи. Одна из них в том, что qemu софтверный эмулятор и я ничего не могу с этим поделать. Надо сравнить с досбоксом на такой же хостовой конфигурации. В противном случае придется оптимизировать.</p></li>
</ul>

    
    <span class="tags">
      
      <a href="/doom-uefi/">doom-uefi</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/10/10/doom-uefi-simple-linear-scaling-to-active-resolution/">
        [DOOM-UEFI] Simple linear scaling to active resolution
      </a>
    </h1>

    <time datetime="2013-10-10T23:36:58+07:00" class="post-date">10 Oct 2013</time>

    <p><a href="/public/images/screen-shot-2013-10-10-at-11-31-59-pm.png"><img src="/public/images/screen-shot-2013-10-10-at-11-31-59-pm.png" alt="Screen Shot 2013-10-10 at 11.31.59 PM"><a href="/public/images/screen-shot-2013-10-10-at-11-32-48-pm.png"><img src="/public/images/screen-shot-2013-10-10-at-11-32-48-pm.png" alt="Screen Shot 2013-10-10 at 11.32.48 PM"></a></a></p>

<p>Now, input processing.</p>

    
    <span class="tags">
      
      <a href="/doom-uefi/">doom-uefi</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/10/09/doom-uefi-title-screen/">
        [DOOM-UEFI] Title screen
      </a>
    </h1>

    <time datetime="2013-10-09T00:52:07+07:00" class="post-date">09 Oct 2013</time>

    <p>Yeah!</p>

<p><a href="/public/images//screen-shot-2013-10-09-at-12-48-46-am.png"><img src="/public/images/screen-shot-2013-10-09-at-12-48-46-am.png" alt="Screen Shot 2013-10-09 at 12.48.46 AM"></a></p>

<p>Original game res is 320x200. EFI is running in 800x600. On to scaling and input processing.</p>

    
    <span class="tags">
      
      <a href="/doom-uefi/">doom-uefi</a>
      
    </span>

    </article>
    
    </div>

    <div class="pagination">
      
      <a class="pagination-item older" href="/page3">Older</a>
      
      
      
      <a class="pagination-item newer" href="/">Newer</a>
      
      
    </div>

  </div>
      
  <div class="sidebar">
    <ul class="post-list">
      
      <!-- a style="font-size: 220%" href="/BIOS/">BIOS</a -->
      <li><a href="/BIOS/">BIOS</a></li>
      
      <!-- a style="font-size: 120%" href="/device state/">device state</a -->
      <li><a href="/device state/">device state</a></li>
      
      <!-- a style="font-size: 303%" href="/preboot/">preboot</a -->
      <li><a href="/preboot/">preboot</a></li>
      
      <!-- a style="font-size: 370%" href="/UEFI/">UEFI</a -->
      <li><a href="/UEFI/">UEFI</a></li>
      
      <!-- a style="font-size: 120%" href="/crypto/">crypto</a -->
      <li><a href="/crypto/">crypto</a></li>
      
      <!-- a style="font-size: 236%" href="/doom-uefi/">doom-uefi</a -->
      <li><a href="/doom-uefi/">doom-uefi</a></li>
      
    </ul>
  </div>

</div>



      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2015-01-28T22:56:05+06:00">2015</time>. All rights reserved.
        </small>
      </footer>

    </div>

  </body>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-59069328-1', 'auto');
            ga('send', 'pageview');

            </script>

</html>
