<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      My worklog &middot; My worklog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.png">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="My worklog" href="/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h2 class="masthead-title">
          <a href="/" title="Home">My worklog</a>
          <small><a href="https://github.com/warfish">GitHub</a></small>
          <small><a href="/archive/">Archive</a></small>
          <small><a href="/tags/">Tags</a></small>
        </h3>
      </header>

      <main>
        <div class="wrapper">
  <div class="center">

    <div class="posts">
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2014/03/11/efi-libc/">
        EFI libc
      </a>
    </h1>

    <time datetime="2014-03-11T23:40:20+07:00" class="post-date">11 Mar 2014</time>

    <p>EDK преследует архитектуру library classes, которая позволяет им обернуть самый безобидный интерфейс, типа ASSERT, в полиморфную библиотеку у которой есть один интерфейс и много реализаций. Конкретная &quot;инстанциация&quot; этого полиморфного интерфейса задается в их билд системе через DSC файл. Реализация C99 stdlib, <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/">EDK/StdLib</a>, которую они взяли из Open/Net/Free BSD и жестко мутировали, работает также. Например memcmp у них <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/LibC/String/Comparison.c#l29">реализована</a> через BaseMemoryLib/CompareMem. Такая архитектура позволяет им задавать реализации библиотек для разных этапов загрузки системы (Pei, Dxe, Bbs, Runtime) и местами кажется очень мощной. Но не понятно зачем она нужна в stdlib если они ограничили линковку своей реализации только до EFI_APPLICATION, т.е. только до стадии boot loader-а. Если по-другому, то в результате из реализацию нельзя линковать с EFI драйвером например, хотя бы ради того же memcmp.</p>

<p>Еще один неприятный момент в их реализации - она зависит от EFI shell. В реализации stdio у них скорее всего встал вопрос, как интерпретировать файловые пути где-нибудь в fopen? Ответ такой - через шелл. Их реализация реализует (sic) NetBSD сисколлы через &quot;драйвера устройств&quot;, которые показывают на <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/LibC/Uefi/Devices/UefiShell/daShell.c">маппинги файловых систем в шелле</a>. В результате проблема решена, но появляется жесткая зависимость от шелла. Эта зависимость явно отражена в <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/LibC/Main/Main.c#l131">реализации точки входа</a>. Также шелл позволяет им ввести понятие аргументов командной строки.</p>

<p>Есть еще россыпь проблем поменьше: типа неготовность их хедеров к компиляции в плюсовом юните трансляции, переопределение флагов компиляции в inf файле, реализация realloc которая <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/branches/UDK2010.SR1/StdLib/LibC/StdLib/Malloc.c#l40">опирается</a> на их же собственные приватные структуры кучи из реализации DxeCore, что делает опасным ее использование на реальном железе где куча реализована иначе. Ну и как и все остальное в EDK она непредназначена для линковки с проектами вне дерева EDK.</p>

<p>Все это заставляет задуматься, а зачем? Возьмем например memcmp. Нужно было <em>выкинуть</em> реализацию чтобы заменить ее своей, через полиморфную либу. Можно было опереться на EFI_SIMPLE_FILE_SYSTEM в реализации fopen приняв например схему с эмуляцией дерева фс через гуиды разделов (/Volume{GUID}/...). Можно было заинвертировать зависимость опубликовав свой кастомный протокол, EDK_LIBC_ARGS например, инстанс которого клиент бы вешал на хендл слинкованного с StdLib приложения. Тоже самое можно было бы сделать и с stdio тоже. Под эту схему и шелл бы подошел. But alas.</p>

<p>И вот конструктивная часть поста. Мне интересно насколько трудоемкий вариант выдернуть реализацию StdLib из EDK и сделать ее зависимой только от UEFI spec. Может быть было бы проще начать с нуля, т.е. с BSD libc и портировать ее. Не знаю, но что-то сделать руки чешутся.</p>

    
    <span class="tags">
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2014/01/18/uefi-architecture-protocols-and-portable-dxe-core/">
        [UEFI] Architecture protocols and portable DXE Core
      </a>
    </h1>

    <time datetime="2014-01-18T17:53:25+07:00" class="post-date">18 Jan 2014</time>

    <p>Речь пойдет об особенности PI спецификации - архитектурных протоколах, которые осуществляют портабельность DXE core и позволяют переносить всю реализацию DXE стадии на платформы эмуляции UEFI, такие как legacy BIOS (EDK/<a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/">DuetPkg</a>) и Win32 (EDK/<a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/Nt32Pkg/">Nt32Pkg</a>).</p>

<p>Меня всегда интересовало, почему DuetPkg и Nt32Pkg, судя по их DSC файлам, по большей части состоят из бинарных модулей, ничего не знающих про эмуляцию. Наример оба эмулятора использую общую реализацию всего DXE рантайма. Как такое работает?</p>

<p>Согласно спецификации UEFI инициализация платформы и подготовка ее к загрузке ОС осуществляется в несколько стадий:
<a href="/public/images/uefifig61.gif"><img src="/public/images/uefifig61.gif"></img></a></p>

<p>Весь API, который описан в UEFI спецификации становится (полностью) доступен на стадии BDS (Boot Device Selection), когда начинает работать boot manager. Реализация этого API и его инициализация происходит, в общем случае, на стадии DXE - driver execution environment. На стадии DXE работаю несколько основных компонентов, которые нас интересуют в контексте темы поста:</p>

<ul>
<li><p>DXE Core
Ядро DXE стадии, получает управление после PEI, разворачивает реализацию базы данных хендлов.</p></li>
<li><p>DXE Dispatcher
Занимается загрузкой драйверов из firmware volume, который был проинициализирован на стадии PEI.</p></li>
</ul>

<p>Референсную реализацию DXE можно найти в <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/MdeModulePkg/Core/Dxe/">EDK/MdeModulePkg/Core/Dxe</a>.</p>

<p>DXE Core реализует EFI_SYSTEM_TABLE и все сервисы из EFI_BOOT_SERVICES и EFI_RUNTIME_SERVICES за счет опоры на EFI architecture protocols:</p>

<p><a href="/public/images/dxefoundationarchitectural1.png"><img src="/public/images/dxefoundationarchitectural1.png"></img></a></p>

<p>Картинка выше перегружена деталями, но в центре находится реализация DXE, которая зависит от набора архитектурных протоколов таких как EFI_CPU_ARCH_PROTOCOL, EFI_TIMER_ARCH_PROTOCOL и так далее. Эти протоколы описаны в PI спецификации и немногим отличаются от протоколов из UEFI спецификации. Различия есть в драйверах, которые их реализуют: это обычные DXE boot service / DXE runtime service драйвера, однако т.к. опубликованные ими протоколы являются опорой для реализации основных boot и runtime сервисов, то они не могут рассчитывать на их полный набор на некоторых этапах своего выполнения.</p>

<p>Становится понятной роль архитектурных протоколов - они абстрагируют базовое железо конкретной архитектурной платформы и позволяют коду в DXE core опираться на эти абстракции в реализации основных сервисов, например:</p>

<ul>
<li><p>Реализация рантайм сервиса <a href="http://wiki.phoenix.com/wiki/index.php/EFI_RUNTIME_SERVICES#GetTime.28.29">EFI_RUNTIME_SERVICES::GetTime()</a> опирается на архитектурный протокол EFI_REAL_TIME_CLOCK_ARCH_PROTOCOL для доступа к аппаратному устройству wall-time clock</p></li>
<li><p>Вся реализация ивентов в EFI_BOOT_SERVICES использует EFI_TIMER_ARCH_PROTOCOL для генерирования периодических прерываний по таймеру.</p></li>
<li><p>EFI_CPU_ARCH_PROTOCOL используется для синхронизации кешей процессора и реализации сервисов управления памятью</p></li>
</ul>

<p>Драйверы, реализующие эти протоколы, как правило находятся в firmware volume, который инициализируется на стадии PEI и информация о котором передается в DXE Core посредством списка Hand-off Block структур (HOB list), что показано в верхней части картинки выше. Я не буду сейчас заострять внимание на деталях HOB списка, скажу только что это каждый HOB представляет из себя блок данных и GUID, который позволяет интерпретировать эти данные различными клиентами на стадии инициализации DXE. При помощи HOB передается информация о доступной памяти, memory mapped firmware volume и т.п.</p>

<p>Firmware volume был упомянут уже не раз, но его определение так и не было дано до сих пор. Firmware volume (FV) это структурированная база данных исполняемых модулей DXE, т.е. драйверов и приложений. База данных FV адресует образы по GUIDу и хранит информацию о зависимостях между различными модулями, а так же т.н. a priori list - список GUIDов образов, которые нужно загрузить при инициализации DXE в строго определенной последовательности. Драйвера архитектурных протоколов как правило и находятся в a priori list. Физически на реальной системе FV находятся в ROM и доступ к нему предоставляется через замапленый диапазон адресов физический памяти. Маппинг осуществляется на стадии PEI и информация о нем передается в HOB листе.</p>

<p>Таким образом при старте DXE код может опираться только на рабочую физическую память, проинициализированную на стадии PEI и описанную в HOB листе. Этого достаточно  для инициализации базы данных хендлов, доступа к FV, загрузке драйверов из FV посредством DXE Dispatcher и инициализацию всех UEFI сервисов.</p>

<p>Становится понятным список задач, которые должен выполнить эмулятор, чтобы загрузить общий код DXE:</p>

<ul>
<li><p>Реализация всех архитектурных протоколов, на который опирается DXE Core</p></li>
<li><p>Реализация firmware volume, доступа к нему и загрузку бинарных образов в среду эмуляции.</p></li>
<li><p>Реализация дополнительных драйверов, таких как block io, GOP, консолей и т.п.</p></li>
<li><p>Формарование корректного HOB листа и передача управления в DXE.</p></li>
</ul>

<p>В этом и заключается полезная нагрузка DuetPkg и Nt32Pkg. К примеру Nt32Pkg реализует архитектурные протоколы и драйвера основных UEFI протоколов через сервисы Win32 и хранит FV как папку на файловой системе предоставляя доступ через <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/Nt32Pkg/FvbServicesRuntimeDxe/">FvbServiceRuntimeDxe</a> драйвер. Реализацию аналогичных компонентов можно найти и в DuetPkg, хотя там все сложнее из-за специфики эмулятора UEFI поверх legacy BIOS, но общая схема остается неизменной.</p>

    
    <span class="tags">
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2014/01/01/career-suicide/">
        Career suicide
      </a>
    </h1>

    <time datetime="2014-01-01T15:56:22+07:00" class="post-date">01 Jan 2014</time>

    <p>Я стараюсь держать этот блог строго техническим, а не личным, но раз в год можно.</p>

<p>Я научился проходить собеседования на С++ девелопера до того как научился программировать на нем. :) Это очень просто. С++ такой язык, что можно долго радовать собеседников деталями реализации виртуальных функций, лейаутом объектов в памяти, отличием ++i от i++ и тому подобной мишурой, которая хотя и полезна, но вовсе не подразумевает способности собеседуемого решать на этом языке задачи, т.е. <em>программировать</em>. И это не было каким-то хитрым планом, попыткой обмануть - я искренне считал что этого достаточно.</p>

<p>До того как научится проходить собеседования на С++ девелопера я умел хорошо кодить на ANSI C. Это тоже было очень далеко от инжиниринга и дизайна чего-то большого, развесистого и требующего планирования. Почему от кодинга на сях я перешел в детали работы виртуальных функций, а не в инжиниринг? Я пытался, но от книг типа <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">design patterns</a>, <a href="http://www.amazon.com/Object-Oriented-Software-Construction-Book-CD-ROM/dp/0136291554">OOSC</a> и <a href="http://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871">SICP</a> я засыпал через каждые 20 страниц, хотя домучил все три. <a href="http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670">Code complete</a> и <a href="http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844">Алгоритмы</a> были интереснее, но по-настоящему интересными книгами того времени для меня были <a href="http://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298">Expert C</a>, <a href="http://www.amazon.com/Understanding-Linux-Kernel-Third-Edition/dp/0596005652">LK</a> и <a href="http://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468">LKD</a> (к слову я смотрю на GNU-манифест и прочую романтику как на ребячество, а в худшем случае как на рак мозга).</p>

<p>Теперь, когда я пытаюсь делать дизайн крупной фичи, декомпозировать ее и высосать из пальца объекты, то мозг скрипит и сопротивляется. В итоге получается в основном хорошо, но очень болезненно. Приятная, интересная и в результате более продуктивная и результативная работа для меня выглядит примерно так: у меня есть черный ящик, который что-то делает, не понятно что. Возможно понятно что он делает, но он запутан деталями. Мне нужно разобраться как с ним работать и абстрагировать его за простым API, который состоит из нескольких простых функций и структур данных. Я чувствую большое удовлетворение от такой работы: от процесса исследования ящика и от дизайна API, который, самое главное, сильно упрощает кому-то жизнь. Ящиком может быть железка, какой-то системный алгоритм вроде DMA или виртуальной памяти. Ящиком может быть какое-нибудь красно-черное дерево. Ящиком может быть непонятный баг. Так или иначе в таком направлении мозг не скрипит, а легко скользит.</p>

<p>Все это хорошо, знать свои сильные и слабые стороны хорошо, но еще я хочу карьеру, а карьера подразумевает повышение уровня ответственности, который, как правило влечет за собой повышение уровня абстракции. И тут мне кажется, что это идет вразрез с тем что я умею хорошо и с тем, что не очень. Я конечно могу в итоге дойти до уровня чувака, который знает всю системную канализацию настолько хорошо, что может по фотографии электромагнитного излучения выполняемого кода угадать что не так и снять порчу, но это все сказки, потому что такие обычно живут в горах, требуют задавать им не больше трех вопросов в день и отрешаются от всего мирского. На самом деле в реальности они живут скорее в подвале у мамы, чем в горах, но остальное верно.</p>

<p>Речь не идет о &quot;нравится - не нравится&quot;, нет в моей работе сейчас ничего, что я заставлял бы себя делать насильно, за мелкими исключениями. Если исходить из прагматических соображений, то все просто: у меня хорошо получается одно и не очень хорошо получается второе, но именно второе видится как основное, в чем нужно быть успешным, чтобы карьерно расти.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/12/23/d18dd0bcd183d0bbd18fd186d0b8d18f-efi-d0bdd0b0-win32/">
        Эмуляция EFI на Win32
      </a>
    </h1>

    <time datetime="2013-12-23T22:31:28+07:00" class="post-date">23 Dec 2013</time>

    <p>В целях тестирования и облегчения отладки у нас есть эмулятор нашего &quot;пребута&quot; на win32. Эмулятор эмулирует некоторую нашу абстракцию платформы, которая на EFI реализована поверх EFI, а на биосе поверх эмуляции EFI :)</p>

<p>Мне кажется, что подход с эмуляцией этого слоя начинает загонять нас в угол в некоторых местах. Все было хорошо пока эмуляция касалась только клавиатур и дисплеев. Как только возникла тема с поддержкой USB и родных EFI драйверов от вендоров определенного типа устройств (роскошь от которой мы не можем отказаться), то стал появлятся паттерн: есть простой и понятный подход это поддержать, но он режется из-за эмуляции. Мне кажется что таким образом мы начинаем терять одно из самых сильных преимуществ нашего подхода - начиная с определенного уровня у нас везде EFI. Это преимущество позволяет нам фактически <strong>удваивать</strong> производительность, потому что мы пишем один EFI бинарник, а покрываем им сразу две платформы.</p>

<p>Поэтому мне кажется нам нужно эмулировать EFI на win32. :) При этом нужно сохранить основное практическое преимущество эмуляции - отладка PBA студийным компилятором.</p>

<p>*<em>Как это сделать. *</em></p>

<p>В EDK есть проект - <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/Nt32Pkg/">Nt32Pkg</a>. Это софтверный эмулятор EFI окружения. Он не эмулирует PC/AT - в этом его отличие от QEmu с прошивкой. Он компилируется в exe-шник и реализует эмуляцию EFI поверх win32 сервисов. Т.е. грубо говоря аллокация памяти реализована через HeapAlloc, загрузка драйверов через LoadLibraryEx. Драйвер блочного устройства может либо транслировать реальный диск либо эмулировать его на файле. GOP и клавиатурный ввод идут непосредственно через GDI контекст окна приложения. При этом екзешник и драйвера он грузит через LoadLibraryEx, значит, <em>вроде бы</em> его можно отлаживать. Чего в нем не хватает:</p>

<ol>
<li><p>Он не эмулирует USB и не протаскивает хостовые USB девайсы. Для поддержки токенов его придется этому учить, например через <a href="http://en.wikipedia.org/wiki/WinUSB">WinUSB</a>.</p></li>
<li><p>Он не знает про наши образы дисков, которые у нас широко начали применятся. Нужно делать BlockIo луп-девайс на наш образ диска, что в общем-то может пригодится не только в эмуляции.</p></li>
</ol>

<p>Концепция работы с таким эмулятором такая, что мы запускаем на нем весь наш и EFI и эмулируемый Win32 код, т.е. ядро и PBA. Моки ядра придется делать эээ другим ядром. И мне кажется, что все это к лучшему:</p>

<ol>
<li><p>Мы таким образом приходим к одной единственной реализации ядра на все три платформы - на EFI. Т.е. теперь один бинарник кроет не две а три платформы.</p></li>
<li><p>Так как на эмуляции запускается тот же код ядра, что и в пребуте, то это позволяет нам больше тестировать наш продакшен-кейс.</p></li>
<li><p>Моки, как я сказал, делаются честной EFI реализацией. Ну или подгружаемой DLL. Так или иначе моки можно, в принципе, запускать не только на эмуляторе. Возможно тут есть профит.</p></li>
<li><p>EDK планируют объединение двух своих эмуляторов (<a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/Nt32Pkg/">Nt32Pkg </a>и <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/UnixPkg/">UnixPkg</a>) в одну платформу - <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/EmulatorPkg/">EmulatorPkg</a>. Что сделает нашу эмуляцию кроссплатформенной на винде и линуксе.</p></li>
</ol>

<p>Конечно это не бесплатно. Но альтернатива мне видится такой, что и ядро и эмуляция начнут обрастать ненужными абстракциями в целях поддержать один и тот же код PBA, а преимущество единой платформы, позволяющее нам сейчас запускать одни бинари на двух платформах и сильно сокращающее нам выход в релиз, начнет буксовать.</p>

<p><strong>А что с PBE API.</strong></p>

<p>Возникает резонный вопрос - если везде EFI, то зачем вообще нужен текущий слой абстракции, который и эмулируется сейчас на Win32 - PBE API.</p>

<p>На мой взгляд PBE API выполняет важную роль - позволяет pba.dll быть полностью юзермодной дллкой без знания про EFI. Это делает PBA более самодостаточным, имеет больш<strong>и</strong>е преимущества для его сборки и отладки. Тем не менее я думаю, что PBE API должен в дальнейшем развиваться в сторону <a href="http://wrfsh.wordpress.com/2013/12/07/preboot-win32-process-vm/">win32 process VM</a>. В идеале я вижу себе такую картину: в качестве низкоуровневой платформы везде EFI, а pba.dll зависит только от Win32 API в виде kernel32.dll и т.п. Я думаю что это не практично в таком абсолюте, например несколько функций кастомного фреймбуфера PBE на порядок проще и удобнее чем gdi32.dll. Но я думаю что лучше стремится к win32 там где это оправдано практически.</p>

    
    <span class="tags">
      
      <a href="/preboot/">preboot</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/12/14/d0b2d0bdd0b5d0b7d0b0d0bfd0bdd0be-d0bed181d0bed0b7d0bdd0b0d0bdd0b8d0b5/">
        Внезапно осознание
      </a>
    </h1>

    <time datetime="2013-12-14T02:35:19+07:00" class="post-date">14 Dec 2013</time>

    <p>Как так получилось, что год назад PBA был 16-ти битным приложением, которое еле влезало в ~600kb риалмодной памяти, которое нужно было отлаживать дизассемблером дампов и принтфами в ком порт, а теперь это (почти) обычное юзермодное Qt приложение с поддержкой плюсов, STL, boost, которое можно писать и отлаживать под виндой и которое весит 12 метров не считая кучу, которую еще никто даже не считал, но работает в пребуте:</p>

<p><a href="/public/images//w7x64-2013-12-12-12-37-4611.png"><img src="/public/images/w7x64-2013-12-12-12-37-4611.png" alt="w7x64-2013-12-12-12-37-461"></a></p>

<p>Что-то кажется мы хорошо поработали в этом году.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/12/07/preboot-win32-process-vm/">
        Preboot Win32 process VM
      </a>
    </h1>

    <time datetime="2013-12-07T13:08:59+07:00" class="post-date">07 Dec 2013</time>

    <p><a href="http://en.wikipedia.org/wiki/Virtual_machine">http://en.wikipedia.org/wiki/Virtual_machine</a>:</p>

<blockquote>A process VM, sometimes called an _application virtual machine_, or _Managed Runtime Environment_ (MRE), runs as a normal application inside a host OS and supports a single process. It is created when that process is started and destroyed when it exits. Its purpose is to provide a [platform](http://en.wikipedia.org/wiki/System_platform)-independent programming environment that abstracts away details of the underlying hardware or operating system, and allows a program to execute in the same way on any platform.</blockquote>

<p>Process VM эмулирует окружение для иденственного процесса. Эмуляция заключается в основном в реализации ABI платформы и стоящего за ним рантайма. Под ABI в данном случае подразумеваются как правило механизм и реализация подобия системных вызовов платформы. Если хостовая <a href="http://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA</a> отличается от той, для которой собран таргет, то тогда эмуляция включает в себя и бинарную трансляцию target ISA - host ISA. Референсной реализацией считается <a href="http://en.wikipedia.org/wiki/FX%2132">FX!32</a></p>

<p>Если ближе к пребуту, то скоуп такой: на входе имеем win32 PE/PE+ dll однопоточный модуль, который слинкован с родным MS CRT и тянет ряд платформенных ABI зависимостей, как правило в форме импортов kernel32 / ntdll. ISA таргета и хоста совпадают. Помимо загрузки, релокации и разрешения импортов PE laundry list полноценной реализации окружения и ABI примерно такой:</p>

<ul>
<li><p>Куча процесса (kernel32!HeapXXX). Как показала практика тут полезна отдельная куча чтобы не лезть в приватные структуры данных хостовой кучи и иметь возможность отделить аллокации таргета от хоста и трассировать их для отладки.</p></li>
<li><p>Контейнер виртуальной файловой системы процесса для подгрузки модулей по имени, загрузки UI ресурсов, etc.</p></li>
<li><p>TLS, FLS, переменные окружения, настройки кодовой страницы для конвертации строк, - все в контексте таргета.</p></li>
<li><p>Манагмент дополнительных загружаемых библиотек таргета(kernel32!LoadLibrary).</p></li>
<li><p>Динамическое связывание с импортами вызова VM монитора, если процесс знает о его существовании. В нашем случае знает и должен знать во избежании импортов GDI для рисования UI.</p></li>
<li><p>Реализация второстепенных системных вызовов типа записи на консоль, остановки процесса и т.п.</p></li>
</ul>

<p>При переходе от однопоточного к многопоточному таргету появляется CreateThread и примитивы синхронизации, и все это возможно реализовать, правда гораздо дороже чем все описанное выше.</p>

<p>Однако до CreateThread существует другой &quot;Nice to have&quot; - поддержка таргетов, состоящий из нескольких модулей. Например поддержка таргета, который линкуется с Qt динамически, а не статически. Проблема с такими таргетами в том, что в отличии от импортов, являющихся часть эмулируемого ABI, VMM ничего не знает о qt.dll и должен опираться на какую-то абстракцию файловой системы для их загрузки и связывания.</p>

<p>Общий поинт в том, что рассматривая пребут на определенном уровне как win32 process VM можно получить четкую модель реализации, которая сама по себе является портируемой на другие реализации пребута (в частности Win32 эмуляцию).</p>

    
    <span class="tags">
      
      <a href="/preboot/">preboot</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/11/13/d0bed0bed0bf/">
        ООП
      </a>
    </h1>

    <time datetime="2013-11-13T22:21:47+07:00" class="post-date">13 Nov 2013</time>

    <p>Объектно ориентированное программирование - это методология разработки программного обеспечения и структурирования кода, которая ставит целью найти наиболее хитрожопый выход из ситуации, когда более простой, эффективный и понятный подход невозможен из-за религиозных убеждений, острой паранойи и авторитетного мнения.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/10/27/exokernels/">
        Exokernels
      </a>
    </h1>

    <time datetime="2013-10-27T12:41:31+07:00" class="post-date">27 Oct 2013</time>

    <p>Оригинальная концепция: <a href="http://u.cs.biu.ac.il/%7Ewiseman/2os/microkernels/exokernel.pdf">http://u.cs.biu.ac.il/~wiseman/2os/microkernels/exokernel.pdf</a></p>

<p>Если коротко, то exo-ядра это крайне минималистичный подход. Концепция перпендикулярна микро или монолитным ядрам. Экзоядро реализует гораздо меньше абстракций чем обычно и дает очень много прямого доступа к &quot;близким к аппаратным&quot; ресурсам (таблицы страниц, дисковые сектора, кеши, etc.). Например экзоядра не реализуют абстракцию файловой системы. Юзерленд реализует ее сам, если нужно (обычно с помощью т.н. libOS). Если не нужно, то работает прямо с диском. Ядро все еще контролирует доступ и мультиплексит эти ресурсы, просто речь о гораздо более низкоуровневом доступе и контроле за этим доступом.</p>

<p>В пейпере есть раздел 5.4.2 The Cheetah HTTP/1.0 Server, который описывает реализацию агрессивно оптимизированного веб сервера на экзоядре.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/10/19/d0b4d180d0b0d0b9d0b2d0b5d180d0b0-etoken-d0bdd0b0-windows/">
        Драйвера eToken на Windows
      </a>
    </h1>

    <time datetime="2013-10-19T18:49:35+07:00" class="post-date">19 Oct 2013</time>

    <p>Я немного посмотрел устройство всего стека eToken на винде и вот что получилось:</p>

<ol>
<li><p>Центральный модуль в их архитектуре это <strong>Windows\system32\eToken.dll</strong>. Этот модуль экспортирует наружу реализацию pkcs#11. Неясно насколько много в нем реализации pkcs#11, но кода много.</p></li>
<li><p>Сам eToken.dll требует ряд импортов, в основном стандартные kernel32.dll, user32.dll, etc. Еще ему нужен winscard.dll, импорты которого регулярно просвечиваются по дереву вызовов pkcs#11 реализации.</p></li>
<li><p>В комплекте идут 2 драйвера:</p></li>
</ol>
<div class="highlight"><pre><code class="language-text" data-lang="text">* aksup.sys - класс USB. В inf файле замечены VendorID/DeviceID алладиновских устройств


* aksifdh.sys - класс SmartCardReader. Подозреваю что это плагин winscard API для интерфейса ридера. Зависит от первого драйвера.
</code></pre></div>
<p>Итого складывается такая картина. Ядреное присутствие eToken ограничивается USB устройством и плагином для winscard, а то что я подозреваю реализацией pkcs#11 - eToken.dll - опирается на winscard.dll.</p>

<p>Отсюда идеи. Предположим, что мы хотим использовать eToken.dll как есть в пребуте. Тогда нам нужны импорты для него. Есть шелуха типа kernel32.dll, user32.dll, которую, думаю, можно разрулить (что-то уже разрулено). И есть winscard.dll. Такой ли это громадный монстр? Оказывается нет : <a href="http://www.smartcard-magic.net/en/pc-sc-reader/winscard-api-c-c/">http://www.smartcard-magic.net/en/pc-sc-reader/winscard-api-c-c/</a>, <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa380142(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/aa380142(v=vs.85).aspx</a></p>

<p>Тут нужно небольшое пояснение. Токен это формфактор смарткарты, объединяющий ридер и карту. Есть интерфейс ридера, а есть интерфейс карты. Интерфейс ридера это winscard при поддержке драйверов etoken, которые, как мы уже знаем, общаются с Siemens CardOS внутри девайса. При этом протокол общения открыт и реализован в OpenCT. Поэтому в принципе winscard API можно реализовать используя драйвера из OpenCT / PCSC-lite / etc. Т.е. получается, <em>что нам не нужны закрытые бинарные драйвера ридера eToken.</em> У нас есть свои.</p>

<p>Реализация winscard API есть, например, у эппла: <a href="http://www.opensource.apple.com/source/SmartCardServices/SmartCardServices-34733/src/PCSC/winscard.c">http://www.opensource.apple.com/source/SmartCardServices/SmartCardServices-34733/src/PCSC/winscard.c</a>. Я думаю ее можно найти в реактосе. И скорее всего в RTOS-32: <a href="http://www.on-time.com/rtos-32.htm">http://www.on-time.com/rtos-32.htm</a>. Последнее правда за деньги, но я хочу немного на RTOS-32 остановится в этом контексте. Мы знаем, что у McAfee, который поддерживает токены, используется именно он в пребуте на биосе. Мы также знаем что у них недавно появилась поддержка EFI, где тоже есть токены. В таком разрезе кажется очень вероятным что они для поддержки токенов на EFI портировали какие-то куски из RTOS-32 и если там есть реализация winscard API, то я почти уверен что они портировали именно его.  Это можно выяснить наверняка, но главное то, что если я прав, то реализацию winscard можно <em>купить</em>.</p>

<p>Ок, с ридером разобрались. Интерфейс карты проприетарный с закрытыми форматами, где его взять? В eToken.dll, для которой мы уже разобрались с ридером через winscard :)</p>

<p>Такой подход сулит ряд бенефитов:</p>

<ul>
<li><p>Если все производители идут примерно таким же путем, то подход хорошо скалируется.</p></li>
<li><p>Конкретно по eToken - нам не нужны их драйвера, потому что мы сами реализуем winscard поверх тех драйверов ридеров, что есть в OpenCT / PCSC-lite.</p></li>
</ul>

<p>Мне не понятна трудоемкость и надежность такого решения. Мне не понятна легальная сторона - можем ли мы использовать чужие бинарные модули вот так? Но мне крайне интересно попробовать, потому что потенциально это сулит более менее легкую поддержку большого числа устройств.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/10/12/doom-uefi-alpha/">
        [DOOM-UEFI] Alpha
      </a>
    </h1>

    <time datetime="2013-10-12T21:40:07+07:00" class="post-date">12 Oct 2013</time>

    <p><a href="/public/images/screen-shot-2013-10-12-at-9-28-07-pm.png"><img src="/public/images/screen-shot-2013-10-12-at-9-28-07-pm.png" alt="Screen Shot 2013-10-12 at 9.28.07 PM"></a></p>

<p>Проблемы:</p>

<ul>
<li><p>Оказывается драйвер cirrus logic на OVMF дает только 8 бит реального цвета. Качество картинки в оригинале сильно лучше.</p></li>
<li><p>Мышки пока нет, но играть можно и без нее.</p></li>
<li><p>Обновление экрана тормозит, но есть идеи. Одна из них в том, что qemu софтверный эмулятор и я ничего не могу с этим поделать. Надо сравнить с досбоксом на такой же хостовой конфигурации. В противном случае придется оптимизировать.</p></li>
</ul>

    
    <span class="tags">
      
      <a href="/doom-uefi/">doom-uefi</a>
      
    </span>

    </article>
    
    </div>

    <div class="pagination">
      
      <a class="pagination-item older" href="/page3">Older</a>
      
      
      
      <a class="pagination-item newer" href="/">Newer</a>
      
      
    </div>

  </div>
      
  <div class="sidebar">
    <ul class="post-list">
      
      <!-- a style="font-size: 182%" href="/BIOS/">BIOS</a -->
      <li><a href="/BIOS/">BIOS</a></li>
      
      <!-- a style="font-size: 107%" href="/device state/">device state</a -->
      <li><a href="/device state/">device state</a></li>
      
      <!-- a style="font-size: 245%" href="/preboot/">preboot</a -->
      <li><a href="/preboot/">preboot</a></li>
      
      <!-- a style="font-size: 295%" href="/UEFI/">UEFI</a -->
      <li><a href="/UEFI/">UEFI</a></li>
      
      <!-- a style="font-size: 107%" href="/crypto/">crypto</a -->
      <li><a href="/crypto/">crypto</a></li>
      
      <!-- a style="font-size: 195%" href="/doom-uefi/">doom-uefi</a -->
      <li><a href="/doom-uefi/">doom-uefi</a></li>
      
      <!-- a style="font-size: 82%" href="/github/">github</a -->
      <li><a href="/github/">github</a></li>
      
      <!-- a style="font-size: 82%" href="/hardware/">hardware</a -->
      <li><a href="/hardware/">hardware</a></li>
      
    </ul>
  </div>

</div>



      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2015-01-31T16:36:23+06:00">2015</time>. All rights reserved.
        </small>
      </footer>

    </div>

  </body>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-59069328-1', 'auto');
            ga('send', 'pageview');

            </script>

</html>
