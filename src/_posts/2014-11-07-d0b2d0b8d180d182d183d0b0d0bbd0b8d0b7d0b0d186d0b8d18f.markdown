---
author: wrfsh
comments: true
date: 2014-11-07 05:52:05+00:00
layout: post
slug: '%d0%b2%d0%b8%d1%80%d1%82%d1%83%d0%b0%d0%bb%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d1%8f'
title: Виртуализация
wordpress_id: 414
---

Виртуализация, в разрезе технологии интеловских процессоров, позволяет делать ряд интересных вещей. Сам принцип такой - процессор входит в режим vm набором инструкций, после чего код гипервизора перемещается в ring -1, затем работа продолжается как обычно. Гипервизор, оставаясь резидентным в ring -1 может получать управление разными способами:



	
  * Периодически, перехватив прерывания или через preemption timer.

	
  * Синхронно через механизм vm-call-ов который реализуется самим гипервизором и используется модифицированной ОС или драйвером в ней, т.е. агентом в ring 0, который знает о гипервизоре.

	
  * Асинхронно по возникновению интересующих гипервизора событий от нормальной работы немодифицированного кода.


Последний механизм самый интересный. Код гипервизора может перехватывать ряд интересных для него событий, которые генерирует нормальная работа немодифицированного кода всех менее привелигерованных режимов. Когда эти события возникают, то процессор делает т.н. vmexit, т.е. возврат в ring -1 и передачу управления хендлеру гипервизора. Механизм похож на exception handler, но регистрация на интересующие исключения происходит по-другому. Что можно перехватывать - много чего, но вот одни из самых интересных вещей:

	
  * Обращения к физической памяти. В режиме виртуализации то что ОС в ring 0 видит как физическую память на самом деле виртуальные адреса смаппированные гипервизором. Ring 0 продолжает нормально работать с этой памятью как с физической, мапить ее на виртуальные адреса, но на самом деле трансляция в физический адрес проходит через дополнительную таблицу страниц гипервизора, у которого есть возможность при маппировании физической страницы указать флагами генерацию исключения и vmexit при доступе к этой странице на R/W/X. В результате можно перехватывать любые обращения гостевой ОС к интересующему диапазону адресов.

	
  * I/O адресное пространство. При инициализации гипервизор может задать битовую маску на весь диапазон I/O портов x86 (почти на весь - у интела баг, который не позволяет захватить два последних бита в маске). Эффект тот же что и с памятью - vmexit при попытке обращения к I/O порту. Это дает дополнительную возможность перехвата одного из способов обращения к PCI Configuration Space, о котором позже.

	
  * MSR - vmexit при попытке R/W на интересующий регистр.

	
  * Еще несколько дополнительных триггеров, включая обращения к XMM/FPU контексту, CPUID, GDT, LDT, IDT, CR регистры.


Все это позволяет гипервизору эмулировать отдельную песочницу для каждого из гостей,аллоцировать ресурсы и переключать выполнение между несколькими гостями, фильтровать и перенаправлять прерывания и т.д. без модификации самих гостей. А еще это позволяет перехватывать весь доступ гостя к ACPI, PCI и MSR, - т.е. всеми каналами управления переферийным железом и чипсетами, что открывает интересные возможности по фильтрации доступа к железу. Можно спрятать PCI устройство, можно нарисовать свое фейковое устройство и т.д. Это открывает дополнительные прикладные возможности виртуализации, помимо очевидной основной, в рамках одного гостя.

Например можно попытаться решить проблему с "богатым пребутом" - запустить линукс с возвратом в фирмварь без потери состояния железа, через жесткий ACPI и PCI фильтр и редирект запросов на допустимые устройства в драйвер фирмвари. В случае UEFI можно попытаться не делать выход из бут сервисов, а отобрать у фирмвари процессор на время, защитить ее память и запустить ядро линукса.

Но одна из самых интересных прикладных задач для меня это инструменты, точнее дебаггер с элементами гипервизора для бареметал. Типичный механизм брейкпоинтов и вочпоинтов подразумевает, что ты знаешь адрес, по которому должен сработать выход в дебаггер. В случае отлаживания и исследования неизвестного кода, например фирмвари, адреса заранее не известны, есть только теория что код обращается к железу / странице памяти / MSRу (например чтобы поменять GS_BASE ;)). В таких случаях нужно нечто более "декларативное", нужно сказать что-то типа "я не знаю где это происходит, но как только это произойдет, то я хочу об этом знать", что и позволяют в определенных пределах элементы гипервизора. Помимо отладки такой инструмент можно использовать для исследования чужого кода, в том числе вредоносного, играть с внедрением ошибок от устройств, эмулировать устройства на самом нижнем уровне для проверки устойчивости системы к ошибкам и поиска уязвимостей например.

Основной недостаток это конечно аппаратные требования. У интела нужную технологию поддерживает уже более менее вся линейка core i процессоров второго и последующих поколений. У AMD своя технология, отдельная от интела и я про нее мало знаю, кроме того что общий смысл тот же, а опкоды другие. У ARM-ов тоже недавно появился TrustZone, который по сути тот же ring -1.
