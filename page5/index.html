<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      My worklog &middot; My worklog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.png">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="My worklog" href="/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h2 class="masthead-title">
          <a href="/" title="Home">My worklog</a>
          <small><a href="https://github.com/warfish">GitHub</a></small>
          <small><a href="/archive/">Archive</a></small>
          <small><a href="/tags/">Tags</a></small>
        </h3>
      </header>

      <main>
        <div class="wrapper">
  <div class="center">

    <div class="posts">
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/06/15/uefi-emulation-what-exactly-is-duetpkg/">
        [UEFI Emulation] What exactly is DuetPkg
      </a>
    </h1>

    <time datetime="2013-06-15T19:04:50+07:00" class="post-date">15 Jun 2013</time>

    <p>Речь пойдет о том, что именно такое DuetPkg в EDK2, какую роль он выполняет.</p>

<p>DuetPkg, в рамках EDK пакета (<a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/">http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/</a>) служит базовой реализацией платформы UEFI поверх Legacy BIOS. На этапе загрузки в его задачи входит загрузка образа, инициализация защищенного режима, страничной памяти и таблицы прерываний, - все под требования остальных компонентов EDK, чтобы они &quot;просто работали&quot;. В рантайме он занимается эмуляцией NVRAM и предоставляет сервис для возврата в реальный режим и вызовы прерываний BIOS.  Если разобрать его покомпонентно, то получается такая картина:</p>

<ul>
<li><p><a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/BootSector">BootSector</a> - набор ассемблерных программ реального и защищенного режима. Из них комбинируется цепочка загрузки на разных платформах. Mbr, FAT boot sector и старт EfiLoader-а, - все там.</p></li>
<li><p><a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/EfiLdr">EfiLdr</a> - загрузчик PE образов. Ему передается управление сразу после перехода в плоский защищенный режим. В его задачи входит расжатие остальных компонентов образа, парсинг и релокация PE и передача управления в DxeIpl</p></li>
<li><p><a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/DxeIpl">DxeIpl</a> - Занимается базовой инициализацией платформы. Инициализирует paging, таблицу прерываний защищенного режима и отдает управление в DxeCore, который уже является стандартным компонентом из MdePkg, т.е. &quot;прикладным&quot; кодом EDK.</p></li>
<li><p><a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/PciBusNoEnumerationDxe">PciBusNoEnumerationDxe</a>/<a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/PciRootBridgeNoEnumerationDxe">PciRootBridgeNoEnumerationDxe</a> - драйвера PCI шины. Предоставляют доступ к PCI configuration space, реализуют PCI IO, позволяют обходить шину и искать там конкретные устройства. NoEnumeration означает что эти компоненты не занимаются аллокацией PCI ресурсов. Т.е. если какое-то устройство на шине не было проинициализировано биосом, то выделением и арбитрацией ресурсов для него будет заниматься конкретный драйвер этого устройства, а не эти компоненты.</p></li>
<li><p><a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/BiosVideoThunkDxe">BiosVideoThunkDxe</a> - механизм вызова INT 10h биоса и реализация EFI_GRAPHICS_OUTPUT_PROTOCOL поверх него.</p></li>
<li><p><a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/FSVariable">FSVariable</a> - драйвер эмуляции NVRAM через файл на загрузочной флешке.</p></li>
</ul>

<p>Остальные компоненты выполняют вспомогательную функцию и особого интереса не представляют. Для реализации всего остального UEFI окружения, например страничного аллокатора, загрузчика драйверов, базу данных хендлов и фреймворка пользовательского интерфейса (HII) используются компоненты не входящие напрямую в DuetPkg, а находящиеся в основном в MdePkg, MdeModulePkg, PcAtChipsetPkg, IntelFrameworkPkg.</p>

<p>Получается, что все богатство эмуляции, которое видно после загрузки с флешки со сборкой DuetPkg реализовано именно прикладным кодом EDK, а не дуэтом. Если разобрать как выглядит сборка дуэта в рантайме и как она загружается (например с флешки), то получается примерно так:</p>

<ol>
<li><p>BIOS загружает MBR флешки (DuetPkg/BootSecotor/Mbr.asm)</p></li>
<li><p>MBR ищет FAT12/16/32 раздел, читает boot sector (DuetPkg/BootSector/bs32.asm) и отдает ему управление</p></li>
<li><p>BS парсит FAT и ищет файл EfiLdr20, лежащий в корне раздела. Затем он загружает первый сектор этого файла и отдает ему управление.</p></li>
<li><p>Структура EfiLdr20:</p>

<ol>
<li>Start32.com (BootSector/Start32.asm). Разделен на две части. В первом секторе находится код реального режима, который поднимает с диска весь остальной EfiLdr20 и переходит по оффсету 0x200 в нем.</li>
<li>Start32.com2 (тот же BootSector/Start32.asm). Вторая половина переводит машину в защищенный режим и передает управление Efi32.com2, по оффсету 0x1000 внутри файла</li>
<li>Efi32.com2 (BootSecotor/Efi32.asm). Составляет e820 карту памяти, парсит заголовок EfiLoader и передает ему управление с параметром - адресом карты памяти.</li>
<li>EfiLoader. Был описан ранее. Разжимает, релоцирует и запускает DxeIpl/PE</li>
<li>DxeIpl. Был описан ранее. Инициализирует платформу и запускает DxeCore/PE.</li>
</ol></li>
</ol>

<p>На этом вклад DuetPkg в этап загрузки системы заканчивается. DxeCore, который работает следом, уже часть MdePkg. Он парсит базу данных драйверов FV (которая идет следом за ним в EfiLdr20) и загружает каждый из этих драйверов. Драйвера, загружаясь, инициализируются, создают хендлы и публикуют на них протоколы, - обычный такой UEFI рантайм. В конце концов загружается BootManager, ищет загрузочное устройство и запускает с него шелл. Или не запускает, если не нашел. Суть описанного в том, что DuetPkg существует в качестве jump start-ера ядра EDK и всех его драйверов. В рантайме он предоставляет дополнительные драйвера, но немного.</p>

<p>Возникает вопрос, а можно ли тогда сделать &quot;свой&quot; DuetPkg и, главное, зачем?</p>

<p>Можно, причем это не слишком тяжело. Вещи типа страничного аллокатора и базы данных хендлов и HII и всего остального идут &quot;бесплатно&quot; из других компонентов EDK. Все что требуется от своей реализации это инициализировать пейджинг, таблицу прерываний, несколько драйверов и обеспечить загрузку всего этого добра согласно протоколам UEFI.</p>

<p>Зачем это может понадобится? Затем, что задача DuetPkg это окружение для тестирования UEFI приложений и драйверов на Legacy BIOS машинах. Он не подразумевает например последующую загрузку UEFI-capable или любой другой ОС. В результате он все-таки не слишком заботится о сохранении состояния аппаратуры для биоса. Задачи бывают разные, с разными требованиями, для реализации которых нужно переделывать процесс загрузки образа, иначе обходится с аппаратурой, больше опираться на биос, не лезть в ACPI, выкинуть эмуляцию NVRAM и т.д. Возможно проще сделать свой Duet (попутно вытянув из оригинала все что можно) нежели чем перепиливать существующий пополам.</p>

<p>К слову загрузку я уже переделал. Вместо флешки образ кладется на диск, стартует мой MBR, поднимает с сырого диска ld.com, который поднимает весь образ EfiLdr20 и отдает управление сразу в пункт 4.2, т.е. второй части Start32.com</p>

    
    <span class="tags">
      
      <a href="/preboot/">preboot</a>
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/06/14/uefi-emulation-1/">
        UEFI emulation 1
      </a>
    </h1>

    <time datetime="2013-06-14T01:22:06+07:00" class="post-date">14 Jun 2013</time>

    <p>Первый день прототипирования с duet показал, что с ним тоже есть свои проблемы. У него внезапно есть баги, точнее я подозреваю у него баг с картой памяти на машинах с 1gb физической памяти. Исправления не должны быть слишком сложными, но все-таки как-то неприятно :) Ещё он тоже занимается серьёзной инициализацией платформы. Судя по всему он не форвардит прерывания из защищенного в реальный режим, а реализует нужные вектора полноценно. Как именно пока не понятно. Создаст ли это проблемы при переходе на загрузку оригинальной оси я пока не знаю, но выглядит страшновато. Тем не менее я считаю его все ещё лучшим вариантом. Все точно будет не просто, но вариантов и возможностей достаточно.</p>

    
    <span class="tags">
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/06/12/cmos-as-a-persistent-secret-storage/">
        CMOS as a persistent secret storage
      </a>
    </h1>

    <time datetime="2013-06-12T21:54:30+07:00" class="post-date">12 Jun 2013</time>

    <p>Чтобы PBA работало с перезагрузкой, нужно сохранить где-то секрет. Секрет можно разбить на две части - данные и ключ шифрования. В таком случае данные можно положить на диск, а вот куда деть ключ, так чтобы он пережил перезагрузку и его было легко стереть.</p>

<p>На UEFI есть <a href="http://en.wikipedia.org/wiki/Non-volatile_random-access_memory">NVRAM</a>, а вот на BIOS есть <a href="http://en.wikipedia.org/wiki/CMOS">CMOS</a>. Он гораздо меньше, 512 байт, но мне нужно всего 16. Можно поэкспериментировать с хранением секрета в этой памяти в случае, если без перезагрузки жить не получится. Основная проблема с таким подходом пожалуй в том, что формат данных, хранимых в CMOS, плохо стандартизирован. Не понятно где свободное место, а где нужные биосу данные.</p>

<p>Код чтения и записи CMOS в Linux: <a href="http://lxr.linux.no/linux+v3.9.5/drivers/char/nvram.c">http://lxr.linux.no/linux+v3.9.5/drivers/char/nvram.c</a></p>

<p>CMOS memory map: <a href="http://www.bioscentral.com/misc/cmosmap.htm#">http://www.bioscentral.com/misc/cmosmap.htm#</a></p>

<p>OSDev article: <a href="http://wiki.osdev.org/CMOS">http://wiki.osdev.org/CMOS</a></p>

    
    <span class="tags">
      
      <a href="/BIOS/">BIOS</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/06/11/d0b2d0bdd0b5d0b7d0b0d0bfd0bdd0be-duetpkg/">
        Внезапно DuetPkg
      </a>
    </h1>

    <time datetime="2013-06-11T21:40:04+07:00" class="post-date">11 Jun 2013</time>

    <p>После одного часа, потраченного на DuetPkg из EDK2 удалось его собрать и прожечь на загрузочную флешку. Загрузившись на реальной машине через BIOS внезапно оказалось, что в получившейся среде есть:</p>

<ul>
<li><p>Печать юникода на экран (у среды есть французская локализация).</p></li>
<li><p>Полноценный UEFI рантайм, поверх которого успешно грузятся драйвера и запускатся приложения, в том числе и шелл.</p></li>
<li><p>PCI/USB стек.</p></li>
<li><p>Sata, Scsi, Ide драйвера, которые можно подгружать</p></li>
<li><p>Готовые механизмы возврата в реальный режим и вызова BIOS ISR.</p></li>
<li><p>Много еще чего-то, чего я не успел заметить</p></li>
</ul>

<p>Не удалось проверить клавиатурные раскладки. В остальном, внезапно, DuetPkg дает все выше перечисленное, т.е. снимает где-то пол года работы по воссозданию среды эмуляции UEFI. Чтобы заработали токены надо портировать libopensc. USB стек уже есть.</p>

<p>Конечно скорее всего это не бесплатно. При таком богатстве наверное опять встанет проблема состояния железа. Но в этом случае она несравнимо более контролируемая чем  на Linux и, к примеру, написать дисковый драйвер для этой среды, опирающийся на int 13h, не составит особого труда. Более контролируемая она потому что получившаяся среда крайне модульная, очень недалеко стоит от BIOS&#39;а и по своему объему вполне доступна для понимания одним человеком. Выкинуть из сборки например поддержку AHCI будет очень просто. Реализовать замену через int 13h тоже несложно.</p>

<p>Я только очень надеюсь что вопрос с лицензированием не подведет. В остальном таким образом относительно легко BIOS уравнивается в функционале до UEFI, точнее того его подмножества, который мне нужен. Нужно работать дальше, но пока этот вариант выглядит очень привлекательно.</p>

<p>Мне кажется, что при таком раскладе на первый план сейчас выходит проработка загрузки хостовой ОС из этой среды через оригинальный MBR. И тут я припас главное. Есть open source проект <a href="http://sourceforge.net/projects/cloverefiboot/">Clover</a>, который представляет из себя UEFI-based boot loader, основанный на DuetPkg, стартующий с BIOS и загружающий ряд операционных систем. Т.е. он решает эту задачу и им можно вдохновлятся. Ну к примеру реализация вышеупомянутого BlockIo драйвера через INT 13h: <a href="http://sourceforge.net/p/cloverefiboot/code/HEAD/tree/LegacyBios/BlockIoDxe/">http://sourceforge.net/p/cloverefiboot/code/HEAD/tree/LegacyBios/BlockIoDxe/</a></p>

<p>Все это внезапно выглядит слишком хорошо.</p>

<p>UPD: Лицензия - <a href="http://edk2.svn.sourceforge.net/viewvc/edk2/trunk/edk2/MdeModulePkg/License.txt?revision=14397&amp;view=markup">http://edk2.svn.sourceforge.net/viewvc/edk2/trunk/edk2/MdeModulePkg/License.txt?revision=14397&amp;view=markup</a><br>
Насколько я понимаю она позволяет нам использовать этот код без ограничений кроме как приложить текст дисклеймера?</p>

    
    <span class="tags">
      
      <a href="/BIOS/">BIOS</a>
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/05/28/d0ba-d0b2d0bed0bfd180d0bed181d183-d0be-d0bdd0b0d0b9d0bcd0b5-d187d182d0be-d185d0bed187d0b5d182d181d18f-d0bed182-d0bad0b0d0bdd0b4d0b8d0b4/">
        К вопросу о найме: что хочется от кандидата на пребут
      </a>
    </h1>

    <time datetime="2013-05-28T13:24:55+07:00" class="post-date">28 May 2013</time>

    <p>Был задан вопрос - что должен знать и что нужно спрашивать у кандидата на собеседовании, чтобы определить насколько он подходит под наши пребутовые задачи. Ниже я постараюсь дать ответ в форме групп вопросов, которые я бы спросил на собеседовании. В общем и целом мы имеем дело с системным программистом, с некоторой спецификой в плане отвязки от конкретного ядра и системного API. Вопросы я старался подбирать не исходя из собственных знаний (часть я затруднился бы ответить), а исходя из повседневной необходимости.</p>

<ul>
<li><p>Общее</p>

<ul>
<li>Попросить описать самое интересное, что было на любом месте работы по выбору кандидата, какую интересную проблему он решал. Азарт в рассказе показывает заинтересованность в профессии, а сама проблема многое говорит о предпочтениях кандидата. Идеально было бы, если кандидат расскажет в этом качестве об отладке сложного бага :)</li>
<li>Спросить чем список отличается от массива :) Уточнить, что речь идет не о библиотечных структурах, а о базовых теоретических понятиях. Большой плюс если кандидат в рамках ответа об алгоритмической сложности перейдет на практические аспекты и расскажет о pointer chasing.</li>
<li>Что такое переполнения буфера на стеке, как и почему оно работает.</li>
</ul></li>
<li><p>Архитектура x86</p>

<ul>
<li>Режимы работы. Protected mode, long mode. Разграничение доступа между kernel/user space и привилегированные инструкции. Отдельный плюс за real mode и unreal mode, но не стоит зацикливаться именно на этом.</li>
<li>Что такое адрес? Описать путь разыменования простого char* в пользовательском режиме. Как виртуальный адрес превращается в физический? В случае своппинга, как происходит подкачка страниц если виртуальный адрес указывает на засвоппированную страницу? Отдельный плюс за MMU и TLB. Отдельный большой плюс за отличия x86_32 от x86_64 и понятие канонического адреса.</li>
<li>Прерывания. Какие типы бывают и для чего они нужны? Что происходит с процессором при возникновении прерывания? Большой плюс за описание TSS и переключение в привилегированный обработчик прерывания при выполнении кода пользовательского режима. Большой плюс за упоминание контроллера прерываний.</li>
<li>Пространство I/O портов. Что это такое, для чего они нужны? Большой плюс за ответ на вопрос как адресное пространство портов аллоцируется в системе и аллоцируется ли</li>
</ul></li>
<li><p>Инструменты.</p>

<ul>
<li>Компиляция и линковка. Зачем нужен линкер. Что такое бинарный формат исполняемого образа, какие бывают форматы (требовать конкретного знания какого-то конкретного формата не нужно, можно попросить описать на словах общие принципы). Как происходит загрузка исполняемого кода. Что такое слабое связывание (weak linking). Что такое релокация, как она происходит. Большой плюс если кандидат различает релокацию фиксапами и трамплинами.</li>
<li>Отладка. Здесь интересует не сам опыт отладки или использования какого-то конкретного дебаггера, а скорее знание общих принципов, на которых отладчики построены. Как работают отладчики? Какая аппаратная поддержка существует для поддержки отладчиков? Как можно реализовать отладчик самостоятельно? :)</li>
<li>Плюсы. Здесь интересует не столько знание языка как такового, сколько понимание как он реализован. Зачем нужен виртуальный деструктор :) Как обычно реализованы виртуальные функции. Если кандидат упирается, что это деталь реализации на конкретной платформе, то спросить как бы он реализовал их сам. Как реализовано простое невиртуальное немножественное наследование, где в памяти будут данные того или иного предка. Как запускаются конструкторы статических объектов. Бонусная задача: как запустить конструктор объекта если нет кучи, стека и CRT.</li>
</ul></li>
<li><p>Практика</p>

<ul>
<li>Разворот двухсвязного списка. Написать реализацию функции list_node* reverse(list_node* head). Функция принимает голову связного списка, разворачивает его и возвращает новую голову, которая позволяет пройти этот список с хвоста. Задача достаточно небольшая по размеру, в ней есть где ошибиться и она показывает, может ли кандидат писать код :)</li>
</ul></li>
</ul>

<p>В общем и целом я бы предложил отдавать приоритет кандидатам, стремящимся узнать скорее что находится &quot;под капотом&quot; языков и систем, нежели чем отличным теоретическим знаниям или высокоуровневым паттернам языков.</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/05/27/d181d0bad0bed0bbd18cd0bad0be-d181d182d0bed0b8d182-advanced-preboot-environment-d181d0b2d0bed0b8d0bcd0b8-d180d183d0bad0b0d0bcd0b8/">
        Сколько стоит Advanced Preboot Environment своими руками.
      </a>
    </h1>

    <time datetime="2013-05-27T22:58:10+07:00" class="post-date">27 May 2013</time>

    <p>Ниже идет грубая оценка на реализацию Advanced Preboot Environment (APBE), написанную своими руками и опирающуюся на BIOS там где это возможно, а именно в драйверах дисплея, серийного порта и дисков.</p>

<h2>Требования.</h2>

<p>APBE это платформа для &quot;интересной&quot; бизнес логики, работающей до загрузки ОС. Понятия интересного каждый определяет сам, но я буду иметь в голове продвинутую авторизацию с поддержкой сети и USB токенов.</p>

<ol>
<li>Плоское адресное пространство и защита памяти</li>
</ol>

<p>APBE должен адресовать 32-битное адресное пространство, и поддерживать защиту памяти в плане разделения страниц кода и данных себя и бизнес логики. В переводе на x86 это означает поддержку:</p>

<ul>
<li><p>Защищенного режима (<a href="http://en.wikipedia.org/wiki/Protected_mode">protected mode</a>)</p></li>
<li><p>Страничного режима виртуальной памяти (paging)</p></li>
</ul>

<p>Отдельно о страничном режиме. Речь не идет о поддержки своппинга и расширений виртуальной памяти на физическое хранилище. Пейджинг в данном случае нужен ради одной фичи - разграничения прав на чтение, запись и выполнение данных со страничной гранулярностью. Мы хотим избежать одной из самых тяжело отлаживаемых проблем при работе в реальном режиме - коррапта памяти. Сегментная адресация защищенного режима позволяет указать тип сегмента (код или данные). Однако оперировать целыми сегментами для этого достаточно тяжело. Вместо этого предлагается реализовать простую схему страничной адресации, где виртуальные адреса напрямую отражаются в физические, т.е. виртуальный адрес 0x10000 напрямую отображается в физический адрес 0x10000. Таким образом можно динамически аллоцировать страницы памяти и выставлять для них нужный режим доступа. Любая попытка записи в страницу с кодом приведет к GPF, что нам и нужно вместо молчаливого коррапта.</p>

<ol>
<li>Firmware piggy-backing</li>
</ol>

<p>Мы не хотим писать свои драйвера хостовых дисковых контроллеров, и поэтому хотим оперется на прошивку. В случае BIOS это означает использование ISR реального режима, что влечет за собой некоторые неудобства с прерываниями в защищенном режиме, о которых будет написано ниже в разделе с открытыми задачами.</p>

<ol>
<li>Максимальная тестируемость в user mode.</li>
</ol>

<p>Мы хотим чтобы максимальная часть кода как APBE так и бизнес логики могла быть автоматически тестируемой в обычном пользовательском режиме. Это влечет за собой поддержку PE образов и реализацию hosted окружения, когда код работает внутри за-mock-ченной реализации.</p>

<ol>
<li>Поддержка современным тулчейном.</li>
</ol>

<p>Мы хотим хороший современный компилятор, ассемблер и линкер, потому что MSVC 1.52 бажный. Это влечет за собой генерацию PE/ELF образов, т.е. необходимость их поддержки при выполнении.</p>

<ol>
<li>Поддержка дополнительной аппаратуры.</li>
</ol>

<p>В плане &quot;бизнес логики по умолчанию&quot; это означает поддержку сетевых устройств и USB шины для поддержки токенов, - того чего BIOS скорее всего не поддерживает. Также это влечет за собой поддержку <a href="http://en.wikipedia.org/wiki/Conventional_PCI">PCI</a>.</p>

<h2>Roadmap</h2>

<p>Этап 0: окружение для разработки, запуска и тестирования.</p>

<ul>
<li><p>Настройка тулчейна</p></li>
<li><p>Адаптация кода первоначальной загрузки окружения (загрузчики первой и второй ступени)</p></li>
<li><p>Serial I/O, display, keyboard input</p></li>
<li><p>Загрузка и релокация PE образа.</p></li>
<li><p>PE/COFF &quot;Hello world&quot; в виде полезной нагрузки.</p></li>
</ul>

<p>Оценка: 40 ч/ч</p>

<p>Результат: по окончанию этапа имеем возможность заняться решением задач непосредственно связанных с APBE.</p>

<p>Этап 1: реализация окружения для выполнения кода</p>

<ul>
<li><p>Защищенный режим</p></li>
<li><p>Страничная адресация</p></li>
<li><p>Аллокатор страниц с выставлением прав + юнит тесты с моком.</p></li>
</ul>

<p>Оценка: 60-80 ч/ч</p>

<p>Результат: по окончанию этапа прикладная логика работает в защищенном режиме с 32-битной адресацией и поддержкой защиты памяти. Есть возможность динамически аллоцировать страничную память.</p>

<p>Этап 2: прерывания реального и защищенного режима</p>

<ul>
<li><p>Реализация protected mode ISR и TSS</p></li>
<li><p>Механизм гейт коллов ISR реального режима с восстановлением контекста прерываний.</p></li>
</ul>

<p>Немного про саму проблему. В 8086 real mode работа с прерываниями очень простая. По адресу 0:0 находится таблица векторов прерываний на 256 элементов. Каждый элемент это стандартный segment:offset указатель на ISR соответствующего прерывания. В защищенном режиме все сложнее. Во-первых вместо простой таблицы указателей нужен <a href="http://en.wikipedia.org/wiki/Integrated_Device_Technology">IDT</a>. Во-вторых при включении защищенного режима нужен ремаппинг прерываний, потому что при включенном пейджинге на прерывания 0 - 0x1f накладываются зарезервированные аппаратные исключения процессора. Мы не хотим заниматься реализацией самих ISR, вместо этого мы хотим опереться на то, что нам дает BIOS. Для этого нужен механизм переключения в реальный режим с восстановлением контекста прерываний BIOS и перенаправление прерываний туда.</p>

<p>Оценка: 80 ч/ч</p>

<p>Результат: по окончанию этапа APBE может опираться на BIOS ISR для дискового I/O, печати на дисплей и захвата ввода с клавиатуры, работая при этом в защищенном режиме. Для прерываний, генерируемых не программно (исключения, железо) есть механизм форвардинга между реальным и защищенным режимом.</p>

<p>Этап 3: обход PCI и идентификация устройств.</p>

<ul>
<li><p>Энумерация PCI топологии системы без раздачи дополнительных ресурсов.</p></li>
<li><p>Составление структур данных для описания и управления общими PCI устройствами.</p></li>
</ul>

<p>На этом этапе мы делаем крайне мало полезного :) Тем не менее это необходимо как подготовительный этап для добавления поддержки дополнительных устройств.</p>

<p>Оценка: 40 ч/ч</p>

<p>Результат: достоверный дамп PCI топологии хоста.</p>

<p>Этап 4: интеграция <a href="http://ipxe.org/">iPXE</a></p>

<ul>
<li><p>База данных сетевых устройств и код драйверов iPXE интегрируются в виде библиотеки кода.</p></li>
<li><p>Обход PCI шины расширяется идентификацией сетевых устройств из базы iPXE и навешиванием драйверов.</p></li>
<li><p>Прикладная логика ip4, udp и tcp из iPXE</p></li>
</ul>

<p>Оценка: 160 ч/ч</p>

<p>Результат: поддержка сетевых устройств в APBE на сыром уровне. Поддержка библиотечной прикладной логики стеков ip4, tcp и udp.</p>

<p>Этап 5: USB</p>

<ul>
<li><p>Энумерация <a href="http://en.wikipedia.org/wiki/Host_controller_interface_%28USB%2C_Firewire%29">EHCI</a> контроллеров на PCI, поддержка синхронной энумерации USB эндпоинтов</p></li>
<li><p>Установление сырого канала отправки USB пакетов между хостом и USB эндпоинтом</p></li>
</ul>

<p>Планируется адаптировать код barebones USB из coreboot.</p>

<p>Оценка: 100 ч/ч</p>

<p>Результат: синхронная энумерация USB, общение с USB энпоинтом на сыром уровне.</p>

<p>Этап 6: HAL</p>

<ul>
<li><p>Абстракции сырого доступа к видео памяти фреймбуфером и устройств пользовательского ввода.</p></li>
<li><p>Абстракции дисков.</p></li>
<li><p>Абстракции USB устройств</p></li>
<li><p>Абстракции сетевых сокетов.</p></li>
</ul>

<p>Этот этап заворачивает все поддерживаемые устройства в абстракции для использования прикладным кодом бизнес логики. Речь идет о реализации, чистке и документировании интерфейсов; сами интерфейсы неявно вырабатываются на предыдущих этапах.</p>

<p>Оценка: 80 ч/ч</p>

<p>Результат: APBE готова для поддержки клиентского кода бизнес логики.</p>

<p>Итого: 580-600 часов и куча рисков :)</p>

<h2>Риски</h2>

<p>Перечислены в порядке потенциального влияния на время разработки.</p>

<ol>
<li>Лицензии стороннего кода</li>
</ol>

<p>Многое из того что я видел совместимо с выпуском проприетарного кода. Есть то, чего я не видел :)</p>

<ol>
<li>Ремаппинг прерываний real и protected моде</li>
</ol>

<p>Задача описана на этапе 2. Риск заключается в &quot;нестандартных&quot; настройках прерываний реального режима в BIOS. Тем не менее общее решение вполне возможно.</p>

<ol>
<li>Аллокация PCI ресурсов для дополнительных устройств.</li>
</ol>

<p>Драйвера сетевых устройств и USB контроллеров должны аллоцировать PCI ресурсы для пронумерированных устройств. Возможно будет необходимо добавить арбитрацию для избегания пересечения этих ресурсов с биосом.</p>

<ol>
<li>Синхронный опрос USB эндпоинтов.</li>
</ol>

<p>На данный момент подразумевается синхронный опрос USB контроллера, что означает отсутствие поддержки для вновь добавленных токенов. Решить это предполагается запуском опроса по таймеру с определенной переодичностью. Риск заключается в скорости опроса, которая сильно может повлиять на время отклика системы для пользователя.</p>

<ol>
<li>Сигнализирование о наличии данных от сетевого устройства.</li>
</ol>

<p>Коррелирует с риском о прерываниях и аллоцированием PCI ресурсов. Необходимо обеспечить сетевой интерфейс линией прерывания. Риск заключается в сохранении и восстановлении маппинга прерываний при переходе между реальным и защищенным режимами.</p>

<p>Заключение</p>

<p>На этом история конечно не заканчивается, но предполагается, что остальное (включая UI, Unicode и токены) это область прикладного кода. Каждый этап предполагает максимально тестируемую реализацию и покрытие тестами.</p>

    
    <span class="tags">
      
      <a href="/preboot/">preboot</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/05/25/phd3-write-up/">
        PHD3 write-up
      </a>
    </h1>

    <time datetime="2013-05-25T23:39:08+07:00" class="post-date">25 May 2013</time>

    <p><a href="http://phdays.ru/">http://phdays.ru/</a></p>

<p>Сразу вынужден извинится за отсутствие фотографий - было не до этого</p>

<h3>День 1.</h3>

<h4>Цикл разработки ПО с уклоном в безопасность приложений</h4>

<p>Начал докладчик хорошо, описал проблему, мол вот, безопасники говорят, а девелоперы не понимают. Ok, whatever. Что делать? И тут началась ахинея. Упомянул эзотерический исследовательский проект IBM&#39;s SHADOW (<a href="http://sysrun.haifa.il.ibm.com/shadows/">http://sysrun.haifa.il.ibm.com/shadows/</a>). Самолечащийся софт, чтобы это не значило. Докладчик описал это так, цитирую: &quot;When software detects a vulenerability it inserts a new line of code and moves memory&quot;. Все, точка. Wait what? Тем не менее он дал полезное слово для самостоятельного гугления: SDLC</p>

<h4>Уязвимости реализаций криптографических приложений для платформы Android</h4>

<p>Доклад до боли был похож на один из defcon&#39;вских 2011 года, только хуже. Суть была такова: докладчик тычел пальцами в тупых девелоперов, который в своих андроидовых приложениях оставили пароль в открытом виде в xml файле конфигурации. Смешно, но посмеялись и ладно. Я ожидал большего)</p>

<h4>Загрузка файлов стандартными средствами ОС Windows</h4>

<p>Атакующий имеет возможность заэксплоитить на виндовом хосте уязвимость, которая приведет к выполнению произвольного кода. Как, имея такую возможность, выгрузить на хост файл? Доклад был очень интересный, но в режиме &quot;для своих&quot;. Докладчик почти ничего не пояснял, пропускал очень многое, как &quot;и так понятное&quot;. В результате выглядело все крайне круто, но многое осталось непонятным. Не отрицаю, что это моя проблема на самом деле. Что я запомнил, так это безумный способ заставить хост сделать nslookup, подставить свой dns сервер и сливать с хоста инфу через dns запросы.</p>

<h4>Windows kernel: краткий курс молодого бойца</h4>

<p>4-х часовые практические занятия по WinDBG. Подключали отладчик, лазили по ядру, выполняли интересные упражнения. Потом Был рассказ о security-фичах в ядре, включая нововведения в Windows 8. Это было очень интересно. Последний час мы разбирали код драйвера, в котором автор оставил 4 уязвимости и учились их эксплуатировать. Это мероприятие вытащило для меня весь первый день. Узнал много нового, интересного и нужного.</p>

<h3>День 2.</h3>

<h4>(Не)безопасность средств защиты</h4>

<p>Отличный грамотный, в меру веселый write-up о факапах вендоров решений защиты информации. Я ехал на конференцию во многом узнать как делать софт защищеннее. Во многом именно этот доклад дал наилучший результат для меня.</p>

<h4>Прелюдия к атаке: практика и автоматизация OSINT</h4>

<p>Еще один отличный доклад. Пентестер рассказывал о подготовке к атаке на клиента. Подготовка заключается в data mining&#39;е информации о топологии сети и, самое главное, сотрудниках клиента. Показывал много интересных инструментов для автоматического поиска такой информации в открытых источниках (google, linkedin, facebook) и ее структурирования. Крайне полезная информация, для тех, кто исповедуют &quot;humans are the weakest link&quot;.</p>

<h4>Можно ли защитить секреты в российском суде</h4>

<p>Для меня это был лучший доклад всего мероприятия. Очень грамотный человек очень грамотно рассказывал что такое коммерческая тайна, и на что может рассчитывать от Российских судов организация в случае, если воруют ее секреты (например когда их сливают сотрудники). Информации было крайне много, во многом потому что я ничего об этом не знал ранее. Но суть такова, что нельзя просто назвать что-то коммерческой тайной и начать судить тех, кто по вашему мнению ее ворует. Нужно вводить специальный режим и обеспечивать охрану этой тайны, согласно формально описанным требованиям нашего законодательства. Только в случае соблюдения такого режима в отношении коммерческих секретов можно рассчитывать на помощь суда.</p>

<h4>Система шифрования White-Box</h4>

<p>Выступал докладчик из НГУ Parallels лаборатории. Рассказывал о примитиве ассиметричного шифрования, который они придумали. Я, как и большинство аудитории, мало что понял в 15 минутном потоке слайдов с математикой алгоритма, но сама идея создания и внедрения своих алгоритмов и примитивов кажется очень страшной.</p>

<h4>Кто смотрит на тебя, малыш?</h4>

<p>Доклад был о том, как страшно жить в мире, где твой смартфон постоянно сливает твое местоположение. Вот. Ну и еще они презентовали свою систему слежения за участниками конференции через rfid badge, из которой юзер мог в любой момент выйти.</p>

<h4>iOS Mach-Ports Fuzzing</h4>

<p>А вот это очень интересно. Я долгое время был системным программистом под OS X и знал про mach порты, которые суть низкоуровневый механизм IPC между процессами, сервисами ядра, etc, - все с навешанной системой прав (кто кому может слать сообщения). Ребята выяснили, что доступ к mach портам возможен из песочницы iOS &quot;просто так&quot;. Затем они зафаззили их и получили падения системы в некотором случае, однако у них была цель получить через порт информацию о wifi соединении, что они успешно выполнили. Тем не менее фаззинг портов намекает на уязвимости сервисов, многие из которых работают из под привилегированного пользователя или из ядра. Я решил заняться этой темой самостоятельно, насколько смогу конечно :)</p>

<h3>Итого</h3>

<p>Я хотел понять как разрабатывать софт секьюрно, какие процессы для этого нужно внести в процесс разработки и т.п. Почти все доклады, которые меня заинтересовали в этом плане оказались ни о чем. Зато вместо них я попал на ряд не менее интересных вещей, часть их которых все-таки восполнили нишу.</p>

<p>Зато вторая цель - практика отладки ядра - была выполнена на все сто.</p>

<p>А еще было встречено много интересных людей :)</p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/05/19/d0be-d0bfd0bed0bbd18cd0b7d0b5-uefi-d181d0bfd0b5d186d0b8d184d0b8d0bad0b0d186d0b8d0b8-d0b2-d0bdd0b5-uefi-d0b4d0b5d0b2d0b5d0bbd0bed0bfd0bc/">
        О пользе UEFI спецификации в не-UEFI девелопменте.
      </a>
    </h1>

    <time datetime="2013-05-19T19:04:03+07:00" class="post-date">19 May 2013</time>

    <p>Вообще, если абстрагированно взглянуть на UEFI спеку, то можно использовать ее в качестве готовой документации на контракты интерфейсов различных сервисов пребута. Например, посмотрите на относительно простой протокол SIMPLE_TEXT_OUTPUT_PROTOCOL (11.4). Спецификация явно декларирует такие вещи как в каких ситуация и как производится перевод позиции текстового курсора:</p>

<p>Table 90. EFI Cursor Location/Advance Rules (страница 430)</p>

<p>Mnemonic Unicode Description</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Null     U+0000  Ignore the character, and do not move the cursor.
BS       U+0008  If the cursor is not at the left edge of the display, 
                 then move the cursor left one column.
LF       U+000A  If the cursor is at the bottom of the display, then scroll 
                 the display one row, and do not update the cursor position. 
                 Otherwise, move the cursor down one row.
CR       U+000D  Move the cursor to the beginning of the current row.
Other    U+XXXX  Print the character at the current cursor position 
                 and move the cursor right one column. 
                 If this moves the cursor past the right edge of the display, 
                 then the line should wrap to the beginning of the next line. 
                 This is equivalent to inserting a CR and an LF. 
                 Note that if the cursor is at the bottom of the display, 
                 and the line wraps, then the display will be scrolled one line.
</code></pre></div>
<p>На мой взгляд это отличная готовая спецификация контракта на интерфейс сервиса печати на текстовую консоль в пребуте, UEFI или не UEFI.</p>

    
    <span class="tags">
      
      <a href="/preboot/">preboot</a>
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/05/19/uefi-spec-2-3-1/">
        UEFI 2.3.1 - User Interface Infrastructure
      </a>
    </h1>

    <time datetime="2013-05-19T18:36:25+07:00" class="post-date">19 May 2013</time>

    <p>Выгрузил последнюю спецификацию UEFI API: <a href="https://dl.dropboxusercontent.com/u/42224890/UEFI_Spec_2_3_1.pdf">https://dl.dropboxusercontent.com/u/42224890/UEFI_Spec_2_3_1.pdf</a></p>

<p>Интересные для PBA UI вещи находятся в пунктах 28 и 29. Описывают user interface infrastructure, клавиатурные раскладки, шрифты и формы ввода. Если быстро пробежаться по реализациям этого кода в tianocore, то, на первый взгляд, кажется что они зависят от следующих вещей (цифры указывают на раздел спецификации):</p>

<ol>
<li><p>Simple Text Input protocol - 11.3</p></li>
<li><p>Simple Text Output protocol - 11.4</p></li>
<li><p>Simple Pointer Protocol - 11.5</p></li>
<li><p>Absolute Pointer Protocol - 11.7</p></li>
<li><p>Graphics Output Protocol - 11.9</p></li>
</ol>

<p>Поддержка юникода (UTF16LE) идет через реализацию стандартной библиотеки, т.е. опять же прикладной код, который я правда еще не копал, но думаю что он зависит в основном от менеджера памяти. В результате пока что это все зависимости прикладного кода поддержки UI в уефае которые я нашел. При наличии stdlib с уникодом их достаточно несложно реализовать через BIOS. Самый сложный это пожалуй Absolute Pointer Protocol.</p>

    
    <span class="tags">
      
      <a href="/preboot/">preboot</a>
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/05/17/uefi-capabilities-and-strategy/">
        UEFI capabilities and strategy
      </a>
    </h1>

    <time datetime="2013-05-17T22:04:12+07:00" class="post-date">17 May 2013</time>

    <p>Что может UEFI:</p>

<ol>
<li><p>Сетевые драйвера, дисковые драйвера, USB, драйвера графической консоли.</p></li>
<li><p>UefiToolkit предоставляет прикладную поддержку сетевых проколов (IP, UDP, TFTP, DHCP, TCP), input form UI, unicode, реализацию stdlib и другой прикладной код. Реализован поверх интерфейсов устройств из пункта 1.</p></li>
<li><p>Работа в защищенном режиме с пейджингом в плане защиты памяти</p></li>
<li><p>PE/COFF бинарники, которые можно тестировать в пользовательском режиме.</p></li>
</ol>

<p>Т.е. для реализации MBO нам нужны &quot;только&quot; драйвера токенов. К сожалению, кроме UEFI систем есть еще и legacy BIOS cистемы, и их достаточно много. На этих системах нет почти ничего из описанных интерфейсов, кроме дисков и сырой видео памяти.</p>

<p>Итого мы получаем две платформы: legacy BIOS и UEFI. С точки зрения удобства разработки нам нужна одна платформа, чтобы уменьшить набор тестовых конфигураций и максимально повысить переиспользование кода. Для этого нам нужна платформа, которая выравнивает обе предыдущие. При этом, если ставить во главу угла пользовательский экспириенс, то мы должны обеспечить быструю загрузку PBA и прозрачное продолжение загрузки машины после прохождения PBA.</p>

<p>На UEFI системах мы <em>пока</em> не представляем как обеспечить прозрачное продолжение загрузки кроме как написать нативное UEFI приложение. Попытки выполнить это на BIOS-e пока приводят к смешанным результатам. Поэтому рождается такой вариант:</p>

<ul>
<li><p>Использовать в качестве общей платформы UEFI, в плане спецификации его API.</p></li>
<li><p>В качестве реализации платформы на UEFI системах использовать саму прошивку</p></li>
</ul>

<p>Что делать с legacy BIOS системами? Реализовать требуемый набор UEFI интерфейсов поверх слепленного комка из самого биоса, <a href="http://ipxe.org/">iPXE</a> для поддержки сети и barebones USB (из состава coreboot) для поддержки USB стека.</p>

<p>Таким образом клиентский код PBA написан против UEFI API, вот только на BIOS мы реализуем этот API сами.</p>

<p>Плюсы такого подхода:</p>

<ul>
<li><p>Одна платформа, переиспользование кода</p></li>
<li><p>Нативное UEFI приложение на UEFI системах работает максимально быстро, обеспечивает прозрачную перезагрузку из коробки.</p></li>
<li><p>На BIOS системах можно использовать прикладной код из UEFI toolkit, потому как наша реализация предоставляет необходимые интерфейсы устройств. Это значит что мы получаем прикладной код сетевых протоколов, UI и stdlib.</p></li>
<li><p>Никаких проблем с состоянием аппаратуры на обоих платформах.</p></li>
<li><p>Возможность развернуть инфраструктуру разработки, отладки и автоматической сборки на одной платформе с остальным кодом решения (проще говоря, собирать все на винде и не тянуть линукс).</p></li>
<li><p>Возможность распараллелить разработку. Один девелопер портирует текущий код и пишет новый для UEFI, второй девелопер наращивает Legacy BIOS до нужного подмножества реализации UEFI API</p></li>
</ul>

<p>Минусы:</p>

<ul>
<li><p>Драйвера токенов.</p></li>
<li><p>Обеспечивается поддержка только той аппаратуры что нужна именно на ближайший период, не хватает задела на будущее, особенно для экзотических вещей типа сканеров отпечатков пальцев.</p></li>
<li><p>Нехилая задача по реализации подмножества UEFI спецификации. Однако есть подспорье в виде <a href="http://sourceforge.net/apps/mediawiki/tianocore/index.php?title=DuetPkg">DuetPkg</a> и <a href="http://sourceforge.net/projects/cloverefiboot/">Clover</a></p></li>
</ul>

<p>Если ссумировать сказанное, то на мой взгляд нам так или иначе придется писать нативный UEFI код на UEFI системах, если мы хотим работать без перезагрузки. А если нам придется это делать, то мы в своем роде ограничены сверху именно UEFI. Поэтому почему бы не провести водораздел зависимости нашего кода именно на уровне спецификации UEFI API и доделать то, чего не хватает на legacy BIOS с помощью сторонних библиотек.</p>

<p>Вопрос, что делать с токенами? Ответ: портировать линуксовую юзер модную реализацию libopensc на USB стек пребута.</p>

    
    <span class="tags">
      
      <a href="/BIOS/">BIOS</a>
      
      <a href="/preboot/">preboot</a>
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    </div>

    <div class="pagination">
      
      <a class="pagination-item older" href="/page6">Older</a>
      
      
      
      <a class="pagination-item newer" href="/page4">Newer</a>
      
      
    </div>

  </div>
      
  <div class="sidebar">
    <ul class="post-list">
      
      <!-- a style="font-size: 220%" href="/BIOS/">BIOS</a -->
      <li><a href="/BIOS/">BIOS</a></li>
      
      <!-- a style="font-size: 120%" href="/device state/">device state</a -->
      <li><a href="/device state/">device state</a></li>
      
      <!-- a style="font-size: 303%" href="/preboot/">preboot</a -->
      <li><a href="/preboot/">preboot</a></li>
      
      <!-- a style="font-size: 370%" href="/UEFI/">UEFI</a -->
      <li><a href="/UEFI/">UEFI</a></li>
      
      <!-- a style="font-size: 120%" href="/crypto/">crypto</a -->
      <li><a href="/crypto/">crypto</a></li>
      
      <!-- a style="font-size: 236%" href="/doom-uefi/">doom-uefi</a -->
      <li><a href="/doom-uefi/">doom-uefi</a></li>
      
    </ul>
  </div>

</div>



      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2015-01-28T22:56:05+06:00">2015</time>. All rights reserved.
        </small>
      </footer>

    </div>

  </body>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-59069328-1', 'auto');
            ga('send', 'pageview');

            </script>

</html>
