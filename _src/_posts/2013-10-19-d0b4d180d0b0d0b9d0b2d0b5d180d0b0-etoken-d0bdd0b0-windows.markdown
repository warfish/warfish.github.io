---
author: wrfsh
comments: true
date: 2013-10-19 11:49:35+00:00
layout: post
slug: '%d0%b4%d1%80%d0%b0%d0%b9%d0%b2%d0%b5%d1%80%d0%b0-etoken-%d0%bd%d0%b0-windows'
title: Драйвера eToken на Windows
wordpress_id: 273
tags:
- crazy ideas
---

Я немного посмотрел устройство всего стека eToken на винде и вот что получилось:



	
  1. Центральный модуль в их архитектуре это **Windows\system32\eToken.dll**. Этот модуль экспортирует наружу реализацию pkcs#11. Неясно насколько много в нем реализации pkcs#11, но кода много.

	
  2. Сам eToken.dll требует ряд импортов, в основном стандартные kernel32.dll, user32.dll, etc. Еще ему нужен winscard.dll, импорты которого регулярно просвечиваются по дереву вызовов pkcs#11 реализации.

	
  3. В комплекте идут 2 драйвера:




	
    * aksup.sys - класс USB. В inf файле замечены VendorID/DeviceID алладиновских устройств

	
    * aksifdh.sys - класс SmartCardReader. Подозреваю что это плагин winscard API для интерфейса ридера. Зависит от первого драйвера.



Итого складывается такая картина. Ядреное присутствие eToken ограничивается USB устройством и плагином для winscard, а то что я подозреваю реализацией pkcs#11 - eToken.dll - опирается на winscard.dll.

Отсюда идеи. Предположим, что мы хотим использовать eToken.dll как есть в пребуте. Тогда нам нужны импорты для него. Есть шелуха типа kernel32.dll, user32.dll, которую, думаю, можно разрулить (что-то уже разрулено). И есть winscard.dll. Такой ли это громадный монстр? Оказывается нет : [http://www.smartcard-magic.net/en/pc-sc-reader/winscard-api-c-c/](http://www.smartcard-magic.net/en/pc-sc-reader/winscard-api-c-c/), [http://msdn.microsoft.com/en-us/library/windows/desktop/aa380142(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/aa380142(v=vs.85).aspx)

Тут нужно небольшое пояснение. Токен это формфактор смарткарты, объединяющий ридер и карту. Есть интерфейс ридера, а есть интерфейс карты. Интерфейс ридера это winscard при поддержке драйверов etoken, которые, как мы уже знаем, общаются с Siemens CardOS внутри девайса. При этом протокол общения открыт и реализован в OpenCT. Поэтому в принципе winscard API можно реализовать используя драйвера из OpenCT / PCSC-lite / etc. Т.е. получается, _что нам не нужны закрытые бинарные драйвера ридера eToken._ У нас есть свои.

Реализация winscard API есть, например, у эппла: [http://www.opensource.apple.com/source/SmartCardServices/SmartCardServices-34733/src/PCSC/winscard.c](http://www.opensource.apple.com/source/SmartCardServices/SmartCardServices-34733/src/PCSC/winscard.c). Я думаю ее можно найти в реактосе. И скорее всего в RTOS-32: [http://www.on-time.com/rtos-32.htm](http://www.on-time.com/rtos-32.htm). Последнее правда за деньги, но я хочу немного на RTOS-32 остановится в этом контексте. Мы знаем, что у McAfee, который поддерживает токены, используется именно он в пребуте на биосе. Мы также знаем что у них недавно появилась поддержка EFI, где тоже есть токены. В таком разрезе кажется очень вероятным что они для поддержки токенов на EFI портировали какие-то куски из RTOS-32 и если там есть реализация winscard API, то я почти уверен что они портировали именно его.  Это можно выяснить наверняка, но главное то, что если я прав, то реализацию winscard можно _купить_.

Ок, с ридером разобрались. Интерфейс карты проприетарный с закрытыми форматами, где его взять? В eToken.dll, для которой мы уже разобрались с ридером через winscard :)

Такой подход сулит ряд бенефитов:



	
  * Если все производители идут примерно таким же путем, то подход хорошо скалируется.

	
  * Конкретно по eToken - нам не нужны их драйвера, потому что мы сами реализуем winscard поверх тех драйверов ридеров, что есть в OpenCT / PCSC-lite.


Мне не понятна трудоемкость и надежность такого решения. Мне не понятна легальная сторона - можем ли мы использовать чужие бинарные модули вот так? Но мне крайне интересно попробовать, потому что потенциально это сулит более менее легкую поддержку большого числа устройств.
