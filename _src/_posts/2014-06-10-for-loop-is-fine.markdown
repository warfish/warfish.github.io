---
author: wrfsh
comments: true
date: 2014-06-10 17:00:53+00:00
layout: post
slug: for-loop-is-fine
title: For loop is fine
wordpress_id: 399
---

Часто приходится писать такой код:


<blockquote>

>     
>     void ProcessAll(element_t* elements, size_t total)
>     {
>         for (size_t i = 0; i < total; ++i)
>         {
>             ProcessElement(elements[i]);
>         }
>     }
> 
> 
</blockquote>


So far so good. Но затем нужно обычно написать еще нечто вроде:


<blockquote>

>     
>     void PrintAll(element_t* elements, size_t total)
>     {
>         for (size_t i = 0; i < total; ++i)
>         {
>             PrintElement(elements[i]);
>         }
>     }
> 
> 
</blockquote>


И тут срабатывает инстинкт "где-то я это уже видел", и, вспоминая какой-нибудь SICP, хочется выделить итерацию отдельно и написать:


<blockquote>

>     
>     void ForEachElement(element_t* elements, size_t total, 
>                         ElementCallbackFptr callback, void* context)
> 
> 

>     
>     {
>         for (size_t i = 0; i < total; ++i)
>         {
>             callback(elements[i], context);
>         }
>     }
> 
> 
</blockquote>


И начать переписывать ProcessAll и PrintAll через ForEachElement + callback собирая со стека весь контекст в context.
Такой код выглядит красиво, общее абстрагировано, частное параметризировано.

Но затем такой код нужно читать кому-то другому, обязательно под дедлайном с целью быстро найти и исправить баг. И тут у читающего начинаются проблемы:



	
  1. Итерация визуально отделена от обработки каждого элемента.
Callback отдельная функция, а не код внутри цикла и визуально он вынесен из скоупа цикла. Приходится прыгать по файлу с целью найти функцию обработки каждого элемента, помнить какая реализация callback соответствует какому из вызовов ForEachElement. Это не дает читающему видеть весь контекст алгоритма сразу, а держать в голове дополнительный контекст и вспоминать его заново каждый раз.

	
  2. void* context в лучшем случае структура, специфичная для каждой реализации callback (в худшем абстрактный интерфейс).
В эту структуру как правило со стека рядом с вызовом ForEachElement упаковываются параметры. Читающему нужно помнить еще один контекст - какой параметр куда присвоен в структуре и чему соответствует на самом деле в реализации callback.

	
  3. Порог вхождения в то как автор называет итерацию.
Цикл for в типичном виде парсится более-менее опытным кодером за один проход. Он не вчитывается в символы, не выясняет их значения, а сразу видит семантику - автор проходит по всем элементам. For это базовая конструкция языка понятная всем. В случае когда автор выделил итерацию отдельно появляется порог вхождения - как именно автор назвал свой аккуратно вырезанный for - ForEach, Enumerate, Walk? Можно сказать, что поняв это один раз можно уже не напрягаться в следующий, но ведь for понимать не надо и в самый первый раз и во все последующие. К тому же код редко читается как книга, в основном читается одна функция за раз с целью найти проблему. Если систему делают несколько авторов, каждый из которых делает свою итерацию, то за одним ForEach следует другой Enumerate уже от другого автора и порог вхождения начинает расти.


В итоге абстрагировать простейший цикл for может и выглядит красиво при написании кода, но создает только проблемы тому, кто хочет разобраться что происходит.
Если итерация не простая? Я стараюсь в таком случае делать код "максимально совместимым" с for делая для своих элементов First(), Next() и End().


