---
author: wrfsh
comments: true
date: 2013-05-27 15:58:10+00:00
layout: post
slug: '%d1%81%d0%ba%d0%be%d0%bb%d1%8c%d0%ba%d0%be-%d1%81%d1%82%d0%be%d0%b8%d1%82-advanced-preboot-environment-%d1%81%d0%b2%d0%be%d0%b8%d0%bc%d0%b8-%d1%80%d1%83%d0%ba%d0%b0%d0%bc%d0%b8'
title: Сколько стоит Advanced Preboot Environment своими руками.
wordpress_id: 85
tags:
- preboot
---

Ниже идет грубая оценка на реализацию Advanced Preboot Environment (APBE), написанную своими руками и опирающуюся на BIOS там где это возможно, а именно в драйверах дисплея, серийного порта и дисков.


## 




## Требования.


APBE это платформа для "интересной" бизнес логики, работающей до загрузки ОС. Понятия интересного каждый определяет сам, но я буду иметь в голове продвинутую авторизацию с поддержкой сети и USB токенов.



1. Плоское адресное пространство и защита памяти

APBE должен адресовать 32-битное адресное пространство, и поддерживать защиту памяти в плане разделения страниц кода и данных себя и бизнес логики. В переводе на x86 это означает поддержку:



	
  * Защищенного режима ([protected mode](http://en.wikipedia.org/wiki/Protected_mode))

	
  * Страничного режима виртуальной памяти (paging)


Отдельно о страничном режиме. Речь не идет о поддержки своппинга и расширений виртуальной памяти на физическое хранилище. Пейджинг в данном случае нужен ради одной фичи - разграничения прав на чтение, запись и выполнение данных со страничной гранулярностью. Мы хотим избежать одной из самых тяжело отлаживаемых проблем при работе в реальном режиме - коррапта памяти. Сегментная адресация защищенного режима позволяет указать тип сегмента (код или данные). Однако оперировать целыми сегментами для этого достаточно тяжело. Вместо этого предлагается реализовать простую схему страничной адресации, где виртуальные адреса напрямую отражаются в физические, т.е. виртуальный адрес 0x10000 напрямую отображается в физический адрес 0x10000. Таким образом можно динамически аллоцировать страницы памяти и выставлять для них нужный режим доступа. Любая попытка записи в страницу с кодом приведет к GPF, что нам и нужно вместо молчаливого коррапта.



2. Firmware piggy-backing

Мы не хотим писать свои драйвера хостовых дисковых контроллеров, и поэтому хотим оперется на прошивку. В случае BIOS это означает использование ISR реального режима, что влечет за собой некоторые неудобства с прерываниями в защищенном режиме, о которых будет написано ниже в разделе с открытыми задачами.



3. Максимальная тестируемость в user mode.

Мы хотим чтобы максимальная часть кода как APBE так и бизнес логики могла быть автоматически тестируемой в обычном пользовательском режиме. Это влечет за собой поддержку PE образов и реализацию hosted окружения, когда код работает внутри за-mock-ченной реализации.



4. Поддержка современным тулчейном.

Мы хотим хороший современный компилятор, ассемблер и линкер, потому что MSVC 1.52 бажный. Это влечет за собой генерацию PE/ELF образов, т.е. необходимость их поддержки при выполнении.



5. Поддержка дополнительной аппаратуры.

В плане "бизнес логики по умолчанию" это означает поддержку сетевых устройств и USB шины для поддержки токенов, - того чего BIOS скорее всего не поддерживает. Также это влечет за собой поддержку [PCI](http://en.wikipedia.org/wiki/Conventional_PCI).


## 




## Roadmap


Этап 0: окружение для разработки, запуска и тестирования.



	
  * Настройка тулчейна

	
  * Адаптация кода первоначальной загрузки окружения (загрузчики первой и второй ступени)

	
  * Serial I/O, display, keyboard input

	
  * Загрузка и релокация PE образа.

	
  * PE/COFF "Hello world" в виде полезной нагрузки.


Оценка: 40 ч/ч

Результат: по окончанию этапа имеем возможность заняться решением задач непосредственно связанных с APBE.



Этап 1: реализация окружения для выполнения кода



	
  * Защищенный режим

	
  * Страничная адресация

	
  * Аллокатор страниц с выставлением прав + юнит тесты с моком.


Оценка: 60-80 ч/ч

Результат: по окончанию этапа прикладная логика работает в защищенном режиме с 32-битной адресацией и поддержкой защиты памяти. Есть возможность динамически аллоцировать страничную память.



Этап 2: прерывания реального и защищенного режима



	
  * Реализация protected mode ISR и TSS

	
  * Механизм гейт коллов ISR реального режима с восстановлением контекста прерываний.


Немного про саму проблему. В 8086 real mode работа с прерываниями очень простая. По адресу 0:0 находится таблица векторов прерываний на 256 элементов. Каждый элемент это стандартный segment:offset указатель на ISR соответствующего прерывания. В защищенном режиме все сложнее. Во-первых вместо простой таблицы указателей нужен [IDT](http://en.wikipedia.org/wiki/Integrated_Device_Technology). Во-вторых при включении защищенного режима нужен ремаппинг прерываний, потому что при включенном пейджинге на прерывания 0 - 0x1f накладываются зарезервированные аппаратные исключения процессора. Мы не хотим заниматься реализацией самих ISR, вместо этого мы хотим опереться на то, что нам дает BIOS. Для этого нужен механизм переключения в реальный режим с восстановлением контекста прерываний BIOS и перенаправление прерываний туда.

Оценка: 80 ч/ч

Результат: по окончанию этапа APBE может опираться на BIOS ISR для дискового I/O, печати на дисплей и захвата ввода с клавиатуры, работая при этом в защищенном режиме. Для прерываний, генерируемых не программно (исключения, железо) есть механизм форвардинга между реальным и защищенным режимом.



Этап 3: обход PCI и идентификация устройств.



	
  * Энумерация PCI топологии системы без раздачи дополнительных ресурсов.

	
  * Составление структур данных для описания и управления общими PCI устройствами.


На этом этапе мы делаем крайне мало полезного :) Тем не менее это необходимо как подготовительный этап для добавления поддержки дополнительных устройств.

Оценка: 40 ч/ч

Результат: достоверный дамп PCI топологии хоста.



Этап 4: интеграция [iPXE](http://ipxe.org/)



	
  * База данных сетевых устройств и код драйверов iPXE интегрируются в виде библиотеки кода.

	
  * Обход PCI шины расширяется идентификацией сетевых устройств из базы iPXE и навешиванием драйверов.

	
  * Прикладная логика ip4, udp и tcp из iPXE


Оценка: 160 ч/ч

Результат: поддержка сетевых устройств в APBE на сыром уровне. Поддержка библиотечной прикладной логики стеков ip4, tcp и udp.



Этап 5: USB



	
  * Энумерация [EHCI](http://en.wikipedia.org/wiki/Host_controller_interface_%28USB%2C_Firewire%29) контроллеров на PCI, поддержка синхронной энумерации USB эндпоинтов

	
  * Установление сырого канала отправки USB пакетов между хостом и USB эндпоинтом


Планируется адаптировать код barebones USB из coreboot.

Оценка: 100 ч/ч

Результат: синхронная энумерация USB, общение с USB энпоинтом на сыром уровне.



Этап 6: HAL



	
  * Абстракции сырого доступа к видео памяти фреймбуфером и устройств пользовательского ввода.

	
  * Абстракции дисков.

	
  * Абстракции USB устройств

	
  * Абстракции сетевых сокетов.


Этот этап заворачивает все поддерживаемые устройства в абстракции для использования прикладным кодом бизнес логики. Речь идет о реализации, чистке и документировании интерфейсов; сами интерфейсы неявно вырабатываются на предыдущих этапах.

Оценка: 80 ч/ч

Результат: APBE готова для поддержки клиентского кода бизнес логики.



Итого: 580-600 часов и куча рисков :)




## Риски


Перечислены в порядке потенциального влияния на время разработки.



1. Лицензии стороннего кода

Многое из того что я видел совместимо с выпуском проприетарного кода. Есть то, чего я не видел :)



2. Ремаппинг прерываний real и protected моде

Задача описана на этапе 2. Риск заключается в "нестандартных" настройках прерываний реального режима в BIOS. Тем не менее общее решение вполне возможно.



3. Аллокация PCI ресурсов для дополнительных устройств.

Драйвера сетевых устройств и USB контроллеров должны аллоцировать PCI ресурсы для пронумерированных устройств. Возможно будет необходимо добавить арбитрацию для избегания пересечения этих ресурсов с биосом.



4. Синхронный опрос USB эндпоинтов.

На данный момент подразумевается синхронный опрос USB контроллера, что означает отсутствие поддержки для вновь добавленных токенов. Решить это предполагается запуском опроса по таймеру с определенной переодичностью. Риск заключается в скорости опроса, которая сильно может повлиять на время отклика системы для пользователя.



5. Сигнализирование о наличии данных от сетевого устройства.

Коррелирует с риском о прерываниях и аллоцированием PCI ресурсов. Необходимо обеспечить сетевой интерфейс линией прерывания. Риск заключается в сохранении и восстановлении маппинга прерываний при переходе между реальным и защищенным режимами.



Заключение

На этом история конечно не заканчивается, но предполагается, что остальное (включая UI, Unicode и токены) это область прикладного кода. Каждый этап предполагает максимально тестируемую реализацию и покрытие тестами.
