<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      My worklog &middot; My worklog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.png">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="My worklog" href="/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h2 class="masthead-title">
          <a href="/" title="Home">My worklog</a>
          <small><a href="https://github.com/warfish">GitHub</a></small>
          <small><a href="/archive/">Archive</a></small>
        </h3>
      </header>

      <main>
        <div class="wrapper">
  <div class="center">

    <div class="posts">
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/07/05/d0b2d0b5d180d0b4d0b8d0bad182-d0bfd0be-opensc/">
        Вердикт по OpenSC
      </a>
    </h1>

    <time datetime="2013-07-05T22:23:45+07:00" class="post-date">05 Jul 2013</time>

    <p>Если коротко, то криптографический токен можно поддержать &quot;из коробки&quot; портированной связкой opensc/openct при выполнении следующих условий:</p>

<ol>
<li><p>Аутентификационные данные и прочие объекты, расположенные на токене, поддерживают стандарт PKCS#15</p></li>
<li><p>OpenSC/OpenCT предоставляет драйвер ридера этого токена, который знает APDU протокол этого устройства.</p></li>
</ol>

<p>А как же PKCS#11? Дело в том, что реализация PKCS#11 в OpenSC опирается на PKCS#15 с одной стороны и драйвер ридера токена с другой. Так что если для конкретного устройства выполняются два условия выше, то PKCS#11 должен &quot;просто работать&quot;.</p>

<p>Что же было не так с eToken? Возникла теория, которую я решил проверить напрямую и она подтвердилась. Дело в том, что eToken не поддерживает PKCS#15. Функция <a href="https://github.com/OpenSC/OpenSC/blob/master/src/pkcs11/pkcs11-session.c#L233">C_Login</a> в реализации PKCS#11 в OpenSC <a href="https://github.com/OpenSC/OpenSC/blob/master/src/pkcs11/pkcs11-session.c#L284">опирается </a>как раз на PKCS#15, конкретнее на функцию <a href="https://github.com/OpenSC/OpenSC/blob/master/src/pkcs11/framework-pkcs15.c#L1332">pkcs15_login</a>. Которая не работает, потому что аутентификационные данные на eToken не поддерживают этот формат.</p>

<p>Если вернутся к условиям в начале поста, то я уверен, что OpenSC удачное решение. Оно не дает 100% покрытия, но на мой взгляд eToken скорее исключение нежели чем правило. Исключение которое нам по силам победить даже в худшем случае. ;)</p>

<p>Стратегии победы включают в себя портирование их бинарных сборок на UEFI и/или реверсинг с технической стороны и переговоры с вендором с политической.</p>

    
    <span class="tags">
      
      <a href="/crypto/">crypto</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/07/02/uefi-emulation-edkduet-is-a-moderate-success/">
        [UEFI Emulation] EDK/Duet is a moderate success
      </a>
    </h1>

    <time datetime="2013-07-02T23:11:23+07:00" class="post-date">02 Jul 2013</time>

    <p>Прототипирование UEFI эмуляции на базе EDK/Duet можно считать законченным. Я считаю результат умеренным успехом. Успехом потому что такой подход действительно позволяет поставить знак равенства между Legacy BIOS и UEFI системами на том уровне поддержки аппаратуры, что нам нужен. А умеренным потому что, несмотря на знак равенства, возможности самого UEFI, будь то native или эмуляция, оставляют за нами массу прикладной работы по поддержке локализации, ввода национальных символов и двух факторной авторизации. Глупо было ожидать обратного. :)</p>

<p>Если сконцентрироваться на хорошем, то UEFI, по сравнению с &quot;голым&quot; PBA дает:</p>

<ul>
<li><p>Защиту памяти и полную адресацию. Коррапты памяти раньше происходили тихо и незаметно. Теперь такие баги генерируют GPF.</p></li>
<li><p>Поддержку современных тулчейнов, включая тот, что используется для остального проекта. Использование MSVC 1.52 можно свести к минимуму, а значит и его баги тоже (а они есть).</p></li>
<li><p>Графический фреймбуфер и рендер растровых юникодных шрифтов.</p></li>
<li><p>Работающий USB и PCI стек.</p></li>
<li><p>Достаточный контроль состояния аппаратуры.</p></li>
<li><p>Модульность, взаимозаменяемость драйверов через повсеместную абстракцию протоколами. Это очень важно для эмуляции, потому что дает возможность заменить реализацию например графического дисплея на свою, работающую через BIOS.</p></li>
<li><p>Поддержка source-level отладки.</p></li>
<li><p>Стеки сетевых протоколов.</p></li>
<li><p>libc</p></li>
</ul>

<p>Из &quot;умеренного&quot;:</p>

<ul>
<li><p>Поддержка ввода национальных символов совсем базовая. Раскладки нужно генерировать самостоятельно. Если для европейских языков все терпимо, то для азиатских и арабских выглядит довольно сложно, хотя и не невозможно.</p></li>
<li><p>Драйвера крипто токенов. Их либо нет, либо они в непонятно каком состоянии в опенсорсных либах, либо нужно начинать говорить с вендорами токенов.</p></li>
<li><p>Нет полноценного GUI фреймворка &quot;из коробки&quot;. Есть все необходимые базовые технологические стеки для его реализации/портирования, типа фреймбуфера, драйверов устройств ввода и т.д, но нет самих примитивов, из которых строится GUI.</p></li>
</ul>

<p>Если ссумировать, то UEFI предоставляет всю базу, чтобы реализовать прикладные задачи, но не больше этого. Реализовать все остальное можно используя нормальный компилятор, отладчик, защиту памяти, снятие множества ограничений по ресурсам и т.д. EDK/Duet выравнивает BIOS до этого же уровня, что экономит наверное год работы и дает унифицирование платформы на поддерживаемых аппаратных конфигурациях. Но при этом все, что выходит за рамки базовой платформы, нужно делать/портировать почти самостоятельно, и, хочу еще раз подчеркнуть, это касается UEFI в целом, а не только его эмуляции. Приятное исключение это рендер шрифтов :)</p>

    
    <span class="tags">
      
      <a href="/BIOS/">BIOS</a>
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/06/30/libusb-porting-tips/">
        libusb porting tips
      </a>
    </h1>

    <time datetime="2013-06-30T01:10:57+07:00" class="post-date">30 Jun 2013</time>

    <p>From <a href="http://www.libusb.org/wiki/libusb-1.0">http://www.libusb.org/wiki/libusb-1.0</a></p>

<blockquote>[libusb](http://www.libusb.org/)-1.0 includes a platform abstraction layer allowing for cross-platform compatibility. Linux, Darwin (Mac OS X), Windows, OpenBSD and NetBSD are supported in the latest release.

FreeBSD 8 and above include a FreeBSD-specific reimplementation of the libusb-1.0 API, so your applications will probably work there too. The source code for this library can be found [​here](http://svn.freebsd.org/viewvc/base/head/lib/libusb/).

If you are interested in porting to other platforms, the [PORTING](http://git.libusb.org/?p=libusb.git;a=blob;f=PORTING;h=7070784d04761562e38208d9d2fa4c2460eefc30;hb=ab9cd5a7be637f7b793987971a706b1d11c27ded;js=1) file tells you where to start. We are more than happy to help out here, please write to the mailing list with your questions and feedback.</blockquote>

<p>From <a href="http://git.libusb.org/?p=libusb.git;a=blob;f=PORTING;h=7070784d04761562e38208d9d2fa4c2460eefc30;hb=ab9cd5a7be637f7b793987971a706b1d11c27ded;js=1">PORTING</a>:</p>

<blockquote>

> 
> Implementation-wise, the basic idea is that you provide an interface to
> 
> 

> 
> libusb's internal "backend" API, which performs the appropriate operations on
> 
> 

> 
> your target platform.
> 
> 

> 
> 

> 
> In terms of USB I/O, your backend provides functionality to submit
> 
> 

> 
> asynchronous transfers (synchronous transfers are implemented in the higher
> 
> 

> 
> layers, based on the async interface). Your backend must also provide
> 
> 

> 
> functionality to cancel those transfers.
> 
> 

> 
> 

> 
> Your backend must also provide an event handling function to "reap" ongoing
> 
> 

> 
> transfers and process their results.
> 
> 

> 
> 

> 
> The backend must also provide standard functions for other USB operations,
> 
> 

> 
> e.g. setting configuration, obtaining descriptors, etc.
> 
> 

> 
> </blockquote>

<p>Existing libusb ports are found in <a href="http://git.libusb.org/?p=libusb.git;a=tree;f=libusb/os;h=1ec9613c0fc4facf6e9217af4130f02387e2b470;hb=7634714aa696175b08016b6f2185a75a2f55a113;js=1">libusb/os folder</a></p>

<p>libusbi.h contains a very well documented interface that should be implemented on a new platform: <a href="http://git.libusb.org/?p=libusb.git;a=blob;f=libusb/libusbi.h;h=3b602d28ca4cae7577bcdcabddccaeb04c0a79cb;hb=7634714aa696175b08016b6f2185a75a2f55a113;js=1#l468">usbi<em>os</em>backend</a></p>

    
    <span class="tags">
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/06/28/opensc-uefi/">
        OpenSC / UEFI
      </a>
    </h1>

    <time datetime="2013-06-28T22:33:05+07:00" class="post-date">28 Jun 2013</time>

    <p>Чтобы портировать связку libopensc/libopenct нужно:</p>

<ol>
<li><p>Затащить StdLib. В EDK есть реализация: <a href="http://sourceforge.net/p/tianocore/edk2/ci/master/tree/StdLib/">http://sourceforge.net/p/tianocore/edk2/ci/master/tree/StdLib/</a>. Есть небольшое неудобство - ванильная реализация StdLib в EDK линкуется только с UEFI<em>APPLICATION (а не DXE</em>DRIVER). Поэтому PBA <em>везде</em> должен быть аппликейшеном. Либо можно распилить StdLib на части и копилировать сишники. Тоже вариант.</p></li>
<li><p>Написать реализацию функций ifd<em>sysdep</em>usb_* в OpenCT. Вот пример порта на <a href="http://www.libusb.org/">libusb</a>/Linux: <a href="https://github.com/OpenSC/openct/blob/master/src/ifd/sys-linux.c">https://github.com/OpenSC/openct/blob/master/src/ifd/sys-linux.c</a>.</p></li>
<li><p>Вытравить зависимости от файловой системы в вспомогательном коде OpenCT. Например у него есть конфиг, который он при инициализации парсит из файла и т.д.</p></li>
<li><p>Выкинуть все &quot;ненужное&quot;. Например общение с токенами по серийному порту.</p></li>
</ol>

<p>Вместо пункта 2 (порт ifd<em>sysdep</em>usb_*) можно подойти к вопросу фундаментальнее - портировать libusb. Эта либа своего рода стандартный API доступа к USB устройствам на линуксе. На нее портировано много всего, включая OpenCT. Если портануть ее, то это дает гибкость, можно не портировать USB стек второй раз в какой-нибудь другой либе. Но это медленнее, потому что libusb больше.</p>

    
    <span class="tags">
      
      <a href="/crypto/">crypto</a>
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/06/27/opensc/">
        OpenSC
      </a>
    </h1>

    <time datetime="2013-06-27T21:09:26+07:00" class="post-date">27 Jun 2013</time>

    <p>Смотрю на <a href="https://github.com/OpenSC/OpenSC">OpenSC </a> - библиотеку драйверов смарт карт и токенов. Наблюдаю интересные вещи. Сама либа не содержит вообще почти никаких платформенных зависимостей, не читает USB. Вместо этого похоже что она абстрагирует конкретный бекенд ридера карт и токенов через <a href="https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/opensc.h#L284">sc_reader</a> и реализует адаптеры на три backend-а:</p>

<ul>
<li><p><a href="http://en.wikipedia.org/wiki/CT-API">CT-API</a> - <a href="https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/reader-ctapi.c">https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/reader-ctapi.c</a></p></li>
<li><p><a href="http://en.wikipedia.org/wiki/PC/SC">PC/SC</a> -  <a href="https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/reader-pcsc.c">https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/reader-pcsc.c</a></p></li>
<li><p><a href="https://github.com/OpenSC/openct">OpenCT</a> - <a href="https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/reader-openct.c">https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/reader-openct.c</a></p></li>
</ul>

<p>Больше инфы по каждому варианту можно найти в вики проекта: <a href="https://github.com/OpenSC/OpenSC/wiki/Creating-applications-with-smart-card-support#low-level-smart-card-access">https://github.com/OpenSC/OpenSC/wiki/Creating-applications-with-smart-card-support#low-level-smart-card-access</a></p>

<p>Все трое это внешние для OpenSC реализации, которые она адаптирует через сишный вариант полиморфизма в <a href="https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/opensc.h#L419">sc<em>reader</em>operations</a>. Я кстати очень люблю такой Pure C полиморфизм, но щас не об этом. Подход должен быть знаком сразу всем, кто писал драйвера для линуксового ядра.</p>

<p>Так или иначе, по моему не самому глубокому 30-ти минутному вниканию я делаю вывод, что портировать на UEFI нужно будет реализацию одного из трех вариантов выше, а не самой OpenSC. У конкурентов на линуксе я почти всегда видел пару libopensc/libopenct, так что вот.</p>

<p>Драйвер для eToken PRO находится здесь:<a href="https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/card-cardos.c">https://github.com/OpenSC/OpenSC/blob/master/src/libopensc/card-cardos.c</a></p>

<p>Generic USB слой:<a href="https://github.com/OpenSC/openct/blob/master/src/ifd/usb.c">https://github.com/OpenSC/openct/blob/master/src/ifd/usb.c</a>
Опирается на платформенно-зависимые ifd<em>sysdep</em>usb_*. Реализация для линукса:<a href="https://github.com/OpenSC/openct/blob/master/src/ifd/sys-linux.c">https://github.com/OpenSC/openct/blob/master/src/ifd/sys-linux.c</a></p>

    
    <span class="tags">
      
      <a href="/crypto/">crypto</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/06/25/uefi-emulation-localized-input-and-output/">
        [UEFI Emulation] Localized input and output
      </a>
    </h1>

    <time datetime="2013-06-25T22:35:11+07:00" class="post-date">25 Jun 2013</time>

    <p>Следующая цель прототипирования: локализованный ввод и вывод. Мы хотим, чтобы пользователь мог ввести свой логин и пароль на своем родном языке и чтобы мы могли локализовать ему пребут. Это означает, что нам нужна поддержка:</p>

<ul>
<li><p>Юникодных строк и их рендеринга на графический дисплей.</p></li>
<li><p>Клавиатурных раскладок с маппингом на юникодные символы.</p></li>
</ul>

<p>Что на данный момент удалось получить от EDK/Duet.</p>

<p>Сначала о выводе юникода на экран. Вообще весь UEFI и EDK юникодные (UTF16). Для вывода юникодных строк на дисплей UEFI предоставляет описание шрифта: <a href="http://wiki.phoenix.com/wiki/index.php/EFI_HII_SIMPLE_FONT_PACKAGE_HDR">http://wiki.phoenix.com/wiki/index.php/EFI<em>HII</em>SIMPLE<em>FONT</em>PACKAGE_HDR</a>. Это по сути таблица маппинга UTF16 кода символа на глиф размером либо 9x19 либо 16x19 пикселей. EDK предоставляет драйвер графической консоли, который учитывает наборы этих шрифтов и рендерит каждый символ в UTF16 строке согласно ее глифу, учитывая переносы строк, слияние границ символов и т.д. И это достаточно много очень противного кода.</p>

<p>Модель для разработчика получается такая: чтобы поддержать печать текста например на русском языке надо изготовить таблицу глифов для каждого UTF16 символа этого языка, загрузить ее в рантайме и автомагически вся печать на дисплей будет работать. Есть также более продвинутое описание шрифтов, не привязанное к размеру глифа: <a href="http://wiki.phoenix.com/wiki/index.php/EFI_HII_FONT_PACKAGE_HDR">http://wiki.phoenix.com/wiki/index.php/EFI<em>HII</em>FONT<em>PACKAGE</em>HDR</a>.</p>

<p>Никто не запрещает поступить как grub2 - сделать большой шрифт со всеми нужными языками в одном пакете и грузить его целиком. Никто не запрещает взять векторный шрифт и отрендерить его в нужно размере получив таким образом растр. В общем с этой стороны поддержку можно считать достаточной.</p>

<p>Теперь о вводе. UEFI предоставляет в том же пакете HII (Human Interface Infrastructure) еще один тип ресурсов - клавиатурные раскладки: <a href="http://wiki.phoenix.com/wiki/index.php/EFI_HII_KEYBOARD_LAYOUT">http://wiki.phoenix.com/wiki/index.php/EFI<em>HII</em>KEYBOARD_LAYOUT</a>. Раскладка это таблица маппинга скан кода на UTF16 код символа + флаги: <a href="http://wiki.phoenix.com/wiki/index.php/EFI_KEY_DESCRIPTOR">http://wiki.phoenix.com/wiki/index.php/EFI<em>KEY</em>DESCRIPTOR</a>. Здесь маппинг уже не такой прямой как в случае со шрифтами. В поле атрибутов можно указать ряд флагов, а клавиатурный драйвер будет их учитывать и изменять свое внутреннее состояние в зависимости от нажатой клавиши. Например через флаги EFI<em>NS</em>KEY<em>MODIFIER и EFI</em>NS<em>KEY</em>DEPENDENCY_MODIFIER реализуется поддержка &quot;мертвых клавиш&quot;.</p>

<p>Модель для разработчика выглядит примерно так же как и в случае со шрифтами: чтобы поддержать ввод символов например на русском языке нужно изготовить таблицу дескрипторов и загрузить ее в рантайме. Но как оказалось тут кроется подстава. В EDK две реализации клавиатурного драйвера: <a href="http://sourceforge.net/p/tianocore/edk2/ci/master/tree/MdeModulePkg/Bus/Usb/UsbKbDxe">UsbKbDxe</a> и <a href="http://sourceforge.net/p/tianocore/edk2/ci/master/tree/IntelFrameworkModulePkg/Bus/Isa/Ps2KeyboardDxe">Ps2KeyboardDxe</a>. Первый - драйвер USB клавиатуры, а второй - PS2, работающий через <a href="http://en.wikipedia.org/wiki/Intel_MCS-48">Intel 8042</a> контроллер. Как оказалось раскладки поддерживает только драйвер USB клавиатуры. Соответвенно для PS2 клавиатур нужно портировать код обработки раскладок.</p>

<p>Ситуацию усложняет еще и так называемый Lеgacy USB. Это стандартная фича USB контроллеров и биосов когда USB клавиатура эмулируется как PS/2 устройство через Intel 8042. Т.е. в большинстве случаев даже если в машину воткнута клавиатура через настоящий USB порт, то биос видит ее как PS/2 клавиатуру. Это можно исправить в ту или другую сторону, но проще не становится.</p>

<p>Итого. При условии что у нас есть драйвер PS/2 клавиатуры, который умеет работать с раскладками, то получается такой псевдокод добавление поддержки национальных символов:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">для каждого поддерживаемого языка:
    сгенерировать растровый шрифт национальных символов
    нарисовать раскладку клавиатуры с учетом диакритиков, мертвых клавиш и т.д.
    протестировать с реальной клавиатурой
конец
</code></pre></div>
<p>Для меня это не выглядит страшным, особенно если учесть, что можно избавится от первого шага сгенерировав &quot;большой&quot; юникодный шрифт один раз. Основная доля работы в раскладках и это будет точно не бесплатно, не из коробки, как в случае с линуксом например.</p>

<p>Мне удалось за один рабочий день корявенько локализовать ввод и вывод на русский язык. Я сгенерировал кривой шрифт и нарисовал раскладку, пока не уперся в то, что VmWare эмулирует клавиатуру как PS/2 устройство, драйвер которого в EDK не понимает раскладки. Но если вынести проблему с драйвером за скобки, то получается примерно такие трудозатраты для относительно простого (и главное знакомого) языка.</p>

    
    <span class="tags">
      
      <a href="/preboot/">preboot</a>
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/06/21/uefi-emulation-windows-boots-faster/">
        [UEFI Emulation] Windows boots (faster)
      </a>
    </h1>

    <time datetime="2013-06-21T22:49:11+07:00" class="post-date">21 Jun 2013</time>

    <p>Пребут на базе EDK/Duet загружается и с обычной скоростью загружает NT на 5 (из 5) тестовых реальных машинах. Какие проблемы были решены за эту неделю:</p>

<ol>
<li><p>Пожалуй основная проблема в том, что биосы стали очень умные. Многие стартуют сразу с включенным A20. Некоторые используют пейджинг, работая внутри ISR в защищенном режиме. Из-за этого восстанавливать нужно такие вещи как GDTR, CR0-4, состояние A20.</p></li>
<li><p>Проблема с замедлением загрузки NT была связана с тем, что биос, находясь в реальном режиме, считает тики таймера, прошедшие с момента загрузки. После ухода в EDK биос больше не видит прерываний таймера и тики начинают теряться. Если по возврату из EDK правильно посчитать сколько тиков прошло с момента загрузки и прописать это значение для биоса, то все грузится с обычной скоростью. Конкретный код, который завязан на значения тиков выяснить не удалось (нет дебаггера). Была придумана теория и проверена вслепую.</p></li>
<li><p>В DuetPkg есть баг, из-за которого происходит коррапт памяти ниже первого мегабайта: <a href="http://sourceforge.net/p/tianocore/edk2/ci/master/tree/DuetPkg/DxeIpl/HobGeneration.h#l26">http://sourceforge.net/p/tianocore/edk2/ci/master/tree/DuetPkg/DxeIpl/HobGeneration.h#l26</a>. Код по ссылке готовит для DxeCore (ядро EDK) т.н. HOB - HandOff Block. В этом блоке загрузчик прописывает таблицы страниц физической памяти, свободные на момент передачи управления из стадии DxeIpl в стадию DxeCore. К сожалению, авторы DxeIpl в дуэте решили захардкодить верхнюю границу диапазона доступной памяти ниже 1MB значением в 0x9F800, что соответствует 640 KB. Практически все современные биосы оставляют меньше свободной памяти, в районе 600KB. В результате при маппировании страниц ниже 1MB перетирается код биоса.</p></li>
</ol>

<p>Проблемы выше были исправлены и теперь все снова хорошо. Танцевать еще рано, но пританцовывать можно начинать.</p>

    
    <span class="tags">
      
      <a href="/BIOS/">BIOS</a>
      
      <a href="/preboot/">preboot</a>
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/06/18/uefi-emulation-windows-boots-slowly/">
        [UEFI Emulation] Windows boots (slowly)
      </a>
    </h1>

    <time datetime="2013-06-18T23:31:47+07:00" class="post-date">18 Jun 2013</time>

    <p>Хорошие новости - винда начала загружаться на реальном железе из эмулируемого UEFI :)</p>

<p>Плохие новости - она загружается минут 5 против секунд 15 если без меня. Потенциальные причины проблемы исследуются.</p>

    
    <span class="tags">
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/06/17/mind-map-researchers-best-friend/">
        Mind map - researcher's best friend
      </a>
    </h1>

    <time datetime="2013-06-17T15:43:20+07:00" class="post-date">17 Jun 2013</time>

    <p><a href="http://wrfsh.files.wordpress.com/2013/06/duet-console-output.png"><img src="http://wrfsh.files.wordpress.com/2013/06/duet-console-output.png?w=300" alt="Duet console output"></a></p>

    
    <span class="tags">
      
    </span>

    </article>
    
    <article class="post">
      <h1 class="post-title">
      <a href="/2013/06/16/uefi-emulation-biosthunk-and-protected-mode-versus-real-mode-interrupts/">
        [UEFI Emulation] BiosThunk and protected mode versus real mode interrupts
      </a>
    </h1>

    <time datetime="2013-06-16T20:31:38+07:00" class="post-date">16 Jun 2013</time>

    <p>DuetPkg для реализации доступа к жесткому диску предоставляет драйвера IDE/SATA/AHCI. Я не хочу опираться на них, потому что мне нужно в итоге вернутся в реальный режим для загрузки хостовой ОС, а драйвера портят картину мира для биоса. Выход - опираться на INT 13h. Но тут встает проблема с прерываниями.</p>

<p>Как работает доставка прерываний в Legacy режиме:</p>

<ul>
<li><p>Железо генерирует прерывание используя линию IRQ</p></li>
<li><p>Intel 8259A программируемый контроллер прерываний содержит маппинг IRQ -&gt; Software interrupt line. Прерывание от железа маппируется на софтверное прерывание процессора. Типичный маппинг это IRQ 0h - 7h -&gt; INT 8h - Fh и IRQ 8h - Fh -&gt; INT 70h - 77h.</p></li>
<li><p>Типично для режима совместимости первый жесткий диск использует IRQ 14, которая маппируется на INT 76h. В результате когда жесткий диск хочет сообщить например о завершении запроса на чтение, то он ассертит IRQ 14, что приводит к софтверному прерыванию 76h. Процессор выполняет софтверный обработчик, навешанный на это прерывание.</p></li>
</ul>

<p>Как процессор определяет где находится обработчик прерывания 76h? Здесь все зависит от режима процессора:</p>

<p>В реальном режиме 8086 по линейному адресу 0x0 содержится таблица указателей на обработчики прерываний. Каждый элемент длинной 4 байта и содержит segment:offset указатель на 16-ти битный код обработчика. BIOS инициализирует эту таблицу указателями на обработчики при старте машины. Процессор просто достает 4 байта по смещению 0x76 * 0x4, интерпретирует это как segment:offset указатель и выполняет icall туда.</p>

<p>В защищенном режиме все устроено сложнее. Вместо таблицы указателей с известным оффсетом процессор требует от системного программного обеспечения проинициализировать регистр IDTR, в котором должен быть адрес на описание дескрипторов IDT. IDT похож на GDT в том плане, что в нем содержится 4 байтовый линейный адрес на начало таблицы обработчиков прерываний и ее размер. Сама таблица содержит структуры дескрипторов обработчиков прерываний. Их структуру я объяснять не буду, подробнее можно почитать здесь: <a href="http://wiki.osdev.org/IDT">http://wiki.osdev.org/IDT</a>. Суть в том, что в защищенном режиме процессор использует (установленное софтом) значение регистра IDTR для поиска указателя на процедуру - обработчик прерывания.</p>

<p>В чем проблема?</p>

<p>Наше окружение на базе UEFI работает в защищенном режиме, а это значит что оно должно предоставлять IDT. Для чтения диска мы хотим опираться на BIOS, но BIOS работает в реальном режиме, в котором процессор ничего не знает про IDTR и хочет простую таблицу указателей на 16-ти битный код. Когда мы вовращаемся из защищенного режима в реальный, то все будет работать нормально, потому что обработчики BIOSа окажутся на месте. Что делать когда мы работаем в защищенном режиме? Прерывания доставляются асинхронно и BIOS не будет о них знать, если мы не будем их форвардить. Вопрос, нужно ли из форвардить или нет? DuetPkg этого не делает, но это ни о чем не говорит.</p>

<p>С DuetPkg в этом плане еще хуже. Он использует механизм BiosThunk для реализации EFI<em>GRAPHICS</em>OUTPUT_PROTOCOL через ISR 10h биоса: <a href="http://sourceforge.net/p/edk2/code/HEAD/tree/trunk/edk2/DuetPkg/BiosVideoThunkDxe">BiosVideoThunkDxe</a>. Что именно там происходит я описывать не буду - главное то, что код вектора 10h исполняется с выключенными прерываниями. Драйвер возвращается в реальный режим, но при этом весь код, выполняющийся там, выполняется с выключенными прерываниями. Вместо инструкции int драйвер напрямую вызывает код обработчика по указателю. Это значит, что использовать такой механизм для вызова INT 13h нельзя, потому что INT 13h ожидает от диска ответного прерывания по окончанию запроса, с таймаутом. До получения такого ответа он не возвращается, а по истечению таймаута возвращается с ошибкой. Даже если в защищенном режиме реализован форвардинг прерываний в BIOS, то он сработает слишком поздно - когда int 13h уже вернулся, потому что прерывания от диска не было. Clover, как оказалось, своим драйвером диска поверх INT 13h не пользуется.</p>

<p>Почему Duet так делает? Потому что во-первых у него есть драйвера дисков, во-вторых он не хочет пропустить прерывания когда делает thunk в 16-ти битный код и в третьих потому что 10h прерывания не нужны для работы. Проблема есть, но пока она роли не играет. Если мы уходим в реальный режим &quot;насовсем&quot;, т.е. чтобы загрузить хостовую ОС, то нам не нужен thunk. Проблема будет, когда мы захотим прочитать с диска во время работы. Решить это можно грубо, включив таки прерывания во время thunk-а и перенаправив их в обработчики биоса. Тогда Duet может потерять несколько прерываний. В крайнем случае придется мутить что-то страшное наподобие редиректора прерываний в оба режима.</p>

    
    <span class="tags">
      
      <a href="/preboot/">preboot</a>
      
      <a href="/UEFI/">UEFI</a>
      
    </span>

    </article>
    
    </div>

    <div class="pagination">
      
      <a class="pagination-item older" href="/page5">Older</a>
      
      
      
      <a class="pagination-item newer" href="/page3">Newer</a>
      
      
    </div>

  </div>
      
  <div class="sidebar">
    <ul class="post-list">
      
      <!-- a style="font-size: 220%" href="/BIOS/">BIOS</a -->
      <li><a href="/BIOS/">BIOS</a></li>
      
      <!-- a style="font-size: 120%" href="/device state/">device state</a -->
      <li><a href="/device state/">device state</a></li>
      
      <!-- a style="font-size: 303%" href="/preboot/">preboot</a -->
      <li><a href="/preboot/">preboot</a></li>
      
      <!-- a style="font-size: 370%" href="/UEFI/">UEFI</a -->
      <li><a href="/UEFI/">UEFI</a></li>
      
      <!-- a style="font-size: 120%" href="/crypto/">crypto</a -->
      <li><a href="/crypto/">crypto</a></li>
      
      <!-- a style="font-size: 236%" href="/doom-uefi/">doom-uefi</a -->
      <li><a href="/doom-uefi/">doom-uefi</a></li>
      
    </ul>
  </div>

</div>



      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2015-01-28T18:42:37+06:00">2015</time>. All rights reserved.
        </small>
      </footer>

    </div>


  </body>
</html>
